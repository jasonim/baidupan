<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonThink&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hujiandong.com/"/>
  <updated>2017-03-11T08:34:05.000Z</updated>
  <id>http://hujiandong.com/</id>
  
  <author>
    <name>JasonThink</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你了解泛型通配符与上下界吗？</title>
    <link href="http://hujiandong.com/2017/03/11/java_generices_bounded/"/>
    <id>http://hujiandong.com/2017/03/11/java_generices_bounded/</id>
    <published>2017-03-11T02:30:16.000Z</published>
    <updated>2017-03-11T08:34:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你了解泛型通配符与上下界吗？"><a href="#你了解泛型通配符与上下界吗？" class="headerlink" title="你了解泛型通配符与上下界吗？"></a>你了解泛型通配符与上下界吗？</h1><p>在进入主题之前， 我们先简单说一下 Java 的泛型（generics）。它是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。</p>
<p>今天我们主要说如下类型：</p>
<ul>
<li>泛型的背景</li>
<li>通配符以及上下界</li>
<li>泛型及通配符的使用场景</li>
</ul>
<h2 id="为什么使用泛型及背后的问题？"><a href="#为什么使用泛型及背后的问题？" class="headerlink" title="为什么使用泛型及背后的问题？"></a>为什么使用泛型及背后的问题？</h2><p>我们来看一下官方的说法：</p>
<blockquote>
<ul>
<li>Stronger type checks at compile time. A Java compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find.</li>
<li>Elimination of casts.</li>
<li>Enabling programmers to implement generic algorithms. By using generics, programmers can implement generic algorithms that work on collections of different types, can be customized, and are type safe and easier to read.</li>
</ul>
</blockquote>
<p>是的， 终止目的就是想把程序员解放出来，关注他们更应该关注的事情上面去。当我第一次学习 Java 的泛型时，总感觉它类似于 C++ 中的模板。但随着慢慢的深入了解发现它们之间有本质的区别。</p>
<p>Java 中的泛型基本上完全在编译器中实现，由编译器执行类型检查和类型推断，然后生成普通的非泛型的字节码。这种实现技术称为 擦除（erasure）（编译器使用泛型类型信息保证类型安全，然后在生成字节码之前将其清除），这项技术有一些奇怪，并且有时会带来一些令人迷惑的后果。</p>
<p>对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面来说，上面已经说了，主要是在编译时刻就能发现很多明显的错误。而从不好的地方来说，主要是为了保证与旧有版本的兼容性，Java 泛型的实现上存在着一些不够优雅的地方。</p>
<p>下面我们来看一下，泛型类型的一个定义，后面我们要在这个的基础上进行改造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">// T stands for "Type"</span></div><div class="line">	<span class="keyword">private</span> T t;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T t)</span> ￼ ￼</span>&#123; <span class="keyword">this</span>.t = t;￼ &#125;￼</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来下面我们来聊聊 Java 泛型的通配符， 记得刚开始看到通配符（？）时我是惊喜的，因为既然有通配符那么就可以这样定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSometing</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</div><div class="line">	list.add(<span class="number">1</span>); <span class="comment">//illegal</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可是我们如上写法，总是出现编译错误，然后从惊喜变成惊吓，心想有什么卵用了。最后发现原因是在于通配符的表示的类型是未知的。那在这种情况下，我们可以使用上下界来限制未知类型的范围。好吧，写了那么多， 终于等到今天的主角登场了，容易吗？</p>
<p>还记得我们上面定义的 Box 吗， 现在我们再定义 Fruit 类以及它的子类 Orange 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123; &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们想它里面能装水果，那么我可以这么写。<br><code>Box&lt;Fruit&gt; box = Box&lt;Orange&gt;(new Orange) //illegal</code></p>
<p>不幸的是编译器会报错，这就尴尬了，why？why？ why？实际上，编译器认为的容器之间没有继承关系。所以我们不能这样做。</p>
<p>为了解决这样的问题， 大神们想出来了&lt;? extens T&gt; 和 &lt;? super T&gt; 的办法，来让它们之间发生关系。</p>
<h2 id="上界通配符（Upper-Bounded-Wildcards）"><a href="#上界通配符（Upper-Bounded-Wildcards）" class="headerlink" title="上界通配符（Upper Bounded Wildcards）"></a>上界通配符（Upper Bounded Wildcards）</h2><p>现在我们把上面的 Box 定义改成：<br><code>Box&lt;? extends Fruit&gt;</code></p>
<p>这就是上界通配符， 这样 Box<fruit> 及它的子类如 Box<orange> 就可以赋值了。<br><code>Box&lt;? extends Fruit&gt; box = new Box&lt;Orange&gt;(new Orange)</code></orange></fruit></p>
<p>当我们扩展一下上面的类， 食物分成为水果和蔬菜类， 水果有苹果和橘子。<br>在上面的结构中， Box&lt;? extends Fruit&gt; 涵盖下面的蓝色的区域。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/upper.png" alt=""></p>
<h3 id="上界只能外围取，不能往里放"><a href="#上界只能外围取，不能往里放" class="headerlink" title="上界只能外围取，不能往里放"></a>上界只能外围取，不能往里放</h3><p>我们先看一下下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Box&lt;? extends Fruit&gt; box = <span class="keyword">new</span> Box&lt;Orange&gt;(<span class="keyword">new</span> Orange);</div><div class="line"></div><div class="line"><span class="comment">//不能存入任何元素</span></div><div class="line">box.set(<span class="keyword">new</span> Fruit);  <span class="comment">//illegal</span></div><div class="line">box.set(<span class="keyword">new</span> Orange);<span class="comment">//illegal</span></div><div class="line"></div><div class="line"><span class="comment">//取出来的东西只能存放在Fruit或它的基类里</span></div><div class="line">Fruit fruit = box.get();</div><div class="line">Object fruit1 = box.get();</div><div class="line">Orange fruit2 = box.get(); <span class="comment">//illegal</span></div></pre></td></tr></table></figure></p>
<p>上面的注释已经很清楚了， 往 Box 里放东西的 set() 方法失效， 但是 get() 方法有效。</p>
<p>原因是 Java 编译器只知道容器内是 Fruit 或者它的派生类， 但是不知道是什么类型。可能是 Fruit、 可能是 Orange、可能是Apple？当编译器在看到 box 用 Box<orange> 赋值后， 它就把容器里表上占位符 “AAA” 而不是 “水果”等，当在插入时编译器不能匹配到这个占位符，所有就会出错。</orange></p>
<h2 id="下界通配符（Lower-Bounded-Wildcards）"><a href="#下界通配符（Lower-Bounded-Wildcards）" class="headerlink" title="下界通配符（Lower Bounded Wildcards）"></a>下界通配符（Lower Bounded Wildcards）</h2><p>和上界相对的就是下界 ，语法表示为：<br><code>&lt;? super T&gt;</code></p>
<p>表达的相反的概率：一个能放水果及一切水果基类的 Box。 对应上界的那种图， 下图 Box&lt;? super Fruit&gt; 覆盖黄色区域。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/lower.png" alt=""></p>
<h3 id="下界不影响往里存，但往外取只能放在Object-对象里"><a href="#下界不影响往里存，但往外取只能放在Object-对象里" class="headerlink" title="下界不影响往里存，但往外取只能放在Object 对象里"></a>下界不影响往里存，但往外取只能放在Object 对象里</h3><p>同上界的规则相反，<strong>下界不影响往里存，但往外取只能放在Object 对象里</strong>。</p>
<p>因为下界规定元素的最小的粒度，实际上是容器的元素的类型控制。所以放比 Fruit 粒度小的如 Orange、Apple 都行， 但往外取时， 只有所有类的基类Object对象才能装下。但是这样的话，元素的类型信息就全部消失了。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在使用泛型的时候可以遵循一些基本的原则，从而避免一些常见的问题。</p>
<ul>
<li>在代码中避免泛型类和原始类型的混用。比如List<string>和List不应该共同使用。这样会产生一些编译器警告和潜在的运行时异常。当需要利用JDK 5之前开发的遗留代码，而不得不这么做时，也尽可能的隔离相关的代码。</string></li>
<li>在使用带通配符的泛型类的时候，需要明确通配符所代表的一组类型的概念。由于具体的类型是未知的，很多操作是不允许的。</li>
<li>泛型类最好不要同数组一块使用。你只能创建new List&lt;?&gt;[10]这样的数组，无法创建new List<string>[10]这样的。这限制了数组的使用能力，而且会带来很多费解的问题。因此，当需要类似数组的功能时候，使用集合类即可。</string></li>
<li>不要忽视编译器给出的警告信息。</li>
</ul>
<h3 id="PECS-原则"><a href="#PECS-原则" class="headerlink" title="PECS 原则"></a>PECS 原则</h3><p>如果要从集合中读取类型T的数据， 并且不能写入，可以使用 上界通配符（&lt;？extends&gt;）—Producer Extends。</p>
<p>如果要从集合中写入类型T 的数据， 并且不需要读取，可以使用下界通配符（&lt;? super&gt;）—Consumer Super。</p>
<p>如果既要存又要取， 那么就要使用任何通配符。</p>
]]></content>
    
    <summary type="html">
    
      你了解泛型通配符与上下界吗？
    
    </summary>
    
      <category term="java" scheme="http://hujiandong.com/categories/java/"/>
    
    
      <category term="java" scheme="http://hujiandong.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>编写可读代码的艺术</title>
    <link href="http://hujiandong.com/2017/02/22/readable-code/"/>
    <id>http://hujiandong.com/2017/02/22/readable-code/</id>
    <published>2017-02-22T07:30:16.000Z</published>
    <updated>2017-02-27T10:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚毕业的时候读过 Bob 大叔的《Clean Code》， 那时候只是被动接受，没有进行更有效的思考，现在也忘记的差不多了。记得在进行公司培训时一部分内容就是代码规范和公司常用的推荐写法，当时也不知道为什么这样子做， 老大告诉我们，<strong>这就是团队做出的决定，喜欢不喜欢照做就是。</strong></p>
<p>开发中我们不可避免的要阅读别人代码，一般会出现两种场景：</p>
<ul>
<li>哇，这块代码写的太棒了， 结构简单、逻辑清晰。</li>
<li>艹，这代码写的一坨坨的，也不知道他在表达什么，写的人是不是当时脑袋被门挤压后写下的代码。</li>
</ul>
<p>我们当然不想成为第二种，那什么样的代码符合可读性的特质？</p>
<blockquote>
<p><strong>可读性 == 可测试 == 代码质量 == 代码优雅 </strong><br>是的， 它们自己是等价的</p>
</blockquote>
<p>这本书译版不过170多页很薄，通过漫画的形式展示每个主题，幽默合理，直指问题要害，阅读起来很有趣，有图有真相。主要分四大部分：</p>
<ul>
<li>表面层次的改进</li>
<li>简化循环和逻辑</li>
<li>重新组织代码</li>
<li>测试与可维护</li>
</ul>
<h2 id="表面层次的改进"><a href="#表面层次的改进" class="headerlink" title="表面层次的改进"></a>表面层次的改进</h2><p><strong>谈到如何命名？</strong></p>
<ul>
<li>避免使用专业词汇。</li>
<li>避免空泛的名字。</li>
<li>为作用域大的名字采用更长的名字</li>
</ul>
<p><strong>如何添加注释？</strong></p>
<ul>
<li>不要为了写注释而写注释</li>
<li>不要给不好的名字加注释—应该改进命名和重构</li>
<li>为代码中的瑕疵写注释：这里单独提一下 HACK（以前没有注意过）—-对一个问题不得采取的粗糙解决方案</li>
</ul>
<h2 id="简化循环和逻辑"><a href="#简化循环和逻辑" class="headerlink" title="简化循环和逻辑"></a>简化循环和逻辑</h2><p>文中提到条件语句中参数的顺序、告诉我们可以通过重新排列 if/else 语句中的语句块。通常来讲，先处理正确的/简单的/有趣的情况。有时候这些准则会冲突，但是当不冲突时， 这是要遵循的经验法则。</p>
<p>通常来讲提早返回可以减少嵌套并让代码整洁。</p>
<p>一个简单的技术是引入「解释变量」来代表较长的子表达。这种方式有三个好处：</p>
<ul>
<li>它把巨大的表达拆成小段</li>
<li>它通过用简单的名字描述子表达式来让代码文档化</li>
<li>它帮助读者识别代码中的主要概率</li>
</ul>
<h2 id="重新组织代码"><a href="#重新组织代码" class="headerlink" title="重新组织代码"></a>重新组织代码</h2><p>文中提到「抽取不相关的子问题」和 Martin Fowler 在中《重构》描述的重构的「抽取方法」相似，而他写的更为详细， 感兴趣的可以去读读。</p>
<p>如何可以少写代码</p>
<ul>
<li>从项目中消除不必要的功能，不要过度设计。</li>
<li>重新考虑需求，解决版本最简单的问题，只有能完成工作就行。</li>
<li>经常性的通读标准库的整个 API，保持对它们的熟悉程度。</li>
</ul>
<h2 id="测试与可维护"><a href="#测试与可维护" class="headerlink" title="测试与可维护"></a>测试与可维护</h2><p>文中提到，在测试代码中，可读性也很重要。如果测试的代码可读性好，其结果是它们会变得很容易些， 因此大家会更多的测试。并且，如果你把真实代码设计的容易测试，代码整个设计会变得更好。</p>
<p>以下是如果改进测试的几个具体要点：</p>
<ul>
<li>每个测试的最高一层应该越简洁越好。最好每个测试的输入/输出可以用一行代码来描述。</li>
<li>如果测试失败了， 它所发出来的错误消息应该能让你容易跟踪并修正这个 bug。</li>
<li>使用最简单的并且能够完整的运用代码的测试输入。</li>
<li>给测试函数取一个完整的描述性的名字，以使每个测试所测到的东西很明确。</li>
</ul>
<p>作者也提到测试走的太远的情况：</p>
<ul>
<li>牺牲真实代码的可读性，只是为了使用测试</li>
<li>着迷于100%的 测试覆盖率</li>
<li>让测试成为产品开发的阻碍</li>
</ul>
<p><strong>思维导图</strong><br>![][<a href="http://sonicwu.com/statics/images/the-art-of-readable-code-m.jpg" target="_blank" rel="external">http://sonicwu.com/statics/images/the-art-of-readable-code-m.jpg</a>])<br>就想本书的名字一样，艺术这个东西本来就是每个人鉴别的方式不一样，但是称得上艺术的东西， 一定符合艺术评断标准的。</p>
<p>编码规范这种事情，本来都是有主观有客观的。</p>
<p>像字节编码、换行、命名之类的事情就是主观的，在公司团队开发中就应该硬性统一，以便协作流畅。</p>
<p>最近阿里巴巴发布一个Java 编码规范—《阿里巴巴Java开发手册（正式版）》，设计编码的方方面面，有兴趣的同学可以看一下。 </p>
<p>我也大致撸了一遍， 文档本身没有太大问题，不过，在网页、Github 高度发达的今天，为什么阿里没有选择将它放在网页上，而是用 PDF 的形式发布？为什么不做成类似：</p>
<blockquote>
<p>Google Java Style Guide<br>[<a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="external">https://google.github.io/styleguide/javaguide.html</a>]</p>
</blockquote>
<p>有人说，编码规范这种东西就是体现「码农」和「工程师」本质区别的地方。</p>
<p>知乎上有个相关的问题「如何写出优雅的代码？」，我很赞同下面的回答：</p>
<blockquote>
<p>多写，写的少的说啥都是空话。<br>讲语法和应用的书一般培养不出所谓的「优雅」，不是作者水平不高的问题，是这样的书就应该务实，不扯淡。<br>将编程美感的书，一般来说，如果写代码不够多，只是读书，毫无收益，只会害自己。所以还是要写。</p>
</blockquote>
<p>其实什么样的代码是优雅的， 可读性好，可能也不过是自以为罢了。掌握一些基本的技巧就好了， 如果大家都严格遵循那些条条框框， 也不会有那么多不同语言和框架了。</p>
<p>最后所谓的代码优雅不过是程序员们用来自慰的工具罢了。爽于不爽只有自己知道。</p>
]]></content>
    
    <summary type="html">
    
      编写可读代码的艺术
    
    </summary>
    
      <category term="读书" scheme="http://hujiandong.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="http://hujiandong.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>写给我心中的她</title>
    <link href="http://hujiandong.com/2017/02/14/happy-valentines-2017/"/>
    <id>http://hujiandong.com/2017/02/14/happy-valentines-2017/</id>
    <published>2017-02-14T07:30:16.000Z</published>
    <updated>2017-02-15T03:38:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想写一篇关于她的文章， 以前认为这是我们之间的事件， 不适合分享。反过来想，除了岁月我们还有诗和远方。</p>
<p>今天是情人节， 往年我都会在家附近买一支玫瑰送给她。而今年我早早的几天前我已经在网上预订定了一束，送到她的公司里去了。</p>
<p>我和她认识的时候， 我大二她大三，一个朋友介绍下我们在中秋节的晚上，我们见了面也吃了饭。当然我也知道， 像长成我这样， 肯定没几个女孩会看上我的。见面的结果可想而知—两个字「没戏」。不过爸妈从小教导我，遇到事件不要怕，要勇敢面对。</p>
<p>然后我就制定一套泡妞计划，其实也不是计划，一没钱、二没人。幸亏这时候「脸皮」同学出现了， 他说帮我在前面打前阵。就这样屡战屡败、屡败屡战情况， 终于在一个月后， 当然是我胜利了，不然我就再这里不写了。</p>
<p>有的童鞋会问， 他也给他喜欢的人打电话， 也发信息， 人家根本不 care， 咋办？给你们说一个朋友的真实例子，他当年追一个女孩的时候， 女孩不搭理他， 他就在她宿舍下面给他电话发信息说，他就在她们宿舍下面等她，如果不来，他每天都来， 直到她下来为止 。大约一周左右，那个女孩也就下来了。</p>
<p>我当然不是鼓励大家按照上面的方法去做， 只是想给我朋友说， 下次再遇到这样的事情， 请带上被子， 不然感冒了， 就没然后了。</p>
<p>像大部分大学情侣一样，我们就这样无忧无虑的交往着，因为我们不是一个学校， 除了周末在一块，平时也很少见面。当然我就有大部分时间，做我自己喜欢的事情， 打篮球、喝酒等等。 </p>
<p>因为她们老家那边，有订婚的说法（后来知道这是为了告诉别人， 我们女儿已经找好， 都不要上门提亲了）， 我大三暑假的时候双方完成订婚，其实也很简单，一块吃了顿饭，买了一个戒指，给了1万1千礼金（那是2010年）。</p>
<p>快毕业我就来北京了，以前我再xxx提到，我的第一台笔记本电脑和在北京培训的钱有一部分是她友情赞助的。 找到工作以后， 过完年她辞职给我一块来北京了， 最开始我们租的房子住在回龙观东大街那边，八九平米左右的房间， 每天挤公交和地铁上班。她也很少买衣服和化妆品，夏天的衣服一般不会超过150。</p>
<p>虽然那时候没钱， 不过也没感觉很苦（至少我是这样认为的， 因为没有和她两个这个话题，也不知道她是不是和我的观点一样）。</p>
<p>因为我们也谈了四五年时间，双方父母也催着我们结婚。 我们当时订在同年十一举办婚礼， 原本想家里都准备好了，我们只是回去就可以了。哪只离结婚还有大概二三个月时间， 家里有点变动，希望我们旅游结婚， 不要回家办婚礼了， 过年回来以后双方再一块吃个饭就行了。</p>
<p>由于我在中间没处理好， 被她误解为，她结婚什么也没找你父母要，你父母结婚连回家都不让回，是不是瞧不起她？当时我也有点生父母的气，再给我打电话说让我们回去，我也赌气说不回去办婚礼了， 十一我们去青岛玩了一周， 就这样我们算结婚了。直到现在我的一些同学还以为我们回家办的婚礼了，因为最开始的时候说的是回家办。</p>
<p>现在回想起来只能说当时 「too young too die」， 为什么赌气呢？以前要是吵架，她就会说， 你家人结婚时怎么对我的？每次被问到， 太多的解释都是演示。 </p>
<p>现在每被问到，如果结婚办婚礼还是旅游结婚时？我会说还是办场婚礼吧，谁心里苦谁知道，反正我挺苦的。 </p>
<p>可能为了缓和结婚对她的伤害，还有就是需要同年12月左右的时候，我们开始看房子， 其实当时手里就是结婚家里给了一点钱， 大概几万块吧。记得当时北京的均价在一万七八左右吧，西边和南北还会更便宜一些， 由于当时限购政策的原因，看中一套房子没弄成事。然后又去了燕郊和固安看了看，可能去的时候太堵的原因， 当时也主要考虑自住，最终放弃那两个地方。  </p>
<p>最后我把目标放到了我们上学的地方—郑州，毕竟那里有我们两个人的回忆，打了几个电话， 大致确定我们能承受的范围，就让我同学去那里交了定金选了房，事后才知道户型是置业帮忙选的。</p>
<p>其实这个价格当时已经超出我们预算了， 我当时其实想放弃的，想等等再买的。 记得那时还在上班，给她打电话时她说没事剩下的她来想办法。要不是她的这句话我也不会买，当时那套房子写的是她的名字。</p>
<p>怀孕的时候由于小孩早产， 她也遭了很多罪， 不管身体还是心理上都是。还好我们挺过来了，现在不真不想回想那段日子。</p>
<p>由于去年买房子时， 我们离了婚，但我们都知道那只是一个形式而已， 对我们没有实质性的改变。</p>
<p>你们也知道是睡了， 是的， 她就是我两任妻子，小孩的妈妈。</p>
<p>当我遇到事情的时候，她很少责备我， 总是鼓励我。说实话我为她做的事情也很少， 可能我不懂的爱情，也可能不懂的她要的爱。谢谢付出和不离不弃，我会尽里拼搏，直到感动自己的那一天到来为止。 </p>
<p>喜欢你是件很骄傲的事情，不是秘密。</p>
<p>在今天这个特殊的日子， 她并没有关注我的公众号，也不是特意给她看的。写这些只是回忆我们匆匆走过的时光。可能还有很多男男女女，如果你还单身， 请想办法脱单；如果你有伴侣，请相互珍惜，可能眼下的路并不好走， 只要认真坚持，未来一定是你们的。</p>
<p>最后，祝天下有情人终成眷属！</p>
]]></content>
    
    <summary type="html">
    
      写给我心中的她
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="随笔" scheme="http://hujiandong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>正确使用 Mac 的姿势</title>
    <link href="http://hujiandong.com/2017/01/18/mac-os-guide/"/>
    <id>http://hujiandong.com/2017/01/18/mac-os-guide/</id>
    <published>2017-01-18T02:33:33.000Z</published>
    <updated>2017-01-18T02:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>不像很多达人上大学或者更早时间就开始就使用 Mac， 我从15年12月份才开始用，到现在已经有一年多时间。Mac 现在成为我的御用电脑， 当然工作中我还没有完全切换到 Mac 上来，主要开发还在用 Ubuntu 进行开发。和 Ubuntu 一样它们都用相同的特点：</p>
<ul>
<li>没有右下角弹窗的打扰，没有流氓软件，能让你注意力更集中。</li>
<li>强大的终端操作。</li>
</ul>
<p>当然它更有别的操作系统不具备的—精美的UI设计和触摸板。如果你还没有， 那么你值得拥有，不过 New MacBook proc 的设计我不是很喜欢，可能我的审美还不到苹果设计师的 level。如果你为了打游戏就算了， 当然 Window 是你的唯一选择。 </p>
<p>下面我们说说 Mac OS X 下常用的软件及快捷键, 当然如果你想达到更正确的姿势，配着多屏和机械键盘就更佳。</p>
<h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><p><strong>Alfred</strong><br>Alfred 是一个非常强大的效率工具。快捷键呼出search框，输入你想找的任何东西得首字母或者前几位、缩写，然后上下方向键找到你的目标，回车就行。 还可以定在快捷键。<br><img src="https://user-gold-cdn.xitu.io/2016/11/29/44a17b11718e7fb3f5ccf45baa46dc18.jpg" alt=""><br><img src="https://user-gold-cdn.xitu.io/2016/11/29/2fb907101c8efd0ecf0d3b79049d91d5.png" alt=""></p>
<blockquote>
<p>Alfred3<br><a href="https://www.alfredapp.com/" target="_blank" rel="external">https://www.alfredapp.com/</a></p>
</blockquote>
<p><strong>iTerm</strong><br>专为 Mac OS 用户打造的命令行应用, 以前我还专门介绍过它， 有兴趣的可以看一下原文 <a href="http://hujiandong.com/2016/09/11/iterm2/">打造最强终端-iTerm 2</a>。</p>
<p><strong>Dash</strong><br>非常强大的文档查看器。<br>当你写东西的时候可能会同时用到好几个文档。Dash帮你管理你的文档。不用再切窗口了！<br>所有的文档都可以下载到本地，再不用忍受蜗牛速度去看国外的文档了， 我以前用来看 Android 文档。<br><img src="http://7xnilf.com1.z0.glb.clouddn.com/dash.png" alt=""></p>
<p><strong>Ulysses</strong><br>Ulysses 是我用过最好的写作软件，我在上面写出了近五万的文字。它的特点是：</p>
<ul>
<li>全平台支持</li>
<li>沉浸式写作</li>
<li>搜索功能</li>
</ul>
<p><img src="http://cdn.macrumors.com/article-new/2016/03/Ulysses-app-800x444.jpg" alt=""><br><strong> Manico</strong><br>在 OS X 下，我们想要启动或切换应用时，通常有以下三个选择：</p>
<ul>
<li>对于常用应用，将鼠标光标移动到屏幕下方打开 Dock 栏，从中选择需要启动或切换的应用打开；</li>
<li>对于已经启动的应用，按下「Command + Tab」呼出切换器，按 Tab 键或使用鼠标选择需要切换的应用打开；</li>
<li>对于既没有放在 Dock 栏也没有启动的应用，可以通过 Launchpad 或 Spotlight 搜索应用打开。</li>
</ul>
<p>对于习惯使用键盘的「效率党」而言，上面的几种方式并不够高效。有没有什么办法，可以整合这三种方式，并通过快捷键组合便能实现快速应用启动和切换呢？Manico 的出现为「效率党」提供了一个简单、易用、高效的快速启动和切换 App 的方式。</p>
<p>下图是我的快捷键配置：<br><img src="http://7xnilf.com1.z0.glb.clouddn.com/manico.png" alt=""><br><strong> Clyppan</strong><br>OS X 系统的剪切板默认只保存最后一次复制或是剪切的内容，所以你想粘贴前几次复制的内容时…不好意思，再切过去、选择、复制一遍。</p>
<p>我以前经常遇到这样的场景， 直到有一天看到大和童鞋使用 Clyppan 以后， 妈妈再也不用担心重复拷贝了。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/clippan.png" alt=""></p>
<p><strong>Hammerspoon</strong><br>有没有使用多屏的用户， 一般程序员和设计喜欢用多屏， 其实条件容许， 每个人都应该多配一个屏， 能很大提升我们的工作效率。</p>
<p>Hammerspoon 是一个多屏幕窗口管理软件，首先它是开源的，其次使用 Lua 脚本作为配置文件。</p>
<p>[<a href="http://www.hammerspoon.org/" target="_blank" rel="external">http://www.hammerspoon.org/</a>]</p>
<p><strong>awesome-mac</strong><br>这是一个 Github 项目，主要是收集非常好用的Mac应用程序、软件以及工具，主要面向开发者和设计师。</p>
<blockquote>
<p>[<a href="https://github.com/jaywcjlove/awesome-mac" target="_blank" rel="external">https://github.com/jaywcjlove/awesome-mac</a>]</p>
</blockquote>
<p>当然还有文本编辑器， 网友很多推荐 Atom 或 Sublime Text，不过我没有用过， 因为我用 emacs，选一个自己喜欢的就行。</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><blockquote>
<p>Command + C， Command + V，Command + A ：这几个大家都知道，不过尽量别用在代码拷贝上。<br>Command + Delete ： 删除当前行。选中文件的时候直接删除文件。<br>shift+方向键 ： 这个在选择文本的时候很有用，可以选择单个字符或者整行，多使用才能找到手感。<br>Command + Shift + 左右方向键：这个可以快速选择当前行，用的也很多<br>Control + A：跑到当前行的最前端，使用频次很高<br>Control + E：跑到当前行的最尾端，使用频次很高，还有 B、F 光标向前移动和向后移动<br>Command + TAB：切换应用，这是大部分人用的最多的方式，却不是最高效的方式，后面会介绍其他方式<br>Command +` : 切换同一应用的窗口，这个非常实用。比如打开多个 Android Studio 工程的情况下，快速的在不同项目之间切换。 Finder，Firefox等场景下都支持<br>Command + W：关闭当前窗口，后面会介绍其他方式，同样高效<br>Command + Q：关闭当前应用<br>Command + N：新建窗口，比如打开新的Finder窗口，配合cmd+w很实用<br>Command + I : 显示当前文件的信息，查看文件大小，图片宽高的时候有用<br>选中文件按空格预览：预览图片或者pdf文件时有用。配合方向键可以快速预览多张图片<br>Command + F：查找， Command + G 查找下一个； Command +Shift + G 向上查找<br>Control + Command + D：英文单词，完成取词翻译</p>
</blockquote>
<h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><blockquote>
<p>Command + T ： 这是基本全局打开新标签的标准键，会用的很多<br>Command + L ：光标移到地址框<br>Command + R ：刷新页面<br>Command + + ：大屏幕的时候很实用，放大页面，基本也是全局型的。 0是恢复默认大小<br>Command + W ： 关闭当前标签。不要和退出按错了<br>Command + Q ：退出当前软件，其他软件也都可以用<br>Command + D ：收藏当前页面<br>空格 ： 屏幕下滚一页<br>Command + Z ：Safari的恢复刚关闭标签就是熟悉的<br>Command + Shift + T：Chrome是和打开差不多的，Chrome这个功能更强大，就是可以按顺序恢复，但是Safari只能恢复最近的一个。这个功能我一直用，经常手抖关闭的一瞬间发现有用。</p>
</blockquote>
<p>当然如果你是 Vim 「中毒」党你也可以在 Chrome 上装上插件， 反正我是装了，不过很少用。</p>
<p>最后送自己和大家一些话， 当然做上面的事你首先有一台 Mac：</p>
<blockquote>
<p>If you’re interested, you come up with stories, excuses, reasons, and circumstances about why you can’t or why you won’t. If you’re committed, those go out the window. You just do whatever it takes.</p>
</blockquote>
<p><strong>PS</strong>：<br>又到了春运时间了， 你们需要回到父母身边吗？是不是还有人没有买到票的？今年要去我媳妇那边过年，正好今年公司年会在外地开， 开完以后就放假了，终于今年可以早点回去了。</p>
]]></content>
    
    <summary type="html">
    
      正确使用 Mac 的姿势
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>程序员最应该读的书</title>
    <link href="http://hujiandong.com/2017/01/18/programer-book/"/>
    <id>http://hujiandong.com/2017/01/18/programer-book/</id>
    <published>2017-01-18T02:26:15.000Z</published>
    <updated>2017-01-18T02:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司在推行程序员应该买什么书读的话题， 也买了一大堆书供大家阅读。以前也被别人问到类似问题—程序员都应该读什么书，你能推荐一下书单吗？最开始我是拒绝回答这总问题的。</p>
<p>第一，这种问题你可以用搜索引擎（Google）去解决，这样的问题有太多的回答了， 多找找你就会发现它们相同的地方了。还是那句话「<strong>不做伸手党</strong>」。</p>
<blockquote>
<p>因为一旦你开始不做伸手党，就会发现自己的分析能力瞬间提高了不少。就像我在 xx 写道 「分析并作出判断」才是我们我们成长的基石。</p>
</blockquote>
<p>第二，每个人的背景和行业都不一样， 你可能是 Java  工程师、C/C++ 工程师、GO 工程师、Python 工程师、数据分析师 或者全栈工程师，所以需求和成长路线就会不一样。你需要的书单就是不一样的， 没办法准确给你答案。</p>
<p>我在思考， 为什么自己会人为设置条框呢？分享就好了， 事真多，别人会去除糟粕的，就不劳烦你操心了。好吧，废话有点多， 我把我收集的关于书籍的资源整理出来，大概分为如下部分：</p>
<ul>
<li>可以下载书籍或者查找书籍的网站；</li>
<li>网友和朋友推荐的书籍；</li>
</ul>
<h2 id="可以下载书籍或者查找书籍的网站"><a href="#可以下载书籍或者查找书籍的网站" class="headerlink" title="可以下载书籍或者查找书籍的网站"></a>可以下载书籍或者查找书籍的网站</h2><ul>
<li>it-ebooks：下载IT电子书籍的网站  [<a href="http://www.it-ebooks.info/" target="_blank" rel="external">http://www.it-ebooks.info/</a>]</li>
<li>gitbook：gitbook上有很多书籍</li>
<li>经典编程书籍大全：100+ 经典技术书籍 [<a href="https://github.com/jobbole/awesome-programming-books" target="_blank" rel="external">https://github.com/jobbole/awesome-programming-books</a>]</li>
<li>oreilly Free Programming Ebooks：ORielly 的免费电子书 [<a href="http://www.oreilly.com/programming/free/" target="_blank" rel="external">http://www.oreilly.com/programming/free/</a>]</li>
<li>free-programming-books：免费的编程英文书籍索引 [<a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md" target="_blank" rel="external">https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md</a>]</li>
<li>free-programming-books-zh_CN：免费的编程中文书籍索引 [<a href="https://github.com/justjavac/free-programming-books-zh\_CN]_" target="_blank" rel="external">https://github.com/justjavac/free-programming-books-zh\_CN]_</a></li>
<li>awesome: awesome系列, 包括各种语言的， 大家到 Github 上搜索一下</li>
</ul>
<h2 id="网友和朋友推荐的书籍"><a href="#网友和朋友推荐的书籍" class="headerlink" title="网友和朋友推荐的书籍"></a>网友和朋友推荐的书籍</h2><p>张逸在 2013 写了一篇 『ThoughtWorks(中国)程序员读书雷达』，该读书雷达将书籍分为了如下四个维度： </p>
<ul>
<li>Coding Practice（编程实践） </li>
<li>Architecture &amp; Design（架构与设计） </li>
<li>Methodology（方法学） </li>
<li>Thought &amp; Leadership（思想与领导力）</li>
</ul>
<p><img src="http://agiledon.github.io/images/2013/04/reading-radar.jpg" alt=""></p>
<blockquote>
<p>ThoughtWorks(中国)程序员读书雷达（2013）:<br>[<a href="https://www.douban.com/doulist/2012097/" target="_blank" rel="external">https://www.douban.com/doulist/2012097/</a>]</p>
</blockquote>
<p>现在发现又有 2016 版的了</p>
<blockquote>
<p>ThoughtWorks读书雷达（2016）：<br>[<a href="https://www.douban.com/doulist/43272819/" target="_blank" rel="external">https://www.douban.com/doulist/43272819/</a>]</p>
</blockquote>
<p>看一下同事发给我的思维导图吧</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/%E8%AF%BB%E4%B9%A6%E9%9B%B7%E8%BE%BE.jpg" alt=""></p>
<p>以上就是我整理的关于书籍的一些资源，你也可以告诉我你的书单。</p>
<p>其实如上面提到的如果你有足够的分析能力， 知道如何阅读一本书，其实根本没有什么书单的。你什么书都去读好了， 不过要带上思考的脑子， 能快速辨别哪些书是需要精度的，哪些是不需要的。</p>
<p>IT 行业本身就是快速变化的行业， 你需要不断学习， 不断的读书。不只是你， 我也有好多书没读…</p>
]]></content>
    
    <summary type="html">
    
      程序员最应该读的书
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>我的 2016</title>
    <link href="http://hujiandong.com/2017/01/01/2016-person-summary/"/>
    <id>http://hujiandong.com/2017/01/01/2016-person-summary/</id>
    <published>2017-01-01T07:30:16.000Z</published>
    <updated>2017-01-02T02:30:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间2016走到了尽头。人们需要仪式感，所以无论情不情愿，总要和过去的自己诀别一番。尽管你我都知道，明年不会是一个更新的自己，只会是一个更老的自己。</p>
<p>只是当你在午夜检点行藏，追忆过去的365个日夜，回想年初制定的那些计划，有太多的事情值得仔细思量。</p>
<p>我最害怕这种命题作文， 因为以前一到这时候回答这个问题都逃不掉下面的一句话:</p>
<blockquote>
<p>对自己失望这件事上，我每年都没让自己失望过。</p>
</blockquote>
<p>不过今年开始往好的方向发展了， 主要发生在我身边的事件线：</p>
<ul>
<li>码字、阅读</li>
<li>置业</li>
<li>学英语</li>
</ul>
<p>提到<strong>码字</strong>是我今年做的最好的事情， 以前提到大大小小、技术和非技术写了100多篇，也有让我个人有那么一丝安慰为数不多的几篇；还有在这周微信公众号邀请「开通原创保护功能」。</p>
<p><strong>码字和阅读</strong>让我的心态变得更平和，我本身是个性子比较急的一个人， 不会控制自己的情绪，不过通过阅读、码字、思考等行动，慢慢变得不那么暴躁了。当然这个只是我个人的看法， 不知认识我的童鞋怎么看呢？还有本质的东西，不是你想控制就能控制的，现在做的远远不够。偶尔在遇到当时看来有挑战的问题时，也会骂娘。</p>
<p><strong>置业</strong>：在八月份的时候， 我选择置办房产，这次的动机很简单主要考虑以后小孩上学问题。为什么选择八月份呢？ 主要那段时间涨的太厉害，  原本计划明年要办的事情提前做了。</p>
<p>本来简单买个房子，不应该那么麻烦， 不巧的狗血的剧情在我身上发生了。在我签合同前，由于房价的持续飞涨，政府终于出台久违的限购政策， 政策导致我瞬间没有购房资格了。</p>
<p>在那之前我向开发商已经交过20%首付了， 无赖为了买这个房子只能选择离婚了。<br>所以现在的身份是个离异人士，老婆变成前妻了。有人说，「年底不买房， 等于一年白忙」，我只能呵呵，你鸭的，我们都是被逼的出来卖的， 唉， 谁信了。</p>
<p><strong>英语</strong>：说完房子我们再来说说英语， 英语这个问题， 一如既往的稳如狗， 从来没有让我失望过。预期目标没有完成， 以前的文章中我一说过问题出在哪里，最主要原因在投入的不够。不过我没有放弃， 现在已经培养中「<strong>物理习惯</strong>」了 ，下一步做就是花时间投入问题了。</p>
<p><strong>生活</strong>：这一年里， 说实话陪家人时间很少， 尤其是我们家的小布点， 有时候回去了， 给你打招呼你也不理我，我知道主要是陪你太少了，你都不认识我了。</p>
<p>我只是希望用自己行动，能影响你的成长。如果自己最终是个有足够积累的人， 起码你不用哀怨自己的命运， 就算不是「含着金钥匙出生」，管它是金是银、是铜是铁， 终归可能起码含着钥匙呢？</p>
<p>明年你又大一点了， 到时候可以多带你出去走走，我知道你很聪明（至少比我聪明），希望你以后你能找到自己的道路，这样我就能早点实现回家种地目标了。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/JlXYOcpo4ZLozCWlmqvqbr3Oy9B4EicL7vTFsXXz6JRfqnA6aHLjRE6VCzm910d7sCoEVgHTlosyhdtUKvpvxxQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>现在工作时候， 哪怕下雨，雾霾，我每天都从地铁口走到公司，不近不远1.5公里，哪怕现在可以选择单车了， 我还是选择走过去， 这段时间是我思考时间，好多实践都是这段时间决定的。</p>
<p>2016对个人成长方面的投资超过5000块，也在点滴改变自己，是的，我在做正确的事情。</p>
<p>从无忧无虑到知道人生不易，这个需要时间去打磨，就像李宗盛在「鬼迷心窍」中唱到：</p>
<blockquote>
<p>虽然岁月总是匆匆地催人老　虽然情爱总是让人烦恼<br>虽然未来如何不能知道　现在说再见会不会太早</p>
</blockquote>
<p>驰骋远方的人总有一天要踏上归途，讲完故事喝完酒也得回老家过年，再老的司机也会因为眷恋一个人的微笑，而燥不了。</p>
<p>平庸的日子一年又一年。我们总会在年初写很多 flag，而又在年末的时候亲手拔掉，开始一个新的轮回。而我，也许现在不美好，但黎明前总是最黑暗。</p>
<p>记得电影《后会无期》里有一句经典台词：</p>
<blockquote>
<p>我们听了很多的道理，可是却依旧过不好这一生。</p>
</blockquote>
<p>我们当然过不好这一生，因为我们只是听了这些道理，从来也没有行动过。也把它送给2017的自己和你们。</p>
]]></content>
    
    <summary type="html">
    
      我的 2016
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--单例模式</title>
    <link href="http://hujiandong.com/2016/12/21/design_pattern_singleton/"/>
    <id>http://hujiandong.com/2016/12/21/design_pattern_singleton/</id>
    <published>2016-12-21T07:30:16.000Z</published>
    <updated>2017-01-02T02:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们日常的工作中经常需要在应用程序中保持一个唯一的实例，如：IO处理，数据库操作等，由于这些对象都要占用重要的系统资源，所以我们必须限制这些实例的创建或始终使用一个公用的实例，这就是我们今天要介绍的——单例模式（Singleton）。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>单例模式，又称单件模式或者单子模式，指的是一个类只有一个实例，并且提供一个全局访问点。</p>
</blockquote>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在单例的类中设置一个 private 静态变量instance，instance 类型为当前类，用来持有单例唯一的实例。<br>将（无参数）构造器设置为 private，避免外部使用 new 构造多个实例。<br>提供一个 public 的静态方法，如 getInstance，用来返回该类的唯一实例 instance。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://rawgit.com/jasonim/design-patterns/develop/zh/creator-mode/singleton/image/singleton.png" alt=""></p>
<h2 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><p>由于使用场景不同，出现不同写法和模式，它们分别:</p>
<ul>
<li>懒汉式</li>
<li>恶汉式</li>
<li>双重校验锁</li>
<li>枚举</li>
<li>静态内部类</li>
</ul>
<p>由于枚举使用场景场景较少， 下面就不介绍，感兴趣的可以自行解决。</p>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式指的是单例的实例在类装载时进行创建。由于是在类装时候创建， 所以能够保证线程安全。如果单例类的构造方法中没有包含过多的操作处理，饿汉式其实是可以接受的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class SingleInstance &#123;</div><div class="line">  private final static SingleInstance instance = new SingleInstance();</div><div class="line"></div><div class="line">  public static SingleInstance getInstance() &#123;</div><div class="line">      return instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不足：</p>
<ul>
<li>如果构造方法中存在过多的处理，会导致加载这个类时比较慢，可能引起性能问题。</li>
<li>如果使用饿汉式的话，只进行了类的装载，并没有实质的调用，会造成资源的浪费。</li>
</ul>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式指的是单例实例在第一次使用时进行创建。这种情况下避免了上面饿汉式可能遇到的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SingleInstance &#123;</div><div class="line">  private static SingleInstance instance;</div><div class="line">  private SingleInstance() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static SingleInstance getInstance() &#123;</div><div class="line">      if (null == instance) &#123;</div><div class="line">          instance = new SingleInstance();</div><div class="line">      &#125;</div><div class="line">      return instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是如果上面的代码在多线程并发的情况下就会发生问题， 因为它们存在共同的「临界资源」 instance, 比如线程A进入 <code>null == instance</code> 这段代码块，而在A线程未创建完成实例时，这时线程B也进入了该代码块，必然会造成两个实例的产生。</p>
<p>所以如果多线程这里要考虑加锁同步。代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SingleInstance &#123;</div><div class="line">  private static SingleInstance instance;</div><div class="line">  private SingleInstance() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static synchronized SingleInstance getInstance() &#123;</div><div class="line">      if (null == instance) &#123;</div><div class="line">          instance = new SingleInstance();</div><div class="line">      &#125;</div><div class="line">      return instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用 synchronized 修饰 getInstance 方法后必然会导致性能下降，而且 getInstance 是一个被频繁调用的方法。虽然这种方法能解决问题，但是不推荐使用在多线程的情况下。所以伟大人类又想到了 「双重检查加锁」。</p>
<h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3><p>伟大人类想到首先进入该方法时进行 <code>null == sInstance</code> 检查，如果第一次检查通过，即没有实例创建，则进入 synchronized 控制的同步块,并再次检查实例是否创建，如果仍未创建，则创建该实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class SingleInstance &#123;</div><div class="line">  private static SingleInstance instance;</div><div class="line">  private SingleInstance() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static SingleInstance getInstance() &#123;</div><div class="line">      if (null == instance) &#123;</div><div class="line">          synchronized (SingleInstance.class) &#123;</div><div class="line">              if(null == instance) &#123;</div><div class="line">                  instance = new SingleInstance();</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      return instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>双重检查加锁保证了多线程下只创建一个实例，并且加锁代码块只在实例创建的之前进行同步。如果实例已经创建后，进入该方法，则不会执行到同步块的代码。</p>
<p>这里我们没有加 volatile ，大家可以思考一下，看看是不是必须要加 volatile？</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SingleInstance &#123;</div><div class="line">  private SingleInstance() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static SingleInstance getInstance() &#123;</div><div class="line">      return SingleInstanceHolder.sInstance;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private static class SingleInstanceHolder &#123;</div><div class="line">      private static SingleInstance sInstance = new SingleInstance();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，我想让它延迟加载， 上面就能这种方式就能达到。</p>
<p><strong>优点</strong>:</p>
<ul>
<li>单例模式（Singleton）会控制其实例对象的数量，从而确保访问对象的唯一性。</li>
<li>实例控制：单例模式防止其它对象对自己的实例化，确保所有的对象都访问一个实例。</li>
<li>伸缩性：因为由类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>系统开销。虽然这个系统开销看起来很小，但是每次引用这个类实例的时候都要进行实例是否存在的检查。这个问题可以通过静态实例来解决。</li>
<li>使用多个类加载器加载单例类，也会导致创建多个实例并存的问题。</li>
<li>使用反射，虽然构造器为非公开，但是在反射面前就不起作用了。</li>
<li>对象生命周期。因为单例模式没有提出对象的销毁， 所以使用时容易造成内存泄漏， 例如在 Android 中在 Activity 中使用单例， 所以我们要额外小心。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li>
<li>不要使用单例模式存取全局变量。这违背了单例模式的用意，最好放到对应类的静态成员中。</li>
<li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</li>
</ul>
<h2 id="Android-系统中的应用"><a href="#Android-系统中的应用" class="headerlink" title="Android 系统中的应用"></a>Android 系统中的应用</h2><p>在 Android 系统中， 大量使用单例模式， 我们来看一下。</p>
<p>饿汉式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class CallManager &#123;</div><div class="line">    ...</div><div class="line">    // Singleton instance</div><div class="line">    private static final CallManager INSTANCE = new CallManager();</div><div class="line"></div><div class="line">    public static CallManager getInstance() &#123;</div><div class="line">        return INSTANCE;</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>懒汉式非线程安全实现方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class SnackbarManager &#123;</div><div class="line">    .....</div><div class="line">    private static SnackbarManager sSnackbarManager;</div><div class="line"></div><div class="line">    static SnackbarManager getInstance() &#123;</div><div class="line">        if (sSnackbarManager == null) &#123;</div><div class="line">            sSnackbarManager = new SnackbarManager();</div><div class="line">        &#125;</div><div class="line">        return sSnackbarManager;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>懒汉式线程安全实现方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class SystemConfig &#123;</div><div class="line">    ...</div><div class="line">    static SystemConfig sInstance;</div><div class="line">    ...</div><div class="line">    public static SystemConfig getInstance() &#123;</div><div class="line">        synchronized (SystemConfig.class) &#123;</div><div class="line">            if (sInstance == null) &#123;</div><div class="line">                sInstance = new SystemConfig();</div><div class="line">            &#125;</div><div class="line">            return sInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>饿汉 VS 懒汉</strong>：<br>+饿汉：声明实例引用时就会被实例化</p>
<ul>
<li>懒汉：静态方法第一次调用前不被实例化，即懒加载。对于创建实例代价大的， 且不一定使用时，这种方式可以减少开销</li>
</ul>
<p>一般的情况下，构造方法没有太多处理时，我会使用「饿汉」方式， 因为它简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境）。只有在要明确实现延迟加载效果时我才会使用「静态内部类」方式。</p>
]]></content>
    
    <summary type="html">
    
      单例模式
    
    </summary>
    
      <category term="设计模式" scheme="http://hujiandong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://hujiandong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android 项目框架--MVP 基础</title>
    <link href="http://hujiandong.com/2016/12/13/android-mvp-basic/"/>
    <id>http://hujiandong.com/2016/12/13/android-mvp-basic/</id>
    <published>2016-12-13T09:17:19.000Z</published>
    <updated>2016-12-13T09:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="http://hujiandong.com">JasonThink</a></li>
<li>审阅者：<a href="https://github.com/shaDowZwy" target="_blank" rel="external">@shaDowZwy</a></li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天我们聊一聊传说中 Android 框架 MVP， 想必大家早就听过了， 最早接触这个名词时在今年1月份左右，那时候在 medium 上看到的一篇关于它的介绍， 看的也不是很明白， 不过被一些设计思想吸引。然后参阅一些相关的资料， 发现 Google 在 Github 有一个实现的代码， 然后模仿它例子也在 Github 上创建第一个 Android Demo。</p>
<p>现在真后悔当时没有写一篇相关的文章， 总给自己理解不深找借口， 越拖发现类似的文章越多， 现在都已经烂大街了， 本来不想凑这个热闹的，好吧， 管它了，就当来补债的 。当时还看了 MVP、MVVM、Facebook Flux 比较的文章，现在 Android 主流框架是： Retrofit + OkHttp + RxJava + MVP + Dagger 2。</p>
<p>言归正传，今天我们主要说明一下情况：</p>
<ul>
<li>什么是 MVP， 有什么优缺点。</li>
<li>如何实现。</li>
<li>实际项目中如何改造。</li>
</ul>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>全称 Model-View-Presenter，其中 Presenter 解耦了 Model 与 View，使得每个模块的职责更加单一，Model 负责获取数据，View 只关心视图的绘制，Presenter 关联 Model 和 View 处理业务逻辑。</p>
<p>需要注意的是，「Model」 这个词并不正确。严格意义上来说，它指的应该是检索或控制一个 Model 的业务逻辑层。举个例子，比如你的数据库里面包含了 User，而你的 View 想要显示一个 User 列表，那么 Presenter 会引用数据库中的业务逻辑层，查询一个 User 列表，如下图：</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/mvp.png" alt=""></p>
<p>有兴趣的大家可以参考下面的文章， 概念写的比较详细，里面讲到了， 它的的发展历程、MVX  解析。</p>
<blockquote>
<p>Android MVP 详解（上）</p>
<p><em><a href="http://www.jianshu.com/p/9a6845b26856" target="_blank" rel="external">http://www.jianshu.com/p/9a6845b26856</a></em></p>
</blockquote>
<p>我们把 MVP 的优缺点单独说一下， 「知己知彼，访客百战不殆」，不然想想下面场景：</p>
<blockquote>
<p>女朋友：你喜欢我什么？</p>
<p>我：(⊙v⊙)嗯，。。。</p>
<p>女朋友：连喜欢我什么都不知道， 走跟我回去跪方便面。</p>
<p>我：。。。。。</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>降低耦合度，实现了Model和View真正的完全分离，可以修改View而不影响Model</li>
<li>方便进行单元测试， 这个很重要。</li>
<li>Presenter可以复用，一个Presenter可以用于多个View。</li>
<li>View 可以进行组件化。在 MVP 当中，View 不依赖 Model。这样就可以让View 从特定的业务场景中脱离出来，可以说 View 可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>Presenter 中除了应用逻辑以外，还有大量的 View-&gt;Model，Model-&gt;View 的手动同步逻辑，造成 Presenter 比较笨重，维护起来会比较困难。</li>
<li>如果 Presenter 过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么 Presenter 也需要变更了。</li>
<li>View 实现接口比较多，显得代码可读性增高。</li>
</ul>
<h2 id="DEMO-展示"><a href="#DEMO-展示" class="headerlink" title="DEMO 展示"></a>DEMO 展示</h2><p>我最开始看的 Demo 就是 Google 官网提供的，给我很多启发，项目主要展示类似便签的应用。</p>
<blockquote>
<p>项目地址:</p>
<p><em><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">https://github.com/googlesamples/android-architecture</a></em></p>
</blockquote>
<p>下面是它框图：<br><img src="http://7xnilf.com1.z0.glb.clouddn.com/google-arch.jpg" alt=""></p>
<p>本来想拿官方源码进行剖析的，发现以及有人已经写了， 而且还写比我要好， 你说气人不， 下面是它的分析。</p>
<blockquote>
<p>Android官方MVP架构示例项目解析</p>
<p>[<em><a href="http://www.infoq.com/cn/articles/android-official-mvp-architecture-sample-project-analysis" target="_blank" rel="external">http://www.infoq.com/cn/articles/android-official-mvp-architecture-sample-project-analysis</a></em>]</p>
</blockquote>
<h2 id="实践项目使用"><a href="#实践项目使用" class="headerlink" title="实践项目使用"></a>实践项目使用</h2><p>我们来思考一个问题， 我们通过观察上一章 Google Demo 我们会发现一个问题， 事实上每个功能块的代码都是类似的，只是细节上会有所不同。重构的原则告诉我们，这些地方是可以进行重构的。在这个时候，一般会首先想到把一些相同的功能块抽象成一个基类。例如网络错误处理、服务器拒绝请求返回的错误处理等。但是随着项目的进行，很快就会发现，类文件量、代码量仍然会增加得很快，随之带来的问题是项目的管理会变得越来越复杂。</p>
<p>不满现状的我们又进行方案的重组和选择， 最后想到可以通过泛型和抽象，进一步简化 MVP 框架。所有view的基类是 IView（activity或fragment 也是这 view）。<br><strong>IView</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IView</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>IPresenter</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPresenter</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">IView</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(V view)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachView</span><span class="params">(<span class="keyword">boolean</span> retainInstance)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面我们提到，我们把 Activity 和 Fragment 看成 View。所以我们提供了 MVPActivity 和 MVPFragment 作为他们的基类。</p>
<p>这里我们仅仅看 <strong>MVPActivity</strong>， MVPFragment类似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MVPActivity</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">IView</span>, <span class="title">P</span> <span class="keyword">extends</span> <span class="title">IPresenter</span>&lt;<span class="title">V</span>&gt;&gt;</span></div><div class="line">        <span class="keyword">extends</span> <span class="title">BaseActivity</span> <span class="keyword">implements</span> <span class="title">IView</span>, <span class="title">IMvpBase</span>&lt;<span class="title">V</span>&gt;&#123;</div><div class="line">    <span class="keyword">protected</span> P presenter;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        presenter = createPresenter();</div><div class="line">        presenter.attachView(getMvpView());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        presenter.detachView(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> P <span class="title">createPresenter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getMvpView</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (V)<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要思想是 IView 会关联一个 IPresenter, 并且管理 IPresenter 的生命周期。大家从上面的代码片段可以看到， 通常 presenter 是绑定在该生命周期上。所有的初始化或者清理工作都放在 <code>presenter.onAttach()</code> 和 <code>presenter.detach()</code> 上进行。想大家注意到 IPresenter 是一个接口。 我们还提供一个 <strong>BasePresenter</strong>,  它只持有 View 的弱引用， 从而避免内存泄漏。所有，当 presenter 想要调用 view 的方法是， 我们需要判断 <code>isViewPresenter()</code> 并使用 <code>getView()</code>来获取引用，以坚持view是否连接当了 presenter。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/mvparch.png" alt=""></p>
<p>看一下上图我项目结构， 其中 BaseLib 下有两个库，分别是 baseapp、mvplib。</p>
<ul>
<li>baseapp：主要包含BaseActiviy、AppMain 类</li>
<li>mvplib： 主要是时 MVP 封装框架，更高效开发</li>
<li>app: 主要是我们的演示程序</li>
</ul>
<p>那么我们看 app 中演示程序，这里本身只是简单通过 Activity 自举， 别的类似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">MVPActivity</span>&lt;<span class="title">MainActivity</span>, <span class="title">HelloPresenter</span>&gt; <span class="keyword">implements</span> <span class="title">IView</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="keyword">final</span> EditText editText = (EditText) findViewById(R.id.editText);</div><div class="line">        Button button = (Button) findViewById(R.id.button);</div><div class="line">        <span class="keyword">final</span> TextView textview = (TextView)findViewById(R.id.textView);</div><div class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                String str = editText.getText().toString().trim();</div><div class="line">                presenter.submit();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> HelloPresenter <span class="title">createPresenter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloPresenter();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面代码中我们可以看到 MainActivity 继承了 MVPActivity ，实现了 IView， 其中 <code>createPresenter()</code>负责创建对应的 Presenter，下面我们看 HelloPresenter 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloPresenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</div><div class="line">        MainActivity view = getView();</div><div class="line">        TextView textView = (TextView) view.findViewById(R.id.textView);</div><div class="line">        EditText editText = (EditText) view.findViewById(R.id.editText);</div><div class="line">        <span class="keyword">assert</span> editText != <span class="keyword">null</span>;</div><div class="line">        textView.setText(editText.getText().toString().trim());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到 HelloPresenter 负责进行 UI 的更新， 这里只是简单举例， 实际项目中我们可以配合 RxJava 进行实现。<br>具体实现可以看一下本人的Github的实现。</p>
<blockquote>
<p>项目GitHub：<br><em><a href="https://github.com/jasonim/mvparchitecture" target="_blank" rel="external">https://github.com/jasonim/mvparchitecture</a></em></p>
</blockquote>
<p>这样我们上面基本上解决上面我们提出的问题， 当然我们经常可能遇到屏幕旋转的问题， 这样一般处理数据持久化问题， 一般的做法是在 <code>onSaveInstanceState()</code>处理， 简单做法记录数据。当然我们可以通过状态来修复view的状态。就不在这里说了， 感兴趣的可以参考 <strong>mosby</strong> 的做法。</p>
<blockquote>
<p>mosby:<br><em><a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">https://github.com/sockeqwe/mosby</a></em></p>
</blockquote>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>「一万个心中有一万个哈姆雷特」，没有任何事情是绝对不变的， 框架也是一样，对 MVP 的争论不断：</p>
<blockquote>
<p>MVP，太多的接口，如果项目大的话，还可以，如果不大，就建太多的类。感觉有点笨重。。。</p>
</blockquote>
<p>把握以下两点就行：</p>
<ul>
<li>我们引用项目框架目的是什么？是不是为了业务扩展，如果没有扩展需求， 什么项目框架也不需要。</li>
<li>每个人的理解不一样，实践中找到一个适合自己的就好, 如果感觉 MVVM 的双向绑定很好，那就改造一下， 没有最好，只有更好。实践、再实践。 </li>
</ul>
<p>下一篇我们来聊一聊， 怎样在 MVP 中加入 dagger、rxjava；怎么通过组件化优化项目结构。</p>
]]></content>
    
    <summary type="html">
    
      Android 项目框架--MVP 基础
    
    </summary>
    
      <category term="项目架构" scheme="http://hujiandong.com/categories/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="项目架构" scheme="http://hujiandong.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式</title>
    <link href="http://hujiandong.com/2016/12/07/factory-method/"/>
    <id>http://hujiandong.com/2016/12/07/factory-method/</id>
    <published>2016-12-07T02:43:23.000Z</published>
    <updated>2016-12-07T02:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>文章来源：ThinkKeep 的 <a href="https://github.com/ThinkKeep/design-patterns" target="_blank" rel="external">design-patterns</a> 项目</li>
<li>作者：<a href="http://hujiandong.com">JasonThink</a></li>
<li>审阅者：<a href="https://github.com/shixinzhang" target="_blank" rel="external">@shixinzhang</a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2></li>
</ul>
<p><img src="https://rawgit.com/jasonim/design-patterns/develop/zh/creator-mode/factory-method/image/factory-method.svg" alt=""></p>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//Http</span></div><div class="line">        ProtocolFactory factory = <span class="keyword">new</span> HTTPFactory();</div><div class="line">        Protocol protocol = factory.createProtocol();</div><div class="line">        protocol.performRequest();</div><div class="line"></div><div class="line">        <span class="comment">//UDP</span></div><div class="line">        factory = <span class="keyword">new</span> UDPFactory();</div><div class="line">        protocol = factory.createProtocol();</div><div class="line">        protocol.performRequest();</div><div class="line"></div><div class="line">        <span class="comment">//TCP</span></div><div class="line">        factory = <span class="keyword">new</span> TCPFactory();</div><div class="line">        protocol = factory.createProtocol();</div><div class="line">        protocol.performRequest();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码， 分别通过不同的协议工厂创建不同协议类， 方便客户端调用。这样客服端不需要关心哪种具体产品类将被实例化这一细节，也不需知道具体的类的类名， 当再有更多协议更方便扩展，也遵循「对扩展开放，对修改关闭」的原则。如果细心的同学可能会发现， 三段代码有相同的地方， 是的， 可以进一步重构， 像这样<code>createFactory(int protocol)</code>，这里为了更方便大家看懂工厂方法，就分开来写了。</p>
<p>运行结果：<br><img src="https://rawgit.com/jasonim/design-patterns/develop/zh/creator-mode/factory-method/image/factory-method-run.png" alt=""></p>
<p><strong>优点</strong>：</p>
<ul>
<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当我们遇见下列场景，可以考虑工作方法模式：</p>
<ul>
<li>我们不能预先知道被创建对象的类型，如我们在不知道发送网络请求用什么协议（TCP、UPD 或 HTTP）， 就像上面的例子。</li>
<li>一个类想要他的子类指定它的创建的实例</li>
<li>将创建的对象的任务委托给多个工厂子类中的其中一个， 调用者在使用时可以无需关系是哪个工厂子类创建产品， 需要时动态指定， 可将具体工厂类名存储在配置文件或数据中。</li>
</ul>
<h2 id="Android-应用实例"><a href="#Android-应用实例" class="headerlink" title="Android 应用实例"></a>Android 应用实例</h2><p>Android 中用到了太多的工厂类，其中有用工厂方法模式的，比如AsyncTask类中工厂的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//工厂实现类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码中 ThreadFactory 就是工厂方式的类的实现。</p>
]]></content>
    
    <summary type="html">
    
      工厂方法模式
    
    </summary>
    
      <category term="设计模式" scheme="http://hujiandong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://hujiandong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="http://hujiandong.com/2016/12/07/abstract-factory/"/>
    <id>http://hujiandong.com/2016/12/07/abstract-factory/</id>
    <published>2016-12-07T02:40:13.000Z</published>
    <updated>2016-12-07T02:42:04.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>文章来源：ThinkKeep 的 <a href="https://github.com/ThinkKeep/design-patterns" target="_blank" rel="external">design-patterns</a> 项目</li>
<li>作者：<a href="http://hujiandong.com">JasonThink</a></li>
<li>审阅者：<a href="https://github.com/shixinzhang" target="_blank" rel="external">@shixinzhang</a></li>
</ul>
<p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。我们可以想一下，有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象，即产品族。如在工厂方法中 HTTPFactory 只负责生产 HTTPProtocol 等。显然不能满足我们的需求了， 怎么办？ 抽象工厂模式给我们解决了这个问题。</p>
<p>为了让你能够更好的理解抽象工厂模式， 我们先了解以下几个概率：</p>
<ul>
<li><strong>产品等级结构</strong> ：产品等级结构即产品的继承结构，如一个抽象类是 Protocol，其子类有 HTTPProtocol、TCPProtocol、UDPProtocol，则抽象 Protocol与具体协议之间构成了一个产品等级结构，抽象Protocol是父类，而具体协议的 Procotol 是其子类。</li>
<li><strong>产品族</strong>：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如中国麦当劳店生产的巨无霸、可乐， 巨无霸位于汉堡产品等级结构中，可乐位于饮料产品等级结构中。</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes。为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>大家都去麦当劳吃过汉堡吧， 还有中国的麦当劳产品和国外的麦当劳，不一样吧， 至少原料不一样吧， 鸡肉都是本地产的吧，还有汉堡的大小不一样吧。套餐的品种也不样吧， 下面我们就用麦当劳举例吧。</p>
<p><strong>类图</strong>：</p>
<p><img src="https://rawgit.com/jasonim/design-patterns/develop/zh/creator-mode/abstract-factory/image/abstract-factory.svg" alt=""></p>
<p><strong>代码</strong>：</p>
<p><strong>AbsFactory</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbsFactory</span> </span>&#123;</div><div class="line">    <span class="function">Hamburg <span class="title">createhamburg</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Drink <span class="title">createDrink</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//套餐....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Store</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        AbsFactory factory = <span class="keyword">new</span> ChineseFactory();</div><div class="line">        factory.createDrink();</div><div class="line">        factory.createhamburg();</div><div class="line"></div><div class="line">        factory = <span class="keyword">new</span> NYFactory();</div><div class="line">        factory.createDrink();</div><div class="line">        factory.createhamburg();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>运行结果</strong>：</p>
<p><img src="https://rawgit.com/jasonim/design-patterns/develop/zh/creator-mode/abstract-factory/image/run.png" alt=""></p>
<p><strong>优点</strong>：</p>
<ul>
<li>封装性，每个产品的实现类不是高层模块要关系的，要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类。</li>
<li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>抽象工厂模式的最大缺点就是产品族扩展非常困难，如实例中如果再添加新产品， 就需要在抽象工厂类添加对应的产品，开闭原则的倾斜性。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<p>如某个 APP多套主题时， 青春版、老人版、自恋办等， 可以考虑抽象工厂模式。</p>
<h2 id="抽象工厂模式与工厂方法模式区别及联系"><a href="#抽象工厂模式与工厂方法模式区别及联系" class="headerlink" title="抽象工厂模式与工厂方法模式区别及联系"></a>抽象工厂模式与工厂方法模式区别及联系</h2><p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。</p>
<p>他们自己没有绝对界限，当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>
<h2 id="Android-源码中的应用"><a href="#Android-源码中的应用" class="headerlink" title="Android 源码中的应用"></a>Android 源码中的应用</h2><p>在java 的连接数据库的操作中，对不同的数据库的操作而形成的对象操作族，就是一种很好的抽象工厂模式的应用。而在 Android 系统中 WebViewFactoryProvider/WebViewChromiumFactoryProvider 也应用抽象工厂。</p>
<p><strong>WebViewFactoryProvider</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebViewFactoryProvider</span> </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function">WebViewProvider <span class="title">createWebView</span><span class="params">(WebView webView, WebView.PrivateAccess privateAccess)</span></span>;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function">CookieManager <span class="title">getCookieManager</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>WebViewChromiumFactoryProvider</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewChromiumFactoryProvider</span> <span class="keyword">implements</span> <span class="title">WebViewFactoryProvider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> WebViewProvider <span class="title">createWebView</span><span class="params">(WebView webView,</span></span></div><div class="line">    	WebView.PrivateAccess privateAccess) &#123;</div><div class="line">        WebViewChromium wvc = <span class="keyword">new</span> WebViewChromium(<span class="keyword">this</span>,</div><div class="line">        	webView, privateAccess);</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> wvc;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CookieManager <span class="title">getCookieManager</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            <span class="keyword">if</span> (mCookieManager == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                ...</div><div class="line"></div><div class="line">                mCookieManager = <span class="keyword">new</span> CookieManagerAdapter(<span class="keyword">new</span> AwCookieManager());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mCookieManager;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WebViewFactoryProvider是抽象工厂接口，定义了WebView及周边功能所需要对象的创建方法，这些方法大部分为工厂方法，它们返回的对象类型是抽象的，属于面向接口的编程风格。抽象工厂WebViewFactoryProvider创建的对象有：实现Webview核心功能的WebViewProvider，管理Cookie的CookieManager，地理位置相关的GeolocationPermissions和存储Web表单数据的WebviewDatabase等等。WebViewChromiumFactoryProvider是抽象工厂的具体实现者，它提供“Chromium”主题的产品族，也是目前最新版本Webview正在使用的产品族。如果将来有新的浏览器引擎内核出现(以前用得是 Apple Webkit 内核， 听说 google 搞了一套自己的，不知道现在加进去没)，那么只需按照WebViewFactoryProvider接口创建该主题下产品，然后替换现有的「Chromium」就可以完成换代，不用改动其他地方任何代码。</p>
]]></content>
    
    <summary type="html">
    
      抽象工厂模式
    
    </summary>
    
      <category term="设计模式" scheme="http://hujiandong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://hujiandong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>那些年我的编程之路（上）</title>
    <link href="http://hujiandong.com/2016/11/28/my-program-away-1/"/>
    <id>http://hujiandong.com/2016/11/28/my-program-away-1/</id>
    <published>2016-11-28T06:49:48.000Z</published>
    <updated>2016-11-28T06:54:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>我接触编程比较晚， 大学时候才开学习编程的， 和阿里的『道哥』、Thoughwork 的 『Phodal』 比起来都要晚， 当然和『云舒』比起来要早， 哪又怎样，人家都能甩我几个银河系。 问我当初为什么学习编程呢？因为我的计算专业的。那你为什么选计算机专业呢？因为当初我上的那个学校，计算机专业没招满， 我被调剂到这个专业了，我当时报的可是生物技术啊。是不是好多同学和我一样， 恭喜。 现在想想真应该感谢我的母校。如果当时学了生物技术， 现在不敢想我能做什么， 实验小白鼠、研究甜玉米、在制药公司买药， 可惜人生没有假设， 不然呢？</p>
<p>和很多大一新生一样， 好不容易离开父母的监管， 记得一般英语课都在上午前两节， 由于晚上玩的比较晚，当然上午就起不来了， 结果导致一般英语课就不去了。那时候主要的活动是 喝酒、Dtao、篮球，记得以前提过喝酒最高纪录，也是那时候创下的。我们吃饭喝酒一般都在学校旁边的 『老地方水煮鱼』，一般一份水煮鱼、一份花生米、四份米饭、8瓶啤酒，齐活。60左右， 现在看来真便宜，而且他家的水煮鱼是一绝，就现在来看也是。前段时间有点事回去，还和同学特意去吃了一次， 还是那个味道， 只是地方变大了， 还和老板说，  「以后不干这行了， 加盟你的水煮鱼可否」。 </p>
<p>大二除了做上面的事情， 做了另一件最主要的事情，找了一个女朋友， 主要动机我想不能重复做大一的事情了，太没意思了，那就找个朋友刷刷吧。由于时间就那么多， 喝酒、打游戏、篮球， 我就出掉了打游戏， 当然不是完全不玩， 只是频率少了很多。女朋友是外校的，  具体是怎么认识的，怎么追的。今天不再这里展开说了， 上次我就说写一写我和她的故事， 一直也没有写，哪天一定要把债补上。总之她是我生命中最主要的女人之一。正好今天是感恩节， 她刚刚发微信告诉我，今天是感恩节， 我是这样回的 「<strong>谢谢你的把我收了，不然我就砸手里了</strong>」 。</p>
<p>大三我又做了一件事情，真正学习编程。 当时感觉应该考虑毕业之后该做什么，回家种地？ 既然学了这个专业， 又没有更好的出路，那就认真搞一把， 由于专业课没有怎么逃课，感觉基础还行。可是自学了一段时间， 一直徘徊于 Hello world 上面。 我就找到当时交我们 C# 老师聊了聊， 说明我的一些想法。他说可以， 你先给做个东西， 拿给他看看。 然后我就给他用 C# 做了一个计算器。也是在网上找的，其实好多代码都看不懂， 勉强让它跑起来。他看后没有说行还是不行，我就回去等结果， 一周我去找他一次， 这样连续去了两周。他说行吧， 你再给我找一个同学， 你两一块；我就找了一个喜欢编程的也喜欢喝酒的。</p>
<p>就这样我们跟这那个老师，边做项目边学习， 持续大概一年时间， 中间为了提高效率我们搬进我们学院提供实验室， 当然学习氛围更好一些， 至少很少看见在那打游戏的了。在哪里我也接触到 Linux，可以说那里是我 『计算机的启蒙、也是我 Linux 的启蒙』，那段时间是我状态最好的， 虽然没有学到什么东西， 但是现在看来让我走上编程道理的主要原因， 不然我不会选择编程之路。</p>
<hr>
<p>PS：<br>不知道微信公众号里都有多少是刚刚工作不久，或者还没有毕业的。虽然我的公众号里并没有多少人，关注我的都是我的种子用户，你们不离不弃， 必将芳龄永继。哈哈， 言归正传， 还没有毕业的或刚刚毕业， 一定要做好下面几件事：</p>
<ol>
<li>如果是男生一定要找一个女朋友， 如果是女生就算了，因为关注我公众号的女生都抢手哈， 不要急，发现上进的男人就同意了；不要太挑了， 这也是一种投资， 当然也有投资失败的情况， 不要在意。 不要听别人说，「现在谈了， 毕业就会分手， 还不如不谈」。这样的论断， 因为每个个体都不一样， 不试试怎么知道呢？我不能说一定不会分手， 至少我身边的有一两个包括我自己都没有分手， 而且还结婚了。是不是让吃瓜群众失望了。当然我们几个只是个体，不适用普遍规律。但是一点是真的恋爱能让人成长。还有最主要的原因是看你们怎么对待这段感谢的， 也就是对待感情的态度， 我看到的好多分手的，都是对待感情很随意。好多人会说那时候年轻不懂，其实不是不懂， 是拿年轻找借口。如果刚毕业也要抓紧找， 不然以后成本会越来越高。当然你认为你很优秀，优秀到地球都装不下你了， 那最好别找。把机会让给不那么优秀的人吧。<strong>还有找朋友，真的那么难吗</strong>？ 多发点时间， 多用点心， 多一点厚脸皮。能跨专业找就跨专业找，如果你会写程序， 你就在特殊的日子，写一点特殊的东西， 其实不难。不会写程序， 总会修电脑、装软件吧， 如果你还说不会， 那就活该你没有女朋友。真替你们着急， 写的我都想再找一次女朋友了， 你们难道没有感觉吗？</li>
<li><strong>好好学习， 多和别人沟通，多参加一些活动 ，哪怕这个专业你不喜欢，你也认真听课，特别是英语。这个就是你于别人不同的地方， 也是你的价值。现在网络特别发达，  如果你有喜欢的方向， 就去学。还有一定要学会科学上网（翻墙），如果不会， 就先把这个学会， 不管你是什么专业，以后从事行业，如果你学习编程就上 Github，什么都有</strong>。</li>
<li>一定要重视第一份工作， 好好想想你要什么， 如果真不知道， 就要去一个中型以上的公司， 最好不要去 Start Up 公司， 这个对以后的最终成为什么样的人， 起到很重要的作用。 当然那些公司不好进， 这个就需要平时多下功夫，特别是那些和我一样学校背景一般的童鞋，更应该多努力， 因为我们可利用的资源少。每个行业切入点不一样，但是差别不大。</li>
<li>除非特殊原因， 前面两三年不要换行业、 城市， 当然工作时间越久，换行业的成本越高。自己把握一个度就行， 以前面试的时候， 有一个童鞋看他简历上写着以前在上海工作， 问他为什么来北京， 他说 「女朋友在北京」，这种鼓励。</li>
</ol>
<p><strong>本篇文章，首发于微信公众号！</strong></p>
]]></content>
    
    <summary type="html">
    
      那些年我的编程之路（上）
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>设计模式几大原则</title>
    <link href="http://hujiandong.com/2016/11/21/design-principle/"/>
    <id>http://hujiandong.com/2016/11/21/design-principle/</id>
    <published>2016-11-21T10:06:26.000Z</published>
    <updated>2016-12-07T05:56:58.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>文章来源：ThinkKeep 的 <a href="https://github.com/ThinkKeep/design-patterns" target="_blank" rel="external">design-patterns</a> 项目</li>
<li>作者：<a href="http://hujiandong.com">JasonThink</a></li>
<li>审阅者：<a href="https://github.com/shixinzhang" target="_blank" rel="external">@shixinzhang</a></li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>天下武林，林林总总。名门正宗如少林武当，诚然名扬天下，而武林之大，但凡修得暗镖神剑者，亦可独步江湖。所以门派无尊贵，只有适合不适合。设计的本质：即使最懂设计的人，也要心胸坦荡，认识到自我局限性，不可以名门正宗自居，须认识到获得真理是一个学无止境、永远追求的过程。</p>
<p>十八般武艺样样精通，仅出现在武侠传说中， 现实中即使是全栈工程师也不敢说十八般武艺样样精通， 对于普通的IT从业者来说， 如何从码农变为一个合格的工程师来说， 软件设计是必经之路。 当然要软件设计一定要遵循设计的六大原则。在工作的初期，我们可能会经常有这样的感受，自己的代码接口设计混乱、代码耦合较为严重、一个类的代码过多等等，当自己回头再看这些代码时可能会感慨，怎么能写成这个鸟样。再看那些知名的开源库，它们大多有整洁的代码、清晰简单的接口、职责单一的类，这个时候我们会通常会捶胸顿足而感慨：什么时候老夫才能写出这样的代码！</p>
<p>在做开发的这些年中，我渐渐的感觉到，其实国内的一些初、中级工程师写的东西不规范或者说不够清晰的原因是缺乏一些指导规则。他们手中挥舞着面向对象的大旗，写出来的东西却充斥着面向过程的气味。也许是他们不知道有这些规则，也许是他们知道但是不能很好的运用到实际的代码中，亦或是他们没有在实战项目中体会到这些原则能够带来的优点，以至于他们对这些原则并没有足够的重视。</p>
<h2 id="设计的六大原则"><a href="#设计的六大原则" class="headerlink" title="设计的六大原则"></a>设计的六大原则</h2><p>在此之前，有一点需要大家知道，熟悉这些原则并不是说你写出的程序就一定灵活、清晰，只是为你优秀的代码之路铺上了一层栅栏，在这些原则的指导下，你才能避免陷入一些常见的代码泥沼，从而让你写出优秀的东西。</p>
<h3 id="单一原则-Single-Responsibility-Principle"><a href="#单一原则-Single-Responsibility-Principle" class="headerlink" title="单一原则(Single Responsibility Principle)"></a>单一原则(Single Responsibility Principle)</h3><p>单一职责原则的英文名称是 Single Responsibility Principle，简称是 SPR，简单地说就是一个类只做一件事，这个设计原则备受争议却又极其重要。只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的。因为单一职责的划分界限并不是如马路上的行车道那么清晰，很多时候都是需要个人经验来界定。当然，最大的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。这跟我们社会分工一样， 一些人干这个， 另一些人干那个，只有大家都这样做了， 我们的社会才更和谐。</p>
<p>试想一下，如果你遵守了这个原则，那么你的类就会划分的很细，每个类都有比较单一的职责，这不就是高内聚、低耦合么！当然，如何界定类的职责就需要你的个人经验了。</p>
<p>当然，软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离，就是抽象的能力。其实要去判断是否应该分离出类来，也不难，那就是如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>
<p>我们来定义一个网络类，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHttp</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 发送 Http 请求，并且返回一个 Response</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request&lt;?&gt; request)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，IHttp 只有一个 sendRequest 函数，它的职责就是执行网络请求并且返回一个 Response，它的职责很单一，这样在需要修改执行网络请求的相关代码时，只需要修改实现 Http 接口的类，而不会影响其他类的代码。如果某个类的职责包含有执行网络请求、解析网络请求、进行 gzip 压缩、封装请求参数等，那么在你修改某处代码时就必须谨慎，以免修改的代码影响了其它的功能。当你修改的代码能够基本上不影响其他功能。这就一定程度上保证了代码的可维护性。注意，单一职责原则并不是一个类只能有一个函数，而是说这个类中的函数所做的工作是高度相关的，也就是高内聚。</p>
<p>基本判断原则， 就是一个特定的类，当确认以后， 它的责任就确定了，不能增加它行为以外的功能。 例如一般我们定义 API 接口的时候，如果这个接口干了很多事情， 就是一些隐含的事情，我们就认为它设计没有遵循<strong>单一原则</strong>。<br><strong>优点</strong></p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义。</li>
<li>可读性提高，复杂性降低，那当然可读性提高了。</li>
<li>可维护性提高，可读性提高了，那当然更容易维护了。</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<h3 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)"></a>里氏替换原则(Liskov Substitution Principle)</h3><p>里氏替换原则本质就是继承和多态的应用。继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。<br>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ul>
<p>还拿上面的 Http 类举例， 我们用 Restful API 方式进行 Http 网络请求，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulClient</span> </span>&#123;</div><div class="line">    ....</div><div class="line">    <span class="function">Public <span class="title">RestfulClient</span><span class="params">(IHttp http)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.http = http != <span class="keyword">null</span> ? http : createHttp();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(String url, List&lt;Header&gt; list, Body body)</span> </span>&#123;</div><div class="line"></div><div class="line">        ...<span class="comment">//先创建Request</span></div><div class="line">        <span class="comment">//发送数据</span></div><div class="line">        http.sendRequest(request)；</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//创建IHttp 类 TODO 这个可以重构到Factory 里， 这里先偷个懒</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHttp <span class="title">createHttp</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//我们可以根据 Android SDK 选择不同的HTTP</span></div><div class="line">        <span class="keyword">int</span> runtimeSDKApi = Build.VERSION.SDK_INT;</div><div class="line">        <span class="keyword">if</span> (runtimeSDKApi &gt;= GINGERBREAD_SDK_NUM) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpUrlConnImpl();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpClientImpl();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中， RestfulClient 类中依赖的是 IHttp 接口，而通过 createHttp 函数返回的是 IHttp 的实现类 HttpClientImpl 或 HttpUrlConnImpl。这就是所谓的里氏替换原则，任何父类、父接口出现的地方子类都可以出现，这不就保证了可扩展性吗！如果我们现在将网络请求库改成 OKHttp， 是不是将依赖传进去就行了。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性。</li>
<li>提高代码的重用性。</li>
<li>提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，很多开源框架的扩展接口都是通过继承父类来完成的。</li>
<li>提高产品或项目的开放性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>继承是侵入性的。只要继承，就必须拥有父类所有的属性和方法。</li>
<li>降低了代码的灵活性。子类必须父类的属性和方法，让子类自由的世界中多了些约束。</li>
<li>增强了耦合性。当父类的常亮、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的后果—大量的代码需要重构。</li>
</ul>
<h2 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h2><p>电脑在以前维修的话是根本不可能的事，可是现在却特别容易，比如说内存坏了，买个内存条，硬盘坏了，买个硬盘换上。为啥这么方便？从修电脑里面就有面相对象的几大设计原则，比如单一职责原则，内存坏了，不应该成为更换CPU的理由，它们各自的职责是明确的。再比如开放－封闭原则，内存不够只要插槽足够就可以添加。还有依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象，说白了，就是要针对接口编程，不要对实现编程，无论主板，CPU，内存，硬盘都是针对接口设计的，如果是针对实现来设计，内存就要对应的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬。</p>
<h3 id="为什么叫反转呢？"><a href="#为什么叫反转呢？" class="headerlink" title="为什么叫反转呢？"></a>为什么叫反转呢？</h3><p>面对过程开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们做新项目时，去调用这些底层的函数就可以了。比如我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时就去调用，这就叫做高层模块依赖底层模块。</p>
<p>但是要做新项目是 业务逻辑的高层模块都是一样的，客户却希望使用不同的数据库或存储信息方式，这时出现麻烦了。我们希望能再次利用这些高层模块，但高层模块都是与底层的访问数据库绑定在一起的，没办法复用这些高层模块，这就非常糟糕了。就像刚才说的，PC里如果CPU，内存，硬盘都是需要依赖具体的主板，主板一坏，所有的部件都没法用了，显然不合理，而如果不管高层模块还是底层模块，它们都依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其它受影响，这就使得无论高层模块还是底层模块都可以很容易被复用，这才是最好的办法。</p>
<p>在前面我们的例子中， RefusClient 实现类依赖于 IHttp 接口（抽象），而不依赖于 HttpClientImpl 与 HttpUrlConnImpl 实现类（细节），这就是依赖倒置原则的体现。</p>
<p>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和 setter 方法传递，相信用过 Dagger、Spring 框架的，对依赖的传递方式一定不会陌生。 在实际编程中，我们一般需要做到如下：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则。 依赖倒置原则的核心就是要我们面向接口编程。<br><strong>优点</strong>：</li>
<li>可扩展性好</li>
<li>耦合度低</li>
</ul>
<h2 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h2><p>接口隔离原则（英语：interface-segregation principles， 缩写：ISP）指明没有客户(client)应该被迫依赖于它不使用方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为角色接口（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。接口隔离原则是在SOLID (面向对象设计)中五个面向对象设计(OOD)的原则之一，类似于在GRASP (面向对象设计)中的高内聚性。</p>
<p>下面是看到网上的举的例子：</p>
<blockquote>
<p>可能描述起来不是很好理解，我们还是以示例来加强理解吧。 我们知道，在网络框架中，网络队列中是会对请求进行排序的。内部使用 PriorityBlockingQueue 来维护网络请求队列，PriorityBlockingQueue 需要调用 Request 类的排序方法就可以了，其他的接口他根本不需要，即 PriorityBlockingQueue 只需要 compareTo 这个接口，而这个 compareTo 方法就是我们所说的最小接口方法，而是 Java 中的 Comparable 接口，但我们这里是指为了学习，至于哪里定义的无关紧要。</p>
<p>在元素排序时，PriorityBlockingQueue 只需要知道元素是个 Comparable 对象即可，不需要知道这个对象是不是 Request 类以及这个类的其他接口。它只需要排序，因此，只要知道它是实现了 Comparable 对象即可，Comparable 就是它的最小接口，也是通过 Comparable 隔离了 PriorityBlockingQueue 类对 Request 类的其他方法的可见性。</p>
</blockquote>
<p>很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构。 采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</li>
</ul>
<h2 id="迪米特原则-Law-of-Demeter"><a href="#迪米特原则-Law-of-Demeter" class="headerlink" title="迪米特原则( Law of Demeter)"></a>迪米特原则( Law of Demeter)</h2><p>迪米特原则（Law of Demeter，缩写LoD）等同于“最少知识原则（Principle of Least Knowledge）”，是一种软件开发的设计指导原则，特别是面向对象的程序设计。迪米特原则是松耦合的一种具体案例。该原则是美国东北大学在1987年末在发明的，可以简单地以下面任一中方式总结。</p>
<p>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元； 每个单元只能和它的朋友交谈：不能和陌生单元交谈； 只和自己直接的朋友交谈。 这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。</p>
<p>很多面向对象程序设计语言用”.”表示对象的域的解析算符，因此迪米特原则可以简单地陈述为“只使用一个.算符”。因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p>
<p>通俗地讲，一个类应该对自己需要耦合或者调用的类知道得最少，这有点类似于接口隔离原则中的最小接口的概念。类的内部如何实现、如何复杂都与调用者或者依赖者没有关系，调用者或者依赖者只需要知道它需要它需要的方法即可，其他的一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>降低复杂度</li>
<li>降低耦合性</li>
<li>增加稳定性</li>
</ul>
<h2 id="开闭原则-Open-Close-Principle"><a href="#开闭原则-Open-Close-Principle" class="headerlink" title="开闭原则(Open-Close Principle)"></a>开闭原则(Open-Close Principle)</h2><p>开闭原则是 Java 世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。开闭原则的定义是：一个软件实体类，模块和函数应该对扩展开放，对修改关闭。在软件的生命周期内，因为变化、升级和维护等原因，需要对软件原有的代码进行修改时，可能会给旧代码引入错误。因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。</p>
<p>在软件开发过程中，永远不变的就是变化。开闭原则是使我们的软件系统拥抱变化的核心原则之一。对扩展开放，对修改关闭这样的高层次概括，即在需要对软件进行升级、变化时应该通过扩展的形式来实现，而非修改原有代码。当然这只是一种比较理想的状态，是通过扩展还是通过修改旧代码需要依据代码自身来定。</p>
<p>还是上面的例子， HttpUrlConnImpl 和 HttpClientImpl 实现了 IHttp 接口， 当我们实现 OKHttp 的时候就可以实现 HttpOKImpl， 这样通过扩展的形式来应对软件的变化或者说用户需求的多样性，既避免了破坏原有系统，又保证了软件系统的可维护性。依赖于抽象，而不依赖于具体，使得对扩展开放，对修改关闭。开闭原则与依赖倒置原则，里氏替换原则一样，实际上都遵循一句话：面向接口编程。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>增加稳定性</li>
<li>可扩展性高</li>
</ul>
<h3 id="避免掉进过度设计的怪圈"><a href="#避免掉进过度设计的怪圈" class="headerlink" title="避免掉进过度设计的怪圈"></a>避免掉进过度设计的怪圈</h3><p>当你掌握一些设计模式或者手法之后，比较容易出现的问题就是过度设计。有的人甚至在一个应用中一定要将 23 种常见的设计模式运用上，这就本末倒置了。设计模式的四大要素中就明确指出，模式的运用应该根据软件系统所面临的问题来决定是否需要使用现有的设计。也就是说，再出现问题或者你预计会出现那样的问题时，才推荐使用特定的设计模式，而不是将各种设计模式套进你的软件中。</p>
<p>不管在设计、实现、测试之间有多少时间都应该避免过度设计，它会打破你的反馈回路，使你的设计得不到反馈，从而慢慢陷入危险中。所以你只需要保持简单的设计，这样就有时间来测试该设计是否真的可行，然后作出最后的决策。</p>
<p>当设计一款软件时，从整体高度上设定一种架构模式，确定应用的整体架构，然后再分析一些重要的设计思路，并且保证他们的简单性、清晰性，如果有时间可以使用 Java 代码模拟一个简单的原型，确保设计是可行的，最后就可以付诸行动了。切实不要过度的追求设计，适当就好，当我们发现或者预计到将要出现问题时，在判断是否需要运用设计模式。</p>
]]></content>
    
    <summary type="html">
    
      设计模式原则
    
    </summary>
    
      <category term="设计模式" scheme="http://hujiandong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://hujiandong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android 单元测试--Mock及Mockito</title>
    <link href="http://hujiandong.com/2016/11/07/android-unit-test-mock/"/>
    <id>http://hujiandong.com/2016/11/07/android-unit-test-mock/</id>
    <published>2016-11-07T11:22:29.000Z</published>
    <updated>2016-11-18T09:22:30.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="http://hujiandong.com">JasonThink</a></li>
<li>审阅者：<a href="https://github.com/itsMelo" target="_blank" rel="external">@Melo</a></li>
</ul>
<p>以前我在<strong><a href="http://hujiandong.com/2016/04/10/how_code_auto_test/">内功之自动化测试</a></strong>中说到测试在项目中的重要性。单元测试是一个个「点」（细胞）的重构，是重构的基石，今天我们说单元测试中如何使用 <strong><a href="https://en.wikipedia.org/wiki/Mock_object" target="_blank" rel="external">Mock</a></strong> 及 <strong><a href="http://mockito.org/" target="_blank" rel="external">Mockito</a></strong> 的。</p>
<h2 id="Mock-概念"><a href="#Mock-概念" class="headerlink" title="Mock 概念"></a>Mock 概念</h2><p>所谓的 Mock 就是创建一个类的虚假的对象，在测试环境中，用来替换掉真实的对象，主要提供两大功能：</p>
<ul>
<li>验证这个对象的某些方法的调用情况，调用了多少次，参数是什么等等</li>
<li>指定这个对象的某些方法的行为，返回特定的值，或者是执行特定的动作</li>
</ul>
<p>要使用 Mock，一般需要用到 Mock 框架，这篇文章我们使用 Mockito 这个框架，这个是Java界使用最广泛的一个mock框架。</p>
<h2 id="在-Gradle-添加-Mockito-依赖"><a href="#在-Gradle-添加-Mockito-依赖" class="headerlink" title="在 Gradle 添加 Mockito 依赖"></a>在 Gradle 添加 Mockito 依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">repositories &#123; jcenter() &#125;</div><div class="line">dependencies &#123; testCompile &quot;org.mockito:mockito-core:1.+&quot; &#125;</div></pre></td></tr></table></figure>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>我们首先看一下官方的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//mock creation List</span></div><div class="line">mockedList = mock(List.class);</div><div class="line"><span class="comment">//using mock object - it does not throw any "unexpected interaction" exception</span></div><div class="line">mockedList.add(<span class="string">"one"</span>);</div><div class="line"><span class="comment">// selective, explicit, highly readable verification</span></div><div class="line">verify(mockedList).add(<span class="string">"one"</span>);</div></pre></td></tr></table></figure></p>
<p>一般使用 Mockito 需要执行下面三步:</p>
<ul>
<li>模拟并替换测试代码中外部依赖。</li>
<li>执行测试代码</li>
<li>验证测试代码是否被正确的执行</li>
</ul>
<p>创建 Mock 对象的方式：</p>
<ul>
<li>mock(toMockObject.class)</li>
<li>注解的方式 @Mock，注意要利用注解， 首先要告诉 Mockito 框架， 可以<code>@Rule public MockitoRule mockitoRule = MockitoJUnit.rule);</code> 或者它的实现<code>MockitoAnnotations.initMocks(target);</code></li>
</ul>
<h3 id="误区一"><a href="#误区一" class="headerlink" title="误区一"></a>误区一</h3><p>上面的例子我们进行修改 ==&gt; 为不同于上面的地方，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//mock creation List</span></div><div class="line">mock(List.class);</div><div class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="comment">//using mock object - it does not throw any "unexpected interaction" exception</span></div><div class="line">list.add(<span class="string">"one"</span>);</div><div class="line"><span class="comment">// selective, explicit, highly readable verification</span></div><div class="line">verify(list).add(<span class="string">"one"</span>);</div></pre></td></tr></table></figure></p>
<p>运行发现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">org.mockito.exceptions.misusing.NotAMockException: </div><div class="line">Argument passed to verify() is of type ArrayList and is not a mock!</div><div class="line">Make sure you place the parenthesis correctly!</div><div class="line">See the examples of correct verifications:</div><div class="line">verify(mock).someMethod();</div><div class="line">verify(mock, times(10)).someMethod();</div><div class="line">verify(mock, atLeastOnce()).someMethod();</div></pre></td></tr></table></figure>
<p>这就是mock的误区一：<br><strong>Mockito.mock()并不是mock一整个类，而是根据传进去的一个类，mock出属于这个类的一个对象，并且返回这个mock对象；而传进去的这个类本身并没有改变，用这个类new出来的对象也没有受到任何改变！</strong></p>
<p>结合上面的例子，Mockito.mock(ArrayList.class);只是返回了一个属于ArrayList这个类的一个mock对象。ArrayList这个类本身没有受到任何影响，而 list 不是一个mock对象。Mockito.verify()的参数必须是mock对象，也就是说，Mockito只能验证mock对象的方法调用情况。因此，上面那种写法就出错了。</p>
<h3 id="误区二"><a href="#误区二" class="headerlink" title="误区二"></a>误区二</h3><p>我们先看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> UserLoginTask mAuthTask;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</div><div class="line">        mAuthTask = <span class="keyword">new</span> UserLoginTask(email, password);</div><div class="line">        </div><div class="line">        <span class="comment">//执行登录操作</span></div><div class="line">        mAuthTask.execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面是一个登录操作， 现在我们来验证 login() 函数， 因为它没有返回值，这时候我们只要验证 execute() 有没有执行就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    UserLoginTask mockLoginTask = mock(UserLoginTask.class);</div><div class="line">    LoginPresenter loginPresenter = <span class="keyword">new</span> LoginPresenter();</div><div class="line">    loginPresenter.login(<span class="string">"jason@gmail.com"</span>, <span class="string">"123456"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//验证是否执行 excute()</span></div><div class="line">    verify(mockLoginTask).excute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于 UserLoginTask 继承 AsyncTask， 所以会报错，同误区一中的问题一样（not  mock），这时候我们需要用到 Robolectric 框架，这个可以参考我<strong><a href="http://hujiandong.com/2016/05/20/android-unit-test/">以前写的</a></strong>。解决这个问题以后你会发现，fuck，怎么还有问题， 什么鬼。。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/mock_wanted.png" alt=""></p>
<p>mock的误区二：<br><strong>mock出来的对象并不会自动替换掉正式代码里面的对象，你必须要有某种方式把mock对象应用到正式代码里面。</strong></p>
<p>这个时候我们可以通过 构造方式将依赖传进去，就 OK 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> UserLoginTask mAuthTask; <span class="comment">//===&gt;</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginPresenter</span><span class="params">(UserLoginTask mAuthTask)</span> </span>&#123;</div><div class="line">        <span class="comment">//TODO test argument</span></div><div class="line">        <span class="comment">//执行登录操作</span></div><div class="line">        mAuthTask.execute(email, password);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改测试用例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">…</div><div class="line">LoginPresenter loginPresenter = new LoginPresenter(mockLonginTask); //==&gt;</div></pre></td></tr></table></figure></p>
<p>运行发现终于成功了， 不容易。。</p>
<h3 id="验证方法调用及参数"><a href="#验证方法调用及参数" class="headerlink" title="验证方法调用及参数"></a>验证方法调用及参数</h3><p>使用Mockito，验证一个对象的方法调用情况：<br>Mockito.verify(objectToVerify).methodToVerify(arguments);<br>其中 objectToVerify 和 methodToVerify 对应上面的 mockedList 和 add，表示验证 mockedList 的 add 方法是否传入参数是 one。</p>
<p>很多时候你并不关心被调用方法的参数具体是什么，或者是你也不知道，你只关心这个方法得到调用了就行。这种情况下，Mockito 提供了一系列的 any 方法，来表示任何的参数都行。</p>
<p>anyString() 表示任何一个字符串都可以。类似 anyString，还有 anyInt, anyLong, anyDouble 等等。anyObject 表示任何对象，any(clazz) 表示任何属于clazz的对象。 举个栗子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   <span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDoGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	Http http = spy(<span class="keyword">new</span> Http(<span class="number">5000</span>, <span class="number">5000</span>));</div><div class="line">	URL url = createUrlConnection();</div><div class="line">	http.doGet(url, ContentType.HTML.str);</div><div class="line">	verify(http).createHttpUrlConnection(any(URL.class), any(Http.Method.class), anyString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="指定-Mock-对象的某些方法的行为"><a href="#指定-Mock-对象的某些方法的行为" class="headerlink" title="指定 Mock 对象的某些方法的行为"></a>指定 Mock 对象的某些方法的行为</h3><p>那么接下来，我们就来介绍 Mock 的第二大作用，先介绍其中的第一点：指定 Mock 对象的某个方法返回特定的值。<br>我们见面的 login() 进行修改， 添加对网络的判断， 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</div><div class="line">    <span class="comment">//TODO test argument</span></div><div class="line">    <span class="keyword">if</span>(!NetManager.isConnected()) &#123; <span class="comment">//添加网络判断===&gt;</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//执行登录操作</span></div><div class="line">    mAuthTask.execute(email, password);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NetManagerWraper netManagerWraper = mock(NetManagerWraper.class); <span class="comment">//==&gt;</span></div><div class="line">when(netManagerWraper.isConnected()).thenReturn(<span class="keyword">false</span>); ==&gt;</div></pre></td></tr></table></figure></p>
<p>下面我们说说怎么样指定一个方法执行特定的动作，这个功能一般是用在目标的方法是 void 类型的时候。<br>现在假设我们的 LoginPresenter 的 login() 方法是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行登录操作, 并且处理网络返回</span></div><div class="line">mAuthTask.execute(email, password, <span class="keyword">new</span> NetworkCallBack() &#123;</div><div class="line">                         <span class="meta">@Override</span></div><div class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object data)</span> </span>&#123;</div><div class="line"></div><div class="line">                         &#125;</div><div class="line"></div><div class="line">                         <span class="meta">@Override</span></div><div class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>&#123;</div><div class="line"></div><div class="line">                         &#125;</div><div class="line">                         &#125;);</div></pre></td></tr></table></figure></p>
<p>我们想进一步测试传给 NetworkCallback 里面的代码，验证 view 得到了更新等等。在测试环境下，我们并不想依赖 excute 的真实逻辑，而是让 mAuthTask<br>直接调用传入的 NetworkCallback 的 onSuccess 或 onFailed 方法。这种指定 Mock 对象执行特定的动作的写法如下：<br>`Mockito.doAnswer(desiredAnswer).when(mockObject).targetMethod(args);<br>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">doAnswer(<span class="keyword">new</span> Answer() &#123;</div><div class="line">             <span class="meta">@Override</span></div><div class="line">             <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">             <span class="comment">//这里可以获得传给performLogin的参数</span></div><div class="line">             Object[] arguments = invocation.getArguments();</div><div class="line"></div><div class="line">             <span class="comment">//callback是第三个参数</span></div><div class="line">             NetworkCallBack callback = (NetworkCallBack) arguments[<span class="number">2</span>];</div><div class="line"></div><div class="line">             callback.onSuccess(<span class="keyword">null</span>);</div><div class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">             &#125;</div><div class="line">             &#125;).when(mockLonginTask).execute(anyString(), anyString(), any(NetworkCallBack.class));</div></pre></td></tr></table></figure>
<p>我们想在调用某些无返回值函数的时候抛出异常，那么可以使用 doThrow 方法。如果想简单的指定目标方法“什么都不做”，那么可以使用 Mockito.doNothing()。如果你想让目标方法调用真实的逻辑，可以使用 Mockito.doCallRealMethod()（默认不是的， 请看下文）。</p>
<h2 id="Spy"><a href="#Spy" class="headerlink" title="Spy"></a>Spy</h2><p>如果我们不指定 Mock 对象方法的行为， 那么他是不是走真实逻辑呢？ 答案是否定的。如果没我们不指定它的行为，对于 Mock 对象的所有非 void 方法都将返回默认值 int，long 类型方法将返回0，boolean 方法将返回 false，对象方法将返回 null 等等；而 void 方法将什么都不做。</p>
<p>然而很多时候，你希望达到这样的效果：除非指定，否者调用这个对象的默认实现，同时又能拥有验证方法调用的功能。这正好是 spy 对象所能实现的效果。<br>创建Spy方式：</p>
<ul>
<li>Mockito.spy(toMockObject);</li>
<li>通过注解的方式@Spy</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpy</span><span class="params">()</span> </span>&#123;</div><div class="line">    NetManagerWraper spy = spy(<span class="keyword">new</span> NetManagerWraper());</div><div class="line">    assertTrue(spy.isConnected());</div><div class="line">    when(spy.isConnected()).thenReturn(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>spy 与 mock 的唯一区别就是默认行为不一样： spy 对象的方法默认调用真实的逻辑，mock 对象的方法默认什么都不做，或直接返回默认值。</strong></p>
<h2 id="Mockito-Annotation"><a href="#Mockito-Annotation" class="headerlink" title="Mockito Annotation"></a>Mockito Annotation</h2><p>通过 Mockito 注解可以快速创建 Mock 对象， 这样对于我们这样的懒人来说，是不是很爽。 上面我也简单提到了， 我们可以通过 mock() 和 @Mock 创建， @Mock 就是通过注解的方式创建的， 由于我们使用注解， 当然我们要告诉 Mockito 框架， 不然它怎样知道你使用注解了， 难道它是神吗？ 加上@Rule 就行了， 这样JUnit Rule（？）就会每个测试方法测试前进行检查。添加方法：<code>@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();</code>， 当然创建 spy 对象也可以加 @Spy。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上面的就是 Mockito 的基本使用， 当然由于并不是很全，更全面的可以看<strong><a href="http://www.vogella.com/tutorials/Mockito/article.html" target="_blank" rel="external">这里</a></strong>。基本的概念都有了， 下面的就是多用， 在项目中发现问题， 然后带着问题去查看文档。 Android 下还可以用 Dagger 动态依赖框架进行测试， 由于涉及到 Dagger 框架的使用，这个我们可以单独来说， 前提是你知道 Dagger 怎样用。</p>
<p>上面代码在 <strong><a href="https://github.com/jasonim/JasonAndroidSimple/tree/master/mocksample" target="_blank" rel="external">Github</a> 上</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.vogella.com/tutorials/Mockito/article.html" target="_blank" rel="external">http://www.vogella.com/tutorials/Mockito/article.html</a></p>
<p><a href="http://chriszou.com/2016/04/29/android-unit-testing-mockito.html" target="_blank" rel="external">http://chriszou.com/2016/04/29/android-unit-testing-mockito.html</a></p>
<p><a href="https://medium.com/square-corner-blog/mockito-on-android-88f84656910" target="_blank" rel="external">https://medium.com/square-corner-blog/mockito-on-android-88f84656910</a></p>
]]></content>
    
    <summary type="html">
    
      Android 单元测试--Mock及Mockito
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
      <category term="单元测试" scheme="http://hujiandong.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android常用的开源项目及其比较系列-序列化篇</title>
    <link href="http://hujiandong.com/2016/11/07/android-open-source-serial/"/>
    <id>http://hujiandong.com/2016/11/07/android-open-source-serial/</id>
    <published>2016-11-07T08:48:27.000Z</published>
    <updated>2016-11-07T08:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进入今天的主题之前我们来说一下当下比较火的话题， 一个AR类游戏刷爆国外网络社交平台？是的，它就是<strong>Pokemon Go</strong>，中文意思就是皮卡丘；一个抓精灵手游，通过你的位置信息，根据不同场景的显示不同精灵。不过可惜国内没有开服，听说东北一些地区可以玩。本来不怎么关注游戏的， 也荡起涟漪想体验体验。另一个就是和电影明星赵薇相关的，大家都称“赵薇事件”，一个微博电影宣传照引发的事件。事情刚开始时本来想写一点对此事一些看法的，但还没来得及写，整个事情就像我想想的方向发展了。你猜猜还会不会再次反转，你们还是洗洗睡吧；所以你会发现有些东西不一定是我们看到的， 特别是涉及到政治相关的。</p>
<h1 id="动态注入"><a href="#动态注入" class="headerlink" title="动态注入"></a>动态注入</h1><h2 id="AndroidAnnotations"><a href="#AndroidAnnotations" class="headerlink" title="AndroidAnnotations"></a>AndroidAnnotations</h2><h2 id="butterknife"><a href="#butterknife" class="headerlink" title="butterknife"></a>butterknife</h2><h2 id="Dagger"><a href="#Dagger" class="headerlink" title="Dagger"></a>Dagger</h2><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="Jackjson"><a href="#Jackjson" class="headerlink" title="Jackjson"></a>Jackjson</h2><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2>]]></content>
    
    <summary type="html">
    
      介绍常用的序列化框架和注解框架
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
      <category term="开源项目" scheme="http://hujiandong.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Android常用的开源项目及其比较系列-Retrofit进阶教程</title>
    <link href="http://hujiandong.com/2016/11/07/android_retrofit_advanced/"/>
    <id>http://hujiandong.com/2016/11/07/android_retrofit_advanced/</id>
    <published>2016-11-07T08:48:27.000Z</published>
    <updated>2016-11-07T08:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们谈了谈Androiod开源项目的网络框架， 比较了它们之间的优缺点，原文在<a href="http://hujiandong.com/2016/06/27/android_open_source_network/"><strong>这里</strong></a> 。今天我们着重谈谈Retrofit框架如何更友好的使用，本着提出问题解决问题的原则，也为大家以后解决问题提供基本思路。</p>
<h1 id="目前都有哪些问题？"><a href="#目前都有哪些问题？" class="headerlink" title="目前都有哪些问题？"></a>目前都有哪些问题？</h1><p>根据官方Demo， 简单使用是这么样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GithubService <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">          Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">                    .baseUrl(BASE_URL)</div><div class="line">                    .addConverterFactory(GsonConverterFactory.create())</div><div class="line">                    .build();</div><div class="line">            <span class="keyword">return</span> retrofit.create(GithubService.class);</div><div class="line"></div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>上面代码如果用在实际项目中有如下问题：</p>
<ul>
<li><p>只能创建指定的服务，而实际项目中可能有多种服务，如：登录，支付、事件上报、Github</p>
</li>
<li><p>URL固定，同样的实际项目中不同服务 base url可能不同。</p>
</li>
<li><p>如果项目https中用到自签名证书该怎么办？</p>
</li>
</ul>
<h1 id="如何解决问题？"><a href="#如何解决问题？" class="headerlink" title="如何解决问题？"></a>如何解决问题？</h1><p>上面我们简单提出我们会遇到的问题， 其实总结就是一个问题<strong>如何更好的封装Retrofit?</strong>对于封装每个人的理解不一样，这就是为什么android中会出现那么多开源网络框架，我一直爱说“没有最好的、只有更好的”。</p>
<p>前面两个问题解决基本思路是首先我们提炼公共部分，然后实现不同的部分,，废话不多说先上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_API_BASE_URL = <span class="string">"https://api.github.com/"</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Retrofit.Builder builder =</div><div class="line"></div><div class="line">            <span class="keyword">new</span> Retrofit.Builder().</div><div class="line"></div><div class="line">            addConverterFactory(GsonConverterFactory.create());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 创建制定api服务</div><div class="line"></div><div class="line">     * <span class="doctag">@param</span> serviceClass</div><div class="line"></div><div class="line">     * <span class="doctag">@param</span> baseUrl</div><div class="line"></div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt;</div><div class="line"></div><div class="line">     * <span class="doctag">@return</span></div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">createService</span><span class="params">(Class&lt;T&gt; serviceClass, String baseUrl)</span> </span>&#123;</div><div class="line"></div><div class="line">        setApiBaseUrl(baseUrl);</div><div class="line"></div><div class="line">        OkHttpClient client = OkHttpManager.getOkHttpClient(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        Retrofit retrofit = builder.client(client).build();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> retrofit.create(serviceClass);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"></div><div class="line">     * 设置base url</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setApiBaseUrl</span><span class="params">(String baseUrl)</span> </span>&#123;</div><div class="line"></div><div class="line">        String apiBaseUrl = baseUrl == <span class="keyword">null</span> ? DEFAULT_API_BASE_URL : baseUrl;</div><div class="line"></div><div class="line">        builder.baseUrl(apiBaseUrl);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码我们可以看到创建一个createService抽象方法，让子类进行相应的实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">GithubHttpService</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    mService = createService(GithubAPIService.class, PAY_API_BASE_URL);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何解决自签名问题？"><a href="#如何解决自签名问题？" class="headerlink" title="如何解决自签名问题？"></a>如何解决自签名问题？</h2><p>解决签名问题之前，我们来说说什么是自签名？因为Retrofit访问网络是通过okhttp去真正进行网络请求的， 而okhttp默认情况下是支持https协议的，比如：<a href="https://www.google.com、https://www.github.com。支持的https的网站基本都是CA机构颁发的证书，默认情况下是可以信任的。" target="_blank" rel="external">https://www.google.com、https://www.github.com。支持的https的网站基本都是CA机构颁发的证书，默认情况下是可以信任的。</a></p>
<p>当自己搭建https的网站，自己通过keytool去生成一个证书，然后使用，并不是CA机构去颁发的。使用自签名证书的网站，大家在使用浏览器访问的时候，一般都是报风险警告，大名鼎鼎的网站就是这么干的，12306。</p>
<p>如果通过代码访问，可能有如下异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">javax.net.ssl.SSLHandshakeException: </div><div class="line">    java.security.cert.CertPathValidatorException: </div><div class="line">        Trust anchor <span class="keyword">for</span> certification path not found.javax.net.ssl.SSLHandshakeException:</div></pre></td></tr></table></figure>
<p>简单说一下， https协议其实是http+SSL， SSL位于TCP/IP和HTTP协议之间，最终保证数据安全。客服端和服务端建立连接之前需要，先要进行一次握手，基本原理如下：</p>
<blockquote>
<ol>
<li>浏览器将自己支持的一套加密算法、HASH算法发送给网站。</li>
</ol>
</blockquote>
<ol>
<li><p>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</p>
</li>
<li><p>浏览器获得网站证书之后，开始验证证书的合法性，如果证书信任，则生成一串随机数字作为通讯过程中对称加密的秘钥。然后取出证书中的公钥，将这串数字以及HASH的结果进行加密，然后发给网站。</p>
</li>
<li>网站接收浏览器发来的数据之后，通过私钥进行解密，然后HASH校验，如果一致，则使用浏览器发来的数字串使加密一段握手消息发给浏览器。</li>
<li>浏览器解密，并HASH校验，没有问题，则握手结束。接下来的传输过程将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li>
</ol>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SSLParams <span class="title">getSslSocketFactory</span><span class="params">(InputStream[] certificates, InputStream bksFile, String password)</span> </span>&#123;</div><div class="line"></div><div class="line">        SSLParams sslParams = <span class="keyword">new</span> SSLParams();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">            TrustManager[] trustManagers = prepareTrustManager(certificates);</div><div class="line"></div><div class="line">            KeyManager[] keyManagers = prepareKeyManager(bksFile, password);</div><div class="line"></div><div class="line">            SSLContext sslContext = SSLContext.getInstance(<span class="string">"TLS"</span>);</div><div class="line"></div><div class="line">            X509TrustManager trustManager;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (trustManagers != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                trustManager = <span class="keyword">new</span> MyTrustManager(chooseTrustManager(trustManagers));</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                trustManager = <span class="keyword">new</span> UnSafeTrustManager();</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            sslContext.init(keyManagers, <span class="keyword">new</span> TrustManager[]&#123;trustManager&#125;, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">            sslParams.sSLSocketFactory = sslContext.getSocketFactory();</div><div class="line"></div><div class="line">            sslParams.trustManager = trustManager;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> sslParams;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面代码主要干了上面几件事</p>
<ul>
<li><p>构造CertificateFactory对象，通过它的generateCertificate(is)方法得到Certificate。</p>
</li>
<li><p>然后讲得到的Certificate放入到keyStore中。</p>
</li>
<li><p>通过trustManagers、keyManagers初始化我们的SSLContext</p>
</li>
</ul>
<p>调用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">setHttpBuilderSSLParams</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//设置自签名证书相关参数</span></div><div class="line"></div><div class="line"><span class="comment">//        InputStream[] certificates = &#123;new Buffer().writeUtf8(CER_TEST).inputStream()&#125;;</span></div><div class="line"></div><div class="line">        HttpsUtils.SSLParams sslParams = HttpsUtils.getSslSocketFactory(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        httpBuilder.hostnameVerifier(<span class="keyword">new</span> HttpsUtils.UnSafeHostnameVerifier())</div><div class="line"></div><div class="line">                .sslSocketFactory(sslParams.sSLSocketFactory, sslParams.trustManager);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如果是单向认证，上面就可以了， 如果是双向的，即服务端要认证客服端的合法性，HttpsUtils.getSslSocketFactory(null, null, null) 后两个参数就是要填client的bsf文件和相应的密码了，一般用在安全性比较高的场景，如：支付。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了， 到目前为止我们已经解决上面所提到的问题了， 这里只是Call使用， 还可以结合RxJava一块使用， 可以让威力变得无穷。</p>
<p>如果你有更好的想法， 可以联系我，一块探讨、进步！</p>
<p>项目地址:<a href="https://github.com/jasonim/Retrofit-Utils-" target="_blank" rel="external"><strong>GitHub</strong></a></p>
]]></content>
    
    <summary type="html">
    
      网络篇
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
      <category term="开源项目" scheme="http://hujiandong.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Android常用的开源项目及其比较系列-网络篇</title>
    <link href="http://hujiandong.com/2016/11/07/android_open_source_network/"/>
    <id>http://hujiandong.com/2016/11/07/android_open_source_network/</id>
    <published>2016-11-07T08:48:27.000Z</published>
    <updated>2016-11-07T08:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇我们谈了谈图片的加载相关的库，在开发中我们少不了请求网络， 主要用到http协议这篇我们继续这个系列，说说开发中我们常用的和网络相关的开源框架有哪些。首先我们去Github上看看排在前几位的和网络相关框架。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/B55687C9-152A-409B-82E4-58B51ED06AF2.png" alt=""></p>
<p>通过上图是通过star排序的结果，我们可以发现它们就是Retrofit、okhttp、android-async-http、xUtils。由于xUtils公共的库它不是只支持http，还支持orm、bitmap、view注解，本着专一原则我们项目中就不会选择xUtils， 这里我们就不介绍它了。</p>
<p>下面我们就分别说说Retrofit、okhttp、android-async-http、还要volley。</p>
<h1 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h1><p>Google提供网络通信库，在2013年Google I/O大会上推出了一个新的网络通信框架，官方是这样说的:</p>
<blockquote>
<p>Easy, Fast Networking for Android</p>
</blockquote>
<p>特点：</p>
<ul>
<li><p>自动调度网络请求</p>
</li>
<li><p>多线程并发网络连接、请求优先级</p>
</li>
<li><p>请求Cache和内存管理</p>
</li>
<li><p>扩展性强 如：支持自定义重连等</p>
</li>
<li><p>支持请求取消</p>
</li>
<li><p>强大的Debug、tracing</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于大数据量的网络操作糟糕， 如：下载文件等</li>
</ul>
<p>下图是它的工作原理图</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/volley.png" alt=""></p>
<p>它的设计目标就是非常适合去进行数据量不大，但通信频繁的网络操作，如list加载等等</p>
<p>项目地址：<a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external">https://android.googlesource.com/platform/frameworks/volley</a></p>
<p>技术文档：<a href="http://commondatastorage.googleapis.com/io-2013/presentations/110%20-%20Volley-%20Easy,%20Fast%20Networking%20for%20Android.pdf" target="_blank" rel="external">http://commondatastorage.googleapis.com/io-2013/presentations/110%20-%20Volley-%20Easy,%20Fast%20Networking%20for%20Android.pdf</a></p>
<h1 id="okhttp"><a href="#okhttp" class="headerlink" title="okhttp"></a>okhttp</h1><p>square 开源的 http协议 工具类，Android系统API 19以后HttpURLConnection内部实现就是使用了okhttp</p>
<p>特点：</p>
<ul>
<li>支持Http/2，Http/2主要支持 SPDY( <a href="http://zh.wikipedia.org/wiki/SPDY" target="_blank" rel="external">http://zh.wikipedia.org/wiki/SPDY</a> )协议。SPDY 协议是 Google 开发的基于传输控制协议的应用层协议，通过压缩，多路复用(一个 TCP 链接传送网页和图片等资源)和优先级来缩短加载时间。</li>
<li>如果 Http/2 不可用，利用连接池减少请求延迟</li>
<li>Gzip 压缩</li>
<li><p>Response 缓存减少不必要的请求</p>
</li>
<li><p>支持请求取消</p>
</li>
</ul>
<p>缺点：</p>
<p>在服务器不支持speedy的情况下没有特别明显的优化</p>
<p>工作原理图</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/okhttp.jpg" alt=""></p>
<p>项目地址：<a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a></p>
<h1 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h1><p>Square 开源RESTFUL API库， Retrofit的跟Volley是一个套路，但解耦的更彻底。同时自己内部对OkHtttp客户端做了封装， 用Retrofit+OkHttp基本上已经可以处理任何业务场景了。</p>
<p>特点：</p>
<ul>
<li><p>简化了网络请求流程，支持注解请求</p>
</li>
<li><p>支持多种Converter、还可以自定义， 如：Gson、Jackson、protobuf、xml</p>
</li>
<li><p>可以配合RxJava使用</p>
</li>
</ul>
<p>缺点：</p>
<p>看不出缺点是最大的缺点</p>
<p>下面的工作原理图是网友Stay的作品，如下：</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/retrofit.png" alt=""></p>
<p>项目地址：<a href="https://github.com/square/retrofit" target="_blank" rel="external">https://github.com/square/retrofit</a></p>
<h1 id="android-async-http"><a href="#android-async-http" class="headerlink" title="android-async-http"></a>android-async-http</h1><p>由于HttpClient在Android API 23后就不能使用了， android-async-http内部实现了HttpClient。 这个库我也没有用过， 只是看过一些介绍，下面摘抄了一下官网的说明仅供参考</p>
<ul>
<li><p>Make asynchronous HTTP requests, handle responses in anonymous callbacks</p>
</li>
<li><p>HTTP requests happen outside the UI thread</p>
</li>
<li><p>Requests use a threadpool to cap concurrent resource usage</p>
</li>
<li><p>GET/POST params builder (RequestParams)</p>
</li>
<li><p>Multipart file uploads with no additional third party libraries</p>
</li>
<li><p>Tiny size overhead to your application, only 60kb for everything</p>
</li>
<li><p>Automatic smart request retries optimized for spotty mobile connections</p>
</li>
<li><p>Automatic gzip response decoding support for super-fast requests</p>
</li>
<li><p>Optional built-in response parsing into JSON (JsonHttpResponseHandler)</p>
</li>
<li><p>Optional persistent cookie store, saves cookies into your app’s SharedPreferences</p>
</li>
</ul>
<p>项目地址：<a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">https://github.com/loopj/android-async-http</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网络框架就介绍这么多吧， 以后还有合适的再做更新吧， 希望大家使用愉快！</p>
<blockquote>
<p><strong>本文原创于微信公众号 ”自由狂想“ 转载务必注明出处！</strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      网络篇
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
      <category term="开源项目" scheme="http://hujiandong.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Android Log打印的正确姿势</title>
    <link href="http://hujiandong.com/2016/11/07/android-log-used/"/>
    <id>http://hujiandong.com/2016/11/07/android-log-used/</id>
    <published>2016-11-07T08:48:27.000Z</published>
    <updated>2016-11-07T08:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家对输出Log肯定不陌生吧， 任何语言任何程序都少不了Log读出， 程序交付前我们可以用它来调试code， 交付后我们可以用它来排除问题。记得当时用C写程序时，我们经常唱“print 大法好哎！print 大法好哎！print 大法好哎！”</p>
<p>Log 的输出是耗时的， 正确的Log打印可以提供工作效率，反之会带来副作用，所以要善用Log打印。有人把程序员分为五类，你可能多多少少有它们中一类或多类的影子。</p>
<blockquote>
<ul>
<li>IDD（IDE-Driven Development），也就是IDE驱动开发，几乎是初学者进入软件开发的殿堂的必经之路。IDE开发者屏蔽了很多细节，并且几乎不用配置（相对于 vim / emacs / sublime）就可以使用代码自动补全，代码跳转，搜索，以及签入签出等软件开发中将会使用到的几乎所有工作。</li>
<li>DDD（Debugger-Driven Development）<br>DDD，面向调试器开发，是 IDD 依赖到一定程度的必然反应。这种开发模式的典型表现为：写出来的代码不知道对不对，从头到尾设置无数个断点，然后进入到调试模式，一个断点一个断点跟踪。发现一个问题，解决一个问题（也许引入一个新的问题），直到所有断点走数遍，所有遇到的问题被消灭，抹一抹头上的汗，心里骂上一句：妈的，这段代码老子（娘）终于调通了！</li>
<li>BDD（Bug-Driven Development）<br>看到 BDD，也就是问题单驱动开发，相信大家都相视一笑。本来这里我想用 TDD（Ticket-Driven Development），更接近我的原意，为了不和 Test-Driven Development 混淆，故而只好改成 BDD。这可能是我们最熟悉的开发模式了 —— 在一个业务稳定的软件公司（甭管规模大小），勉力维护现有的代码，小心地添加新功能是多数程序员的主要职责。在这些公司里，与其说我们是工程师，不如说我们是补锅匠。看不懂代码？没关系，只要你会读日志（出错信息）；解决不了问题？不打紧，能找到 workaround 把问题绕过去也可以，更有甚者，遇到神问题，看不懂，想不明，解不了，还没有 workaround，大笔一挥：not reproducible，就把问题关了，几个月半年后，说不定自己已经去补别的锅了。</li>
<li>RDD（Rat-race-game-Driven Development）<br>RDD，老鼠赛跑驱动的开发，是指那些整个职业生涯都在原地打转的开发模式。Rat race game 是『富爸爸穷爸爸』中的经典例子 —— 老鼠在环形的笼子里拼命地奔跑。</li>
</ul>
</blockquote>
<p>如想了解更多， 请参见<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=402343575&amp;idx=1&amp;sn=cf5bd19b7eb979c0904692475c5f997d&amp;scene=0#wechat_redirect" target="_blank" rel="external">原文</a>, 看看作者怎么分析每类人的， 你值得拥有。 </p>
<p>好了， 来说说Android的Log打印的一些方法和技巧，为了简单起见，下文中AS就是Android Studio的缩写。</p>
<h1 id="善用adb-logcat"><a href="#善用adb-logcat" class="headerlink" title="善用adb logcat"></a>善用adb logcat</h1><p>我看到有些测试人员为了，看程序的Log， 还特意装一个AS。有时候想问为什么不用adb logcat，难道是没有linux下的shell命令吗， 好吧， 被你的无邪打败了。</p>
<p>有时候我们要看一个Java层的奔溃，我仅仅需要下面命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">adb logcat | grep -i &quot;system.err&quot;</div></pre></td></tr></table></figure>
<p>想看看别的，使用process输出格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">adb logcat -v process</div></pre></td></tr></table></figure>
<h1 id="AS-使用技巧"><a href="#AS-使用技巧" class="headerlink" title="AS 使用技巧"></a>AS 使用技巧</h1><p>AS提供了很多的模板功能, 自己也可以根据情况自己定义：</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/live-template.png" alt="template设置"></p>
<p>自动填写Tag、方法名和返回值：</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/log.gif" alt=""></p>
<h1 id="动态设置值"><a href="#动态设置值" class="headerlink" title="动态设置值"></a>动态设置值</h1><p>你在调试时会不也遇到这样的情况，为了进入不同分支，最笨的办法是每次都有修改一下条件变量的代码， 然后重新编译运行。现在我们可以利用debug的setValue(Mac F2)方法动态设置值, 下面代码 变量b 开始等于0， 正常情况下会进入catch条件; 现在我将它修改为2， 它就不会进入catch条件了。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/setvalue.gif" alt=""> </p>
<h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><p>你可以用第三方库（<a href="https://github.com/orhanobut/logger" target="_blank" rel="external">logger</a>、<a href="https://github.com/pengwei1024/LogUtils" target="_blank" rel="external">LogUtils</a>、<a href="https://github.com/JakeWharton/timber" target="_blank" rel="external">timber</a>）或自己改造log框架， 让打印更美观。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/logger-log.png" alt="Logger效果图"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一万个人心中有一万个丘比特，所有找到一个自己适合的打印方式。</p>
<p><strong>希望大家使用愉快！</strong></p>
]]></content>
    
    <summary type="html">
    
      Android Log打印的正确姿势
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android项目持续集成-Travis CI</title>
    <link href="http://hujiandong.com/2016/11/07/android-continuous-integration-travis/"/>
    <id>http://hujiandong.com/2016/11/07/android-continuous-integration-travis/</id>
    <published>2016-11-07T08:48:23.000Z</published>
    <updated>2016-11-07T08:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前在写代码重构中提到，所有的重构都是建立在测试的基础上的， 没有测试覆盖的重构都是在耍流氓，其中我也提到了持续构建（CI）。传统的、非敏捷的软件创建方法通常依赖于一个更严格管制的开发流。瀑布流程就是这方面的一个示例，其中需求、设计、开发和测试的每个活动都是连续执行的。而现今互联网时期都受益于敏捷开发方式，他们主要采取快速迭代开发、多人协作式开发推动项目的发展。在代码或者项目开发过程中，就能发现问题。</p>
<h1 id="什么是CI-持续集成-？"><a href="#什么是CI-持续集成-？" class="headerlink" title="什么是CI(持续集成)？"></a>什么是CI(持续集成)？</h1><p>根据 Martin Fowler（现就职于ThoughtWorks） 的观点，持续集成（continuous integration）是一种软件开发实践，要求团队成员经常集成他们的工作。每个人至少每天集成一次，这导致每天有多个集成。集成是通过自动化的构建进行验证的，这些构建运行回归测试，以尽快检测集成错误。团队发现，这种方法会导致集成问题大幅减少，更快地实现有凝聚力的软件开发。</p>
<p>CI的目的就是及早地、经常地改正错误。这样就可以避免它们稍后在项目中发展成为更大、更难解决的问题。该技术提供的好处之一是能够提供在项目时间表中多个日期进行构建和测试的更小的功能性发布。通过验证来自团队的架构、需求和时间表估算，每个交付都降低了项目风险。</p>
<p>知乎上有一个相关问题的回答：<a href="https://www.zhihu.com/question/23444990" target="_blank" rel="external">如何理解持续集成、持续交付、持续部署？</a> 大家可以看看。</p>
<hr>
<p>说了这么多，CI这么好怎么用了？当然CI的工具很多，Jenkins、Travis CI、Circle CI等等。Jenkins现在主要用在工作中，特点是构建比较灵活，插件比较丰富。</p>
<p>Travis CI主要用在个人项目中， 主要于Github结合，构建简单。今天我们来说说Travis CI。</p>
<h1 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h1><p>通过<a href="https://travis-ci.org" target="_blank" rel="external">官网</a> 说明，步骤和把大象装进冰箱一样多，也是三步：</p>
<p><strong>1. 打开开关</strong></p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/travis.png" alt=""></p>
<p><strong>2. 新建和配置.travis.yml文件</strong></p>
<p>Travis CI使用YAML文件作为构建脚本，在项目根目录创建.travis.yml文件，下面主要是针对SDK API 23的配置。</p>
<p>android SDK和依赖相关：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">language: android</div><div class="line"></div><div class="line">android:</div><div class="line"></div><div class="line">  components:</div><div class="line"></div><div class="line">    # Uncomment the lines below if you want to</div><div class="line"></div><div class="line">    # use the latest revision of Android SDK Tools</div><div class="line"></div><div class="line">    - platform-tools</div><div class="line"></div><div class="line">    - tools</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    # The BuildTools version used by your project</div><div class="line"></div><div class="line">    - build-tools-23.0.1</div><div class="line"></div><div class="line">    # The SDK version used to compile your project</div><div class="line"></div><div class="line">    - android-23</div><div class="line"></div><div class="line">    # Additional components</div><div class="line"></div><div class="line">    - extra-google-google_play_services</div><div class="line"></div><div class="line">    - extra-google-m2repository</div><div class="line"></div><div class="line">    - extra-android-m2repository</div><div class="line"></div><div class="line">    - addon-google_apis-google-19</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    # Specify at least one system image,</div><div class="line"></div><div class="line">    # if you need to run emulator(s) during your tests</div><div class="line"></div><div class="line">    - sys-img-armeabi-v7a-android-23</div><div class="line"></div><div class="line">    - sys-img-x86-android-17</div></pre></td></tr></table></figure>
<p>模拟器相关：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"># Emulator Management: Create, Start and Wait</div><div class="line"></div><div class="line">before_script:</div><div class="line"></div><div class="line">  - echo no | android create avd --force -n test -t android-23 --abi armeabi-v7a</div><div class="line"></div><div class="line">  - emulator -avd test -no-skin -no-audio -no-window &amp;</div><div class="line"></div><div class="line">  - android-wait-for-emulator</div><div class="line"></div><div class="line">  - adb shell input keyevent 82 &amp;</div></pre></td></tr></table></figure>
<p>编译和测试相关：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">script:</div><div class="line"></div><div class="line">  - ./gradlew build connectedCheck</div></pre></td></tr></table></figure>
<p>也可以指定JDK版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">jdk:</div><div class="line">  - oraclejdk8</div></pre></td></tr></table></figure>
<p><strong>3. 提交.travis.yml文件到远程库上</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">git add .</div><div class="line"></div><div class="line">git ci -m &quot;add travis config&quot;</div><div class="line"></div><div class="line">git push origin master</div></pre></td></tr></table></figure>
<p>更多配置请参考<a href="https://docs.travis-ci.com/user/languages/android" target="_blank" rel="external">官方文档</a> 配置。</p>
<p>最后自动构建完成后， 所在的项目显示效果如下：</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/display.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从技术角度来看，CI 可以帮助团队更高效地工作。这些团队可能是跨职能的，创建配合工作的硬件和软件。他们在地理上可能是分散的，因为不断的集成工作将会确保您没有偏离设计。人们可以在大型团队中工作，因为复杂系统的不同组件将以更可靠的方式一起工作。CI 解决了许多非传统的敏捷团队在没有 CI 时可能都经历过的早期陷阱。CI 与测试驱动的开发相结合使更多人可以利用敏捷，因为它可以让敏捷方法更高效地工作。</p>
<p><strong>祝大家使用愉快！</strong></p>
]]></content>
    
    <summary type="html">
    
      CI的目的就是及早地、经常地改正错误。
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
      <category term="CI" scheme="http://hujiandong.com/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Android 性能优化</title>
    <link href="http://hujiandong.com/2016/10/28/android-performance/"/>
    <id>http://hujiandong.com/2016/10/28/android-performance/</id>
    <published>2016-10-28T07:30:16.000Z</published>
    <updated>2016-11-07T08:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做 APP 优化，查阅官方说明和一些网友的总结，因为涉及内容比较多， 而且一些在项目上也没有用到，没有更多的见解，在这里进行一下整理笔记。</p>
<p>在Android中，性能和内存的关系很密切，因为系统的整体内存大小会影响所有进程的性能，因为垃圾回收器会对运行期间的性能产生很大的影响。下面的重点是运行期间的性能问题而不是内存。主要分为下面几个方面：</p>
<ul>
<li>代码性能优化建议</li>
<li>内存优化</li>
<li>渲染优化</li>
<li>减少 App 大小</li>
<li>App 启动优化</li>
<li>App 后台优化</li>
<li>减少图片下载大小</li>
<li>网络优化</li>
</ul>
<h1 id="代码性能优化建议"><a href="#代码性能优化建议" class="headerlink" title="代码性能优化建议"></a>代码性能优化建议</h1><p>这个使我们写代码时候要特别注意的， 这里不涉及算法、代码设计， 仅仅这样写执行起来更有效， 主要依赖编译器规则。</p>
<p>基本原则：</p>
<ul>
<li>不要做冗余的动作，如打篮球时能一步过的，就一步过， 不要像有的球员本来可以过的，感觉刚才的姿势不够优美， 回到半场重新来。</li>
<li>如果能避免，尽量不要分配内存， 如尽量避免在循环语句里分配内存等。</li>
</ul>
<p>原文：</p>
<blockquote>
<p><a href="http://developer.android.com/training/articles/perf-tips.html" target="_blank" rel="external">http://developer.android.com/training/articles/perf-tips.html</a></p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p>[<a href="http://hukai.me/android-training-course-in-chinese/performance/performance-tips.html" target="_blank" rel="external">http://hukai.me/android-training-course-in-chinese/performance/performance-tips.html</a>]</p>
</blockquote>
<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><p>由于嵌入式设备，内存相对服务器来说， 内存还是很宝贵的，还有 Android 对每个 App 内存限制，让我们在开发中使用内存就显得格外注意了。</p>
<p>明白Android会运行多个Activity和多个并行的Service也是很重要的。在最近App列表中切换而不是重新启动一个App的方式对于创造出一种很好的体验是非常重要的。但是这样意味着如果这些app消耗了比它们本应该消耗的更多内存，那么留给其它的应用的系统内存就很少了。如果这种低内存情况发生，应用就不能保留在后台，系统会干掉app的进程，用户就被迫以重新启动的方式去开启一个App，显然这样的体验就比较差。<br>官网：</p>
<blockquote>
<p><a href="https://developer.android.com/topic/performance/memory.html#remove" target="_blank" rel="external">https://developer.android.com/topic/performance/memory.html#remove</a></p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p><a href="http://www.lightskystreet.com/2016/10/16/android-optimize-memory/" target="_blank" rel="external">http://www.lightskystreet.com/2016/10/16/android-optimize-memory/</a></p>
</blockquote>
<p>Developing for Android, II The Rules: Memory:</p>
<blockquote>
<p><a href="https://medium.com/google-developers/developing-for-android-ii-bb9a51f8c8b9" target="_blank" rel="external">https://medium.com/google-developers/developing-for-android-ii-bb9a51f8c8b9</a></p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p><a href="http://www.lightskystreet.com/2015/06/07/google-for-android-2-memory/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/07/google-for-android-2-memory/</a></p>
</blockquote>
<h1 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h1><p>Android 从一诞生到现在已经发布的 7.0 版本，卡顿和不流畅问题却一直被人们所诟病。客观地来讲，Android 的流畅性确实一直不给力，哪怕是某些大厂的 App ，也都不同程度地存在卡顿问题。从开发角度来说，每个开发者都应该关注下性能优化，在平时的开发工作中注意一些细节，尽可能地去优化应用。本文作为性能优化系列的开篇，先从过度绘制优化讲起。<br>官网：</p>
<blockquote>
<p><a href="https://developer.android.com/topic/performance/rendering/index.html" target="_blank" rel="external">https://developer.android.com/topic/performance/rendering/index.html</a></p>
</blockquote>
<p>Android 过度绘制优化:</p>
<blockquote>
<p><a href="http://jaeger.itscoder.com/android/2016/09/29/android-performance-overdraw.html" target="_blank" rel="external">http://jaeger.itscoder.com/android/2016/09/29/android-performance-overdraw.html</a></p>
</blockquote>
<h1 id="减少-App-大小"><a href="#减少-App-大小" class="headerlink" title="减少 App 大小"></a>减少 App 大小</h1><p>主要减少资源文件包括图片， 减少不用的资源。<br>原文：</p>
<blockquote>
<p><a href="https://developer.android.com/topic/performance/reduce-apk-size.html" target="_blank" rel="external">https://developer.android.com/topic/performance/reduce-apk-size.html</a></p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p><a href="http://www.lightskystreet.com/2016/10/19/android-optimize-image-download-size/" target="_blank" rel="external">http://www.lightskystreet.com/2016/10/19/android-optimize-image-download-size/</a></p>
</blockquote>
<h1 id="App-启动优化"><a href="#App-启动优化" class="headerlink" title="App 启动优化"></a>App 启动优化</h1><p>通常用户期望app响应和加载速度越快越好。一个启动速度慢的app很可能会给用户留下不好的印象，除了导致用户在应用市场上的打分低之外，很有可能导致致用户直接卸载。<br>这篇文章提供了优化app启动时间的方法。先解释了app进程启动的内部流程。然后讨论如何优化启动的性能。最后列出几个常见的启动问题和解决方案。<br>官网：</p>
<blockquote>
<p><a href="https://developer.android.com/topic/performance/launch-time.html#common" target="_blank" rel="external">https://developer.android.com/topic/performance/launch-time.html#common</a></p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p><a href="http://www.lightskystreet.com/2016/10/15/android-optimize-start/" target="_blank" rel="external">http://www.lightskystreet.com/2016/10/15/android-optimize-start/</a></p>
</blockquote>
<h1 id="App-后台优化"><a href="#App-后台优化" class="headerlink" title="App 后台优化"></a>App 后台优化</h1><p>后台进程是内存和电池敏感的。一个隐式的broadcast可能会启动很多监听它的后台进程，即使这些进程可能做得工作不多。这可能丢设备性能和用户体验都有比较大的影响。</p>
<p>为了缓解这种问题，7.0（API 24）做了以下限制：</p>
<ul>
<li>Target为 Android 7.0 (API level 24)的App，将不会再收到在mainfest中注册的 CONNECTIVITY_ACTION广播。运行中的App仍然可以在Main Thread中通过Context.registerReceiver()注册 CONNECTIVITY_CHANGE 广播来监听</li>
<li>App 将不能够发送或者接收 ACTION_NEW_PICTURE or ACTION_NEW_VIDEO。这种优化会影响到所有的app，不仅是target为Android7.0的设备。</li>
</ul>
<p>因此如果你使用了这些intennt，应该尽快的移除对它们的依赖，以便你的app可以在Target为Android 7.0的设备上正常运行。Android框架提供了几种解决方案去减小对这些隐式广播的依赖。比如，JobScheduler and GcmNetworkManager提供了强健的机制去调度特定情况下的网络操作。比如，你也可以使用JobScheduler去响应content provider的变化。JobInfo对象封装了JobScheduler用于调度job的参数。当满足指定的条件的时候，系统会通JobService过执行该job。<br>原文：</p>
<blockquote>
<p><a href="https://developer.android.com/topic/performance/background-optimization.html" target="_blank" rel="external">https://developer.android.com/topic/performance/background-optimization.html</a></p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p><a href="http://www.lightskystreet.com/2016/10/16/android-optimize-background/" target="_blank" rel="external">http://www.lightskystreet.com/2016/10/16/android-optimize-background/</a></p>
</blockquote>
<h1 id="减少图片下载大小"><a href="#减少图片下载大小" class="headerlink" title="减少图片下载大小"></a>减少图片下载大小</h1><p>主要如下：</p>
<ul>
<li>如何选择一种图片格式（PNG、JPG、WebP）</li>
<li>确定准确质量值</li>
<li>服务端的尺寸大小</li>
</ul>
<p>原文：</p>
<blockquote>
<p><a href="https://developer.android.com/topic/performance/network-xfer.html" target="_blank" rel="external">https://developer.android.com/topic/performance/network-xfer.html</a></p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p><a href="http://www.lightskystreet.com/2016/10/19/android-optimize-image-download-size/" target="_blank" rel="external">http://www.lightskystreet.com/2016/10/19/android-optimize-image-download-size/</a></p>
</blockquote>
<h1 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h1><p>位于在城市中的大多数软件开发者来说拥有一些现代的基础设施和移动网络是很简单的。但很多其它地区并不具备这样的设施。更别说LTE或4G了。很多国家的地区还是2G的网络而且可能还要承受大量数据的传输。这样就会导致两个通用的问题：</p>
<ul>
<li>依赖于快速的网络速度 App 严重依赖大媒体数据， 在网络基础较差的地方可能没有选择。但是避免下载，直到条件允许的情况下再去下载也是 App 体验的一部分。</li>
<li>多度同步也许你的 App 希望更新一些信息，但是用户并不需要它，更重要的问题，设备并不应该承受所有应用程序与网络不断交互的情况。这种动态会很容易地使设备持续工作而不能够进行休眠，最终影响电池的续航。</li>
</ul>
<p>原文：</p>
<blockquote>
<p><a href="https://medium.com/google-developers/developing-for-android-iv-e7dc4ce0a59#.l1kwx8e0n" target="_blank" rel="external">https://medium.com/google-developers/developing-for-android-iv-e7dc4ce0a59#.l1kwx8e0n</a></p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p><a href="http://www.lightskystreet.com/2015/06/07/google-for-android-4-network/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/07/google-for-android-4-network/</a></p>
</blockquote>
<p>移动端网络优化:</p>
<blockquote>
<p><a href="http://b.codekk.com/detail/Trinea/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96" target="_blank" rel="external">http://b.codekk.com/detail/Trinea/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96</a></p>
</blockquote>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>当然优化不仅仅是上面所说的， 不同场景方案不一样。<strong>有人的地方就有江湖、有代码的地方就有优化，代码不止、优化不止</strong>。生活当然不是只有诗和远方， 还有代码和段子。</p>
<hr>
<p>PS：苹果发布新款 MacBook Proc ，我没有看发布会， 第二天看了 KeyNote， 发现除了变薄，并没有特点。还把 USB 给取消了，变亮的 logo 也没有了， 反正让我太失望了，还好我有2015款。你们感觉呢？</p>
]]></content>
    
    <summary type="html">
    
      Android 性能优化
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>利用 Markdown here 排版微信公众号</title>
    <link href="http://hujiandong.com/2016/10/20/markdown-here/"/>
    <id>http://hujiandong.com/2016/10/20/markdown-here/</id>
    <published>2016-10-20T12:30:16.000Z</published>
    <updated>2016-11-07T08:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前写的文章一般都会发到个人Blog上面去， 并没有发到微信公众号上面前。当然微信公众号的排版一直是让人头痛的问题， 我也知道现在是移动互联网时代， 微信的时代。 有没有小伙在公众号排版上发费的时间超过半个小时以上的？我先默默举个手。 微信公众号申请一年多时间也没有发布几篇文字。有网友在后台给我留言问，问我你微信公众号是多， 一般回答都是xx， 然后默默补上一句里面没几篇文字。</p>
<p>直到突然的某天，在知乎上发现有人说微信后台支持 Markdown 格式（不知道，没关系，下面我们再说，下面的文章 Markdown 简称 MD），当时心里窃喜还专门尝试了一下， 拷贝一段含有 MD 格式的文字， 预览发现不起作用，心里想是不是骗人的， 不科学啊。最后搜索发现可以用 Markdown here 工具将 MD 格式的转换一下。这样微信排版只需要几分钟就可以搞定了。在我们说Markdown here 之前来介绍一下 Markdown， 它才是以后一切的前提啊。</p>
<h2 id="关于Markdown"><a href="#关于Markdown" class="headerlink" title="关于Markdown"></a>关于Markdown</h2><p>维基：</p>
<blockquote>
<p>Markdown 是一种轻量级标记语言, 它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
</blockquote>
<p>总之就是方便写作，在没用 MD 之前，我是用 Emacs Org-mode 编辑文字和做 TODO list 任务管理。突然某天我发现好多网站后台都支持 MD 了，如简书、Mynote、CSDN等，然后我就这样学习了 MD，并喜欢上它。其实 MD 语法也很简单， 关于 MD 的教程，可以去看看这篇文章：</p>
<blockquote>
<p>[<a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">http://wowubuntu.com/markdown/</a>] </p>
</blockquote>
<h2 id="Markdown-编辑器"><a href="#Markdown-编辑器" class="headerlink" title="Markdown 编辑器"></a>Markdown 编辑器</h2><p>其实我最开始用时是 emacs markdown-mode 并加入一些 snippets,  感觉很好。后来 MalkTalk 推荐的写作工具 Ulysses，尝试一下发现它有如下优点：</p>
<ul>
<li>界面友好</li>
<li>多终端同步</li>
<li>强大的搜索、统计功能</li>
</ul>
<p>写作我现在一般也用它， 可惜它有点贵。 推荐好评比较多的免费 Markdown 编辑器，下面的两款软件我没有用过，大家可以去试一下，来告诉我， 应该是不错的。<br>Sublime Text 2 + MarkdownEditing/Atom，下面使他们的教程。<br>Sublime Text 2：</p>
<blockquote>
<p>[<a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/" target="_blank" rel="external">http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/</a>]<br>Atom:<br><a href="http://xiaolai.li/2016/06/17/makecs-atom-advanced/" target="_blank" rel="external">http://xiaolai.li/2016/06/17/makecs-atom-advanced/</a></p>
</blockquote>
<p>多说一句，工具是解决问题而产生的，选择一个适合你的就行， 如果没找到，就不断的尝试。</p>
<h2 id="Markdown-here"><a href="#Markdown-here" class="headerlink" title="Markdown here"></a>Markdown here</h2><p>Markdown here  是个浏览器插件（Chrome/Firefox/Safari），可以将浏览器中编辑器里的 Markdown 文本转换成渲染过后的 HTML。还能自定义 CSS，对应经常使用 Markdown 格式的人来说， 确实是很爽， 你写邮件、文档等用 Markdown 。</p>
<p>装好插件以后， 下面我们只需要下面几步就可是帮你在微信公众号上排版：</p>
<ol>
<li>将上面写好的拷贝粘贴到微信公共帐号的编辑器中</li>
<li>Ctrl+Alt+M 使用 Markdown Here 渲染</li>
<li>插入图片</li>
</ol>
<p>Markdown here 默认 CSS 和 Github 的显示样式一样，当然上面我们说过可以自定义 CSS 达到想要的效果。</p>
<h2 id="自定义CSS"><a href="#自定义CSS" class="headerlink" title="自定义CSS"></a>自定义CSS</h2><p>Chrome修改路径： </p>
<blockquote>
<p>Chrome → 设置 → 扩展程序 → markdown.here → 选项 → 基本渲染 CSS </p>
</blockquote>
<p>主要对字体大小、行间距、字间距、字体颜色做修改就可以。总结原则如下：</p>
<ul>
<li>文章正文的字号最好在14—18px之间，以16px最为合适。</li>
<li>行间距：1.5-1.75倍的行距看起来会比较舒服。</li>
<li>移动端的文章均无需首行缩进。</li>
<li>段落之间最好空一行。</li>
</ul>
<p>推荐几个人的 Markdown here 自定义样式吧。<br><a href="https://github.com/veganshe/CodeBlock/blob/master/Markdown-here/markdown-here-yzp.css" target="_blank" rel="external">阳志平</a><br><a href="https://gist.github.com/xiaolai/aa190255b7dde302d10208ae247fc9f2" target="_blank" rel="external">李笑来版</a></p>
<p>如果你现在使用的是 Web 版的邮箱，你也可以 Markdown 来书写你的邮件内容，在最后通过 Markdown Here 一键渲染，格式化邮件样式。</p>
<p>祝大家使用愉快！</p>
]]></content>
    
    <summary type="html">
    
      Markdown here 使用和配置
    
    </summary>
    
      <category term="工具" scheme="http://hujiandong.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Markdown" scheme="http://hujiandong.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
