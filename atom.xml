<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonThink&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hujiandong.com/"/>
  <updated>2017-05-06T08:16:20.000Z</updated>
  <id>http://hujiandong.com/</id>
  
  <author>
    <name>JasonThink</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://hujiandong.com/2017/05/06/evils_live/"/>
    <id>http://hujiandong.com/2017/05/06/evils_live/</id>
    <published>2017-05-06T07:50:53.000Z</published>
    <updated>2017-05-06T08:16:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>title: 一个视频直播开源项目<br>date: 2017-04-28 15:30:16<br>categories: 杂谈<br>tags: [杂谈] #文章标签，可空，多标签请用格式，注意:后面有个空格<br>description: 一个视频直播开源项目</p>
<p>我在 「<strong><a href="http://hujiandong.com/2017/04/22/learning_fake/">漫无目标的假学习者</a></strong>」 写到：</p>
<blockquote>
<p>对于技术人来说，目标就是可以做一个解决自己生活中遇到问题的小产品，学习不阶段不要忌讳重复造轮子，努力做到 500 日活；做个开源项目，努力得到500个 Star；做个小工具，努力赚到 500 人民币；做个小社群，努力拥有 500 个注册用户，或者开一篇博客， 写个公众号， 努力做到 500 阅读量。</p>
</blockquote>
<p>当然我也没闲着，不是只是说说， 践行是我实现目标唯一途径。年后我们启动一个直播的软件开发工具包（SDK）项目， 目前支持 Android 平台， 以后还会支持 Web/IOS 平台。主要包括音视频采集、推流、预览、播放等功能。</p>
<p>目前支持的功能：</p>
<ul>
<li>视频编码：H.264</li>
<li>推流协议：RTMP</li>
<li>预览与推流分辨率可分别自由设置</li>
<li>支持前、后置摄像头动态切换</li>
</ul>
<p>开发过程中也遇到一些坑：</p>
<ul>
<li>Activity 设置为竖屏时，SurfaceView 预览图像颠倒90度。</li>
<li>SurfaceView 预览图像拉伸变形。</li>
<li>播放视频流延时30s 以上。</li>
<li>编码图像显示黑白，无法显示彩色问题。</li>
<li>各种 Crash</li>
<li>…</li>
</ul>
<p>现在仅仅实现部分功能， 项目还将持续更新中…</p>
<p>其中 Songlcy 小伙伴看到这个项目后问， 如何快速入门音视频，直播？希望这个项目能真正帮助到类似这样的小伙伴，这也是我们继续的动力。下面是我的回答：<br><img src="http://7xnilf.com1.z0.glb.clouddn.com/tiwen.png" alt=""></p>
<p>小龙同学坐在没有靠背的凳子上 Coding; 阿峰同学笔记本放在被子上或半躺着Coding; 而我坐在垫子上趴在床边Coding。在这个不到 12  平的房间里， 上面的画面不难想象。<br>期间有一次隔壁的一小伙看到我们这样问:</p>
<blockquote>
<p>难道你们是在进行传说中创业吗？</p>
</blockquote>
<p>在这里特别感谢 小龙和阿峰同学参与， 没有他们的参与我是不可能坚持到现在的。由于我们平时都有本职工作要做而且平时都很忙，基本上只能周末参与此项目。为了快速得到正反馈，代码编码质量、Code review、测试覆盖率， 计划的制定和执行力方面多多少少有点问题，不过总体还在可控阶段。</p>
<p><a href="https://github.com/ThinkKeep/EvilsLive" target="_blank" rel="external">ThinkKeep/EvilsLive</a></p>
<p>PS：</p>
<p>最后， 我们的小龙同学要和他妹子结婚了， 看来阿峰同学要失落了， 我顺便讨个喜气，祝小龙：</p>
<p>一阳初动，二姓和谐，庆三多，具四美，五四其倡征风卜。</p>
<p>记得以前再知乎上看到， 『程序员结婚戒指刻什么字好？』其中一个答案很赞：</p>
<p>0  error  0 warning</p>
<p>你可以去试试， 然后告诉我们体验， 是不是还会有 Crash？</p>
<p>五一小长假要到来， 祝大家吃好玩好！</p>
<p>项目的详细信息，请点击原文阅读！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;title: 一个视频直播开源项目&lt;br&gt;date: 2017-04-28 15:30:16&lt;br&gt;categories: 杂谈&lt;br&gt;tags: [杂谈] #文章标签，可空，多标签请用格式，注意:后面有个空格&lt;br&gt;description: 一个视频直播开源项目&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>漫无目标的假学习者</title>
    <link href="http://hujiandong.com/2017/04/22/learning_fake/"/>
    <id>http://hujiandong.com/2017/04/22/learning_fake/</id>
    <published>2017-04-22T07:30:16.000Z</published>
    <updated>2017-05-06T07:48:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几篇文章我们反复提到学习的目的，为什么反复提以及反复写，只因为它太重要、太重要、太重要… 说十遍、一百遍都不为过。</p>
<p>我们好多人因为无意间看到一篇文章，感觉自己很受启发，然后就看更多，自己到最后发现什么也没学会。主要因为自身没有一套认知的体系结构，没能 Get 到作者真正的意图。</p>
<p>我们看似努力，可成绩始终上不去。只因为我们只是忙碌于表层的东西。从来没想过 1+1 = 2 的潜在逻辑和原理。其实老师出题来来回回就那几个套路。真正的学霸从来不读书。多年后我才发现这个道理后。唉，发现自己已经输在起跑线上了。</p>
<p>我们统统称这类为 「<strong>漫无目的的假学习者</strong>」。</p>
<p>我们把学习主要分三类 “器” 、“术”、“道”。</p>
<h1 id="器"><a href="#器" class="headerlink" title="器"></a>器</h1><p>对于个人来说，它是一种具体的工具和软件。任何一个领域，都有对应工具，它们都是因为解决特定问题而出现的，目的更大的提高工作和生产效率。</p>
<p>Java、C、GO、Python、JavaScript等等编程语言就是“器”。</p>
<h1 id="术"><a href="#术" class="headerlink" title="术"></a>术</h1><p>对于个人来说，它是一种具体知识和技能的积累。任何一个专业领域，任何一个专业人士，都是由无数个“细节”构成的，所以细节的积累很重要。当细节积累到一定程度，就有了术，就有能力来驾驭一个领域的专业任务，在这个过程中没有捷径。</p>
<p>在一个项目中编码、调试、联调、测试、分析数据中用到的方法，如框架设计、设计模式等就是“术”。</p>
<h1 id="道"><a href="#道" class="headerlink" title="道"></a>道</h1><p>对于个人来说，它是一种思维能力和思维习惯的修炼，就是要有一种主动的意识，去思考和探索事物的深层的本质，不满足于表象，不满足于道听途说，不满足于流行的概念、术语和观念。这种思维素质难能可贵，但不是高不可攀，要会有意识地自我训练。</p>
<p>函数式编程、面向对象等编程思想、学术论文等就是“道”。</p>
<p>有道无术的人，可以去做观察家，做评论员，鸡汤大师，但永远无法成为一个专业人士。有术无道的人，可以作为一个专业人士，可以解决难题，但是无法思考和判断大的方向，需要别人来指路，或 者靠山寨模仿。而道术兼备的人，必然成为真正的大师，牛逼闪闪熠熠生辉。</p>
<p>从学习、工作的能力来看，离“道”和“术”都有一段距离，只是在“器”这个层面或者“表”层面。就是我们说的“假”学习，每个人都会经历过这个阶段， 不过真正“聪明”的人能很快度过这个阶段。</p>
<p>举个我个人最近的例子，当然我绝对不是聪明的那类人，但是我知道聪明的人通常是怎么做的，我就学习他们做事的方式。我们都知道在手机上看某位公众号的历史文章不支持分页和搜索体验很不好。我也尝试在传送门、搜狗等平台搜索，但并没有找到需要的内容。</p>
<p>知道实在不能忍受了，我就研究怎么抓取公众号的内容。我就在 Github 上找到几个相关项目， 然后测试可行性，不断的调试修改、带着问题查找原理，最终抓取我想要的内容。这件事情大概发费我两个晚上的时间， 收获不仅仅是公众号的内容，顺便了解了微信的 API 的设计接口，而且还学习了 Go 的基本语法。</p>
<p>再来举一个我刚毕业时自学 Python 的反例，当时忘记在哪听说或看的：</p>
<p>C 语言再加上一门脚本语言， 可上九天揽月，下五洋捉鳖。</p>
<p>然后我就自学 Python，拿 『Python 核心编程』 这本书一点点啃， 好像啃了一百多页就放弃了。</p>
<p>当时从来没有想过学习 Python 的目的是什么？即没有揽月，更没有捉鳖。 我们走入为了学习而学习的误区，其实真正学习目的是拿来用的。 因为没有得到正反馈，消耗大量时间和体力过了一遍以后，依然一无所得，你知道我当时有多痛苦吗， 直到现在也没再看过那本书， 看到它就想吐。</p>
<p>网上有些视频和社群带你刷完一本技术书，最后发现没有几个坚持下来的， 主要原因是大部分人上来就被刷吐了， 哪还有以后。</p>
<p>其实正确的姿势是以结果为导向，用到什么学什么，现学现卖。因为我们是在自学又不是在教学，刚开始又不用给别人讲明白，如果有人问你，你就回：</p>
<p>我喜欢，你管我。</p>
<p>你可能会问，好多知识点云里雾里，很多概率不清楚，总是感觉心里不踏实，很焦虑？ 莫急，这个时候你就可以通过视频或一本书去把你不清楚的概率弄明白，这时候你会发现此时的动力和效率比你想象的要惊人。如果还不明白，你也不用怕，继续前行， 多用几次多查几次自然就会明白了。</p>
<p>好了， 总结一下上面的内容，其实只有一句话：</p>
<p>有目标的实践最重要，是的， 有目标的实践最重要。</p>
<p>那问题来了， 定什么目标呢？</p>
<p><strong>对于技术人来说，目标就是可以做一个解决自己生活中遇到问题的小产品，学习不阶段不要忌讳重复造轮子，努力做到 500 日活；做个开源项目，努力得到500个 Star；做个小工具，努力赚到 500 人民币；做个小社群，努力拥有 500 个注册用户，或者开一篇博客， 写个公众号， 努力做到 500 阅读量。</strong></p>
<p>我以前也是去读其他人的技术文章，最后发现至少大多数技术文章都是对我们无益的，读的越多，越是会产生彷徨和焦虑，感觉自己没有成长，缺少自信。缺少自信的表现是你会恐惧未来遇到的新问题，你没有自己真正的独立思考，你只解决了一个眼前问题，你没有办法套用到千千万万个问题上，你无法亢奋自己的神经，而产生持续的学习和研究欲望。</p>
<p>大量读别人的文章，其实你也无法得到一个独立解决问题的方法论，你会滋生思想的懒惰，很多美好的事物和机会，也会和你擦身而过。</p>
<p><strong>有的时候，读其他人的技术文章也会让自己产生一种诡异的满足感，你会感到我貌似很多东西都会，只是有些不熟罢了，真的如此吗？</strong></p>
<p>这也是我为什么公众号上很少写技术相关的，如果看到我写了， 那也是我做复盘笔记， 其实对你们没太大用，仅仅对我有用。真正复杂的东西，依赖的知识点很多，不是一篇或几篇技术文章能涵盖的。</p>
<p>我主张你去看原始的资料，主张你去读系统的书籍，主张你去研究官方或是优秀项目的源码。这些都是一手资料和优质 Demo。这才是真正的方法论，Google 是不会给你带来安全感的，Github 才是你最应该深交的朋友，在它上面花再多时间都不为过。</p>
<p>你可能会问我那样会不会太难？那我问你想不想挣钱？任何行业和领域都有它背后的逻辑和”套路“，这也是我们上面提到”道“的层面，也就是我们常常说的方法论。其实本篇文章你也可以给它看成一篇方法论的文章或者”毒鸡汤“， 随你。</p>
<p>好了，最后如果你还在忧虑，那就行动起来，用行动填满你的思考时间。下一篇，我们来聊聊目标管理， 提前透露一下，目标不是用来管理的， 而是用来实现的。</p>
]]></content>
    
    <summary type="html">
    
      你是不是这样的人呢？
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>这么多社群，你加的过来吗？</title>
    <link href="http://hujiandong.com/2017/04/15/community-talk/"/>
    <id>http://hujiandong.com/2017/04/15/community-talk/</id>
    <published>2017-04-15T07:30:16.000Z</published>
    <updated>2017-04-20T03:06:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇 <a href="http://hujiandong.com/2017/03/27/seven-year-later/"><strong>七年后你还是你吗</strong></a> 中我是这样说的：</p>
<blockquote>
<p>现在又进入以罗振宇为首的内容卖家宣扬的知识学习时期， 已经恐慌了一大批人，很多人像无头苍蝇一样到处付费，到头来却一无所获。我也是其中一员。<br>其实看完牛人的东西，看到刷新甚至颠覆三观的文字，我们要做的不是直接将这些思想刻进脑子，而是去用自己的话去梳理一遍， 梳理其中的逻辑，用文字记录下来， 不断打磨，让我们真正在选择的时候用的上。</p>
</blockquote>
<p>我也加了很多社群，我就不说免费的，说说付费的，避免有打广告嫌疑，这里就不截图展示了。</p>
<p>好多社群我不能说他们没有价值，我也知道，学的越多，觉得这也好，那也不错，都想去看，这个知识点还没有消化又来一个新的，到最后会发现自己脑袋都要炸掉，我们的很多人都是这样，最后我们不是在高效的处理事情，而是作为一个消防员，不断的被事情应对。</p>
<p>就像上面一样这点道理都明白，但我们中的很多人确实没有把控和自制的能力！你不能说对方不好学，问题是一个人一旦承受了太多他承受不了的知识，那么这个时候这样的知识只会让他陷入混乱，自己没有知识体系的构建和培养，而同时又吸收不了外部的知识，那么人就会混乱，导致人更加的迷茫。</p>
<p>慢慢我发现最重要的品质就是专注，在一个领域之内沉淀，我知道什么都学，什么都想知道，其实到最后什么也就知道个大概。</p>
<p>最开始时我也不能免俗，看到了不买会不会失去改变自己的机会呢？那就买吧，把入口占住再说。我在16年仅仅在社群订阅各种专栏方面，粗略算了一下大概六七千。最后发现根本看不过来，整体忙于各个社群中打卡，来寻找安慰  “嗨，你看我的打卡记录，你看我在学习哈”。其实自己有没有真正得到改变，自己心里知道。</p>
<p>一直反复问自己 “<strong>为什么懂得那么多道理，却依然过不好一生</strong>”。最后发现，其实我们在当下知道这个道理，和面临选择时依然想得起这个道理是不一样的。其中最关键的就是自己价值观出了问题，什么是价值观？ 笑来老师给我们举了个例子：</p>
<blockquote>
<p>什么是价值观来着？ 价值观就是思考“什么更重要？” 和 “什么最重要？” 然后盯着重要的， 而不是那些不重要的….就这么简单。</p>
</blockquote>
<p>现在想想还不如在你财力有限的情况下把那些钱的50% 打赏给我们最认可的人， 说不定会得到意想不到的收获。</p>
<p>这里推荐几个对我个人影响比较大的公众号和资源，不一定适合每个人，各取所需就好了， 不要太认真。</p>
<h3 id="学习学习再学习"><a href="#学习学习再学习" class="headerlink" title="学习学习再学习"></a>学习学习再学习</h3><p>作者李笑来， 如果不知道他是谁的，请自行搜索。不过现在更新频率低了，可能和已经找到变现途径有关。</p>
<p>我也付费订阅他的「通向财富自由之路」和 「天天用英语」专栏，特别是「通向财富自由之路」专栏每周一个主题，然后展开来讨论。如果打磨自己的认知和成长系统，订阅这个就够了。</p>
<h3 id="caoz的梦呓"><a href="#caoz的梦呓" class="headerlink" title="caoz的梦呓"></a>caoz的梦呓</h3><p>作者曹政，老牌互联网从业者，头衔比较多，现在从事天使投资，是个数据控+淘宝控，对流量运营有独到的见解。干货比较多，也敢于发声 。为人谦虚易于沟通，很值得我们学习的前辈。</p>
<h3 id="亦无所知"><a href="#亦无所知" class="headerlink" title="亦无所知"></a>亦无所知</h3><p>作者亦仁，前阿里运营，现在创业。这里我主要说说他的小密圈 「<strong>生财有术</strong>」，一个谈钱不伤感情的圈子，里面有很多大牛， 也会分享一些他们认为可以赚钱的项目。绝对圈内新贵，实操和分享派达人。</p>
<p>五天圈内用户数在只有500人左右情况下就赚到28万左右，小密圈的收费策略就是每增加100名用户，涨价100元，我入坑时765，我们来看看封顶会是多少呢？</p>
<h3 id="水库论坛"><a href="#水库论坛" class="headerlink" title="水库论坛"></a>水库论坛</h3><p>所有关于靠房子买卖的知识，他的公众号里基本都能找到答案。</p>
<p>他的理论和实操体系被无数靠房子赚钱的人奉为圭臬。他提出很多术语圈外的人看都看不懂：</p>
<blockquote>
<p>远郊CEO盘、老破小、凤变冰、A8-A10（数字代表财富的位数，A8就是千万级）进阶理论、构建以房贷为主的资产组合包、信用卡空当接龙还贷款、abc单、笋盘、2N等行话。</p>
</blockquote>
<p>最为难能可贵的是，他讲的东西很系统，很雄辩，并且他依然活跃着在点评区。<br>对房子感兴趣的朋友看这一个公众号就够了。</p>
<p>房子这个话题很沉重也实际，不要说没有首付就盼着房价跌，上了车的人都在盼涨。</p>
<p>我不是鼓励大家炒房，但是这个问题必须正面面对。从哪里入手？不妨系统看一下这个公号。我知道「水库论坛」比较晚， 现在看我买的房的经历就是瞎胡闹。</p>
<h3 id="JasonThink"><a href="#JasonThink" class="headerlink" title="JasonThink"></a>JasonThink</h3><p>为自己打一个广告，程序员一枚， 目标是能够多去远方看看。目前在寻求发展途径，其中也进行取舍，欢迎大家来和我交流。</p>
<hr>
<p>PS：<br>由于清明节放假在郑州办点事情，这篇文章是在去的车上整理完成的，有点仓促。顺便见多年不见的那个人，心里很复杂，祝我好运吧。</p>
<p>祝大家节日快乐！</p>
]]></content>
    
    <summary type="html">
    
      这么多社群，你加的过来吗？
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>七年后你还是你吗</title>
    <link href="http://hujiandong.com/2017/03/27/seven-year-later/"/>
    <id>http://hujiandong.com/2017/03/27/seven-year-later/</id>
    <published>2017-03-27T00:30:16.000Z</published>
    <updated>2017-03-27T01:34:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>李笑来老师说七年就是一辈子，我不知道他为什么这么说，可能七年时间足够能改变一个人一辈子的命运。</p>
<p>七年前的我还没大学毕业，坐着学校门口的旁边小店里，吃着水煮鱼喝着啤酒，同学们之间相互吹着牛皮。记得刚毕业的时候给自己定一个大目标和几个小目标— 给自己五年时间，寻找自己，自己能不能在这个行业站住脚。</p>
<p>五年时间很快过去， 获得答案也是肯定的，基本上按照当初设定目标来的，二十四岁结婚、二十五岁置业、二十七岁生子等，其实目的只有一个，在三十而立之年时能腾出更多精力做更有意义的事情。</p>
<p>可能有些人和我的观点不一样， 他认为出名要趁早，结婚生子可以往后排。如果你背景好或者天赋异禀或者才能出众再或者可以靠脸吃饭，那么什么时候都不晚。我是上述条件都没有， 你告诉我等等吧，等来的只会是失望和更高的房价。而立之年后还为结婚生子浪费精力， 个人认为不值。当然前提是你要有个靠谱的女（男）朋友，这个需要你个人判断，判断标准就是要为我们做的事情负责，这点很重要，特别当你是个男人的时候。</p>
<p>当然这中间也暴露一些问题， 走了一些弯路。13年底由于没有找到方向，又捡起大一玩的 DOTA ， 下班除了游戏就是 NBA，这样的状态一直持续到 14年年中，因为无意间在播客的上听了一堂创业课， 现在也记不得是谁讲的， 那时候听到最多的话就是『<strong>在风口上，猪都能飞起来</strong>』。</p>
<p>当时被这种情绪点燃， 整天就涮投资圈， 今天 XX 融了多少钱明天又一个 XX   又融多少。然后就看他们的公司背景、老板背景和项目背景， 想想是不是能够复制。整天把刚看到的东西，不带思考的转诉给他人，博得他人的认同感。</p>
<p>现在只想对那时的自己说:</p>
<blockquote>
<p>嗨， 你真是个大傻叉，你以为你看到就是自己的吗</p>
</blockquote>
<p>那时说的多，做的少，就是个“嘴炮”。也没有把注意放在自己成长上，就像笑来老师说的：</p>
<blockquote>
<p>很多人总在说“懂得那么多道理，却依然过不好一生”。<br>其实，你在当下知道这个道理，和面临选择时依然想得起这个道理是不一样的。</p>
</blockquote>
<p>现在又进入以罗振宇为首的内容卖家宣扬的知识学习， 已经恐慌了一大批人，很多人像无头苍蝇一样到处付费，到头来却一无所获。我也是其中一员。这其中有一大部分原因：</p>
<ul>
<li>没有找到优质的资源对接，网上的垃圾信息和粗制滥造的付费内容太多。</li>
<li>没有一个优质的推荐平台，要不然那么多付费内容，新手进入的时候怎么选择。</li>
</ul>
<p><img src="https://cdn.pixabay.com/photo/2017/03/01/10/03/businessman-2108029__480.jpg" alt=""></p>
<p>其实看完牛人的东西，看到刷新甚至颠覆三观的文字，我们要做的不是直接将这些思想刻进脑子，而是去用自己的话去梳理一遍， 梳理其中的逻辑，用文字记录下来， 不断打磨，让我们真正在选择的时候用的上。</p>
<p>不断问自己，自己在阅读时有哪些「认知习惯」是需要注意的？哪些需要改掉的阅读“原罪”，我们要做的第一件事不是去积累多少知识，开阔多广的视野，而是要把这个与生俱来的缺陷克服，即使不能时时刻刻都克服，也要有意识的去抵消其影响。</p>
<p>同样我们的另一个陷阱是无目的的学习，没有一个战略上的目标，任何战术上的胜利都会最终被时间耗散成一团散沙。安兰德说过:</p>
<blockquote>
<p>当你说我爱你的时候，你要明白你有我吗？只有有我的人才有权利说爱别人。</p>
</blockquote>
<p>这句话的意思是如果爱只是被本能驱使，你不可能是“我”，你是随便一个人。如果你说你爱知识，爱学习，却不清楚自己学习的长远目标，那么不是你在学习，是你在表演学习这种行为艺术给自己看，给朋友圈看，就是我们通常说的“<strong>假学习</strong>”， 寻求自嗨。</p>
<p>反思发现自己以前做那些事情， 其实就是「自嗨」行为， 以后也要调整， 考虑「他嗨」，当然这件事件，需要极强的能力，我会用接下来的七年时间不断打磨。 </p>
<p>以前一直有一个误区，做出好的产品，写出感动自己的代码，才是王道。其实根据个人实际情况，对自己很难。为什么不从用户需求做起，深挖周边资源，真正解决部分用户需求。这也是下一步我主要要学要做的事情。</p>
<p>七年后我37岁，也将到达不惑之年，活着或生活以及我将变成什么样？更好的自己还是更坏的自己？是否还在北京？</p>
<p>这些其实都不知道。唯独能做的就是用心写作，用心做事，做对别人有用的事，从而实现个人价值。但是有一点是肯定的就是回归家庭， 多陪陪家人。那时小硕硕九岁，大概上小学三、四年级，多带他去看看远方，看看世界，他的人生才刚刚开始，希望能用我的行动去影响他。</p>
<p>把更多的注意力放在做事上面，尽快摆脱现在出售时间这种不划算的事情上面， 让自己有更多话语权。</p>
<p>七年后你还是你吗？ 希望自己还能保持一颗初心，一颗不断学习的初心，真正实现做自己，让身边的家人和朋友更好。<strong>未来不可期，与君共勉！</strong></p>
]]></content>
    
    <summary type="html">
    
      李笑来老师说七年就是一辈子，我不知道他为什么这么说，可能七年时间足够能改变一个人一辈子的命运
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Android正确的Log打印姿势—中级篇</title>
    <link href="http://hujiandong.com/2017/03/24/android-log-used-debug/"/>
    <id>http://hujiandong.com/2017/03/24/android-log-used-debug/</id>
    <published>2017-03-24T00:30:16.000Z</published>
    <updated>2017-03-24T01:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过<a href="http://hujiandong.com/2016/11/07/android-log-used/"><strong>Android Log打印的正确姿势</strong></a>， 今天我们来谈谈怎么控制 Log 的输出?</p>
<p>第一种：自定义常量， 例如将配置文件放到 asset 下，里面配置是否需要打开 log，Debug 设为 true，Release 设为 false。</p>
<p>第二种：通过 Log.isLogable 去判断，每次需要手动开启。</p>
<p>第三种：Gradle 中 BuildConfig.DEBUG 判断是否是 Debug 模式， 从而做到一些在 Debug 模式下开启， 这样好处是不用再发布前去主动修改。</p>
<p>第一种类似最原始的方式，每次生产环境和开发环境下切换，容易出错，另外在给其他模块提供服务时也不会通用。人类是个不靠谱的东西，机器才是我们目前为止更应该相信的。例如我们经常说的：</p>
<blockquote>
<p><strong>作为研发不要相信产品、作为测试不要相信研发、作为运维谁都不要相信、作为产品谁都不要相信…</strong></p>
</blockquote>
<p>今天我们就不讨论第一种模式，着重说说第二种和第三种情况， 并讨论他们的优缺点。</p>
<h2 id="第二种-Log-isLoagable"><a href="#第二种-Log-isLoagable" class="headerlink" title="第二种 Log.isLoagable"></a>第二种 Log.isLoagable</h2><p>直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtils</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL = Log.DEBUG;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDebug</span><span class="params">(String tag, <span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> level &gt;= LEVEL &amp;&amp; Log.isLaggable(tag, level);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String tag, <span class="keyword">int</span> level, String msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isDebug(level)) &#123;</div><div class="line">            Log.println(level, tag, msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String tag, String msg)</span> </span>&#123;</div><div class="line">        println(tag, Log.DEBUG, msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码主要作用，判断当前 level 是否大于 Log.DEBUG 并且判断 Log.isLoggable() 是否为 true，如果条件成立调用 println()。最后问题就回归到怎么通过改变 isLoggable() 状态呢？</p>
<p>最后我们发现可以通过 adb shell 进行设置，方法如下：</p>
<blockquote>
<p><code>adb shell setprop log.tag.MYTAG D</code></p>
</blockquote>
<h2 id="第三种-BuildConfig-DEBUG"><a href="#第三种-BuildConfig-DEBUG" class="headerlink" title="第三种 BuildConfig.DEBUG"></a>第三种 BuildConfig.DEBUG</h2><p>我们直到 Debug 模式下 BuildConfig.DEBUG 会始终为 true。我们将上面的代码改造一下， 只需要修改 isDubug(）函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDebug</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">    retrun level &gt;= LEVEL &amp;&amp; BuildConfig.DEBUG;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际开发中我们一般将 LogUtils 放到 Utils Module 中， 而不是放到 app Module 里， 我们会发现 BuildConfig.DEBUG 永远为 false。 Why？ 难道遇到假的系统吗？</p>
<h3 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h3><p>原来 BUildConfig.java 是编译时自动生成的， 每个 Module 都会自己生成一份。所以如果你的应用拥有多个 Module 就会有多个 BuildConfig.java, 而上面的 LogUtils 被放到 Utils, 而 app Module 又依赖 Utils，编译时被依赖的 Utils Module 默认会提供 Release 版给其他 Module 或 工程，这就导致该 BuildConfig.DEBUG 会始终为 false。那么如何解决了？</p>
<h3 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h3><p>为了解决上面的问题，我们反编译 Debug 包和 Release 包发现，在AndroidManifest.xml 中 application 节点的 android:debuggable 值是不同的。Debug 版本值为 true，Release 版本值为 false。所以我们可以通过 ApplicationInfo 的这个属性来判断是否是 Debug 版本，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppUtils</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean isDebug = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDebug</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> isDebug == <span class="keyword">null</span> ? <span class="keyword">false</span> : isDebug;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugMode</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isDebug == <span class="keyword">null</span>) &#123;</div><div class="line">            isDebug = context.getApplicationInfo() != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                    (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在自己的 Application 内调用：</p>
<blockquote>
<p><code>AppUtils.debugMode(getApplicationContext());</code></p>
</blockquote>
<p>修改 LogUtils 的 isDubug() :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDebug</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> level &gt;= LEVEL &amp;&amp; AppUtils.isDebug();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了， 这样就解决上面的问题了。<br>注意：<br><strong>上面的解决方案，不能再 app Module 中主动设置 android:debuggable,  否则无论 Debug 还是 Release 版会始终是设置的值。</strong></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>优点：</p>
<ul>
<li>不用手动修改， 从而减少出错的概率</li>
<li>灵活，能在 Release 也能动态控制输出结果</li>
</ul>
<p>缺点：</p>
<ul>
<li>当我们重启手机以后上面的设置就不会起作用了，每次重启需要重新设置</li>
</ul>
<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>优点：</p>
<ul>
<li>不用手动修改， 从而减少出错的概率<br>缺点：</li>
<li>不够灵活，不能在 Release 也能动态控制输出结果</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上面的方案可以根据开发中的使用场景来确定，没有最好，只有更好。</p>
]]></content>
    
    <summary type="html">
    
      Android正确的Log打印姿势—中级篇
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>你了解泛型通配符与上下界吗？</title>
    <link href="http://hujiandong.com/2017/03/11/java_generices_bounded/"/>
    <id>http://hujiandong.com/2017/03/11/java_generices_bounded/</id>
    <published>2017-03-11T02:30:16.000Z</published>
    <updated>2017-03-24T01:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你了解泛型通配符与上下界吗？"><a href="#你了解泛型通配符与上下界吗？" class="headerlink" title="你了解泛型通配符与上下界吗？"></a>你了解泛型通配符与上下界吗？</h1><p>在进入主题之前， 我们先简单说一下 Java 的泛型（generics）。它是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。</p>
<p>今天我们主要说如下类型：</p>
<ul>
<li>泛型的背景</li>
<li>通配符以及上下界</li>
<li>泛型及通配符的使用场景</li>
</ul>
<h2 id="为什么使用泛型及背后的问题？"><a href="#为什么使用泛型及背后的问题？" class="headerlink" title="为什么使用泛型及背后的问题？"></a>为什么使用泛型及背后的问题？</h2><p>我们来看一下官方的说法：</p>
<blockquote>
<ul>
<li>Stronger type checks at compile time. A Java compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find.</li>
<li>Elimination of casts.</li>
<li>Enabling programmers to implement generic algorithms. By using generics, programmers can implement generic algorithms that work on collections of different types, can be customized, and are type safe and easier to read.</li>
</ul>
</blockquote>
<p>是的， 终止目的就是想把程序员解放出来，关注他们更应该关注的事情上面去。当我第一次学习 Java 的泛型时，总感觉它类似于 C++ 中的模板。但随着慢慢的深入了解发现它们之间有本质的区别。</p>
<p>Java 中的泛型基本上完全在编译器中实现，由编译器执行类型检查和类型推断，然后生成普通的非泛型的字节码。这种实现技术称为 擦除（erasure）（编译器使用泛型类型信息保证类型安全，然后在生成字节码之前将其清除），这项技术有一些奇怪，并且有时会带来一些令人迷惑的后果。</p>
<p>对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面来说，上面已经说了，主要是在编译时刻就能发现很多明显的错误。而从不好的地方来说，主要是为了保证与旧有版本的兼容性，Java 泛型的实现上存在着一些不够优雅的地方。</p>
<p>下面我们来看一下，泛型类型的一个定义，后面我们要在这个的基础上进行改造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">// T stands for "Type"</span></div><div class="line">	<span class="keyword">private</span> T t;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T t)</span> ￼ ￼</span>&#123; <span class="keyword">this</span>.t = t;￼ &#125;￼</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来下面我们来聊聊 Java 泛型的通配符， 记得刚开始看到通配符（？）时我是惊喜的，因为既然有通配符那么就可以这样定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSometing</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</div><div class="line">	list.add(<span class="number">1</span>); <span class="comment">//illegal</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可是我们如上写法，总是出现编译错误，然后从惊喜变成惊吓，心想有什么卵用了。最后发现原因是在于通配符的表示的类型是未知的。那在这种情况下，我们可以使用上下界来限制未知类型的范围。好吧，写了那么多， 终于等到今天的主角登场了，容易吗？</p>
<p>还记得我们上面定义的 Box 吗， 现在我们再定义 Fruit 类以及它的子类 Orange 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123; &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们想它里面能装水果，那么我可以这么写。<br><code>Box&lt;Fruit&gt; box = new Box&lt;Orange&gt;(new Orange()) //illegal</code></p>
<p>不幸的是编译器会报错，这就尴尬了，why？why？ why？实际上，编译器认为的容器之间没有继承关系。所以我们不能这样做。</p>
<p>为了解决这样的问题， 大神们想出来了&lt;? extens T&gt; 和 &lt;? super T&gt; 的办法，来让它们之间发生关系。</p>
<h2 id="上界通配符（Upper-Bounded-Wildcards）"><a href="#上界通配符（Upper-Bounded-Wildcards）" class="headerlink" title="上界通配符（Upper Bounded Wildcards）"></a>上界通配符（Upper Bounded Wildcards）</h2><p>现在我们把上面的 Box 定义改成：<br><code>Box&lt;? extends Fruit&gt;</code></p>
<p>这就是上界通配符， 这样 Box<fruit> 及它的子类如 Box<orange> 就可以赋值了。<br><code>Box&lt;? extends Fruit&gt; box = new Box&lt;Orange&gt;(new Orange)</code></orange></fruit></p>
<p>当我们扩展一下上面的类， 食物分成为水果和蔬菜类， 水果有苹果和橘子。<br>在上面的结构中， Box&lt;? extends Fruit&gt; 涵盖下面的蓝色的区域。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/upper.png" alt=""></p>
<h3 id="上界只能外围取，不能往里放"><a href="#上界只能外围取，不能往里放" class="headerlink" title="上界只能外围取，不能往里放"></a>上界只能外围取，不能往里放</h3><p>我们先看一下下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Box&lt;? extends Fruit&gt; box = <span class="keyword">new</span> Box&lt;Orange&gt;(<span class="keyword">new</span> Orange);</div><div class="line"></div><div class="line"><span class="comment">//不能存入任何元素</span></div><div class="line">box.set(<span class="keyword">new</span> Fruit);  <span class="comment">//illegal</span></div><div class="line">box.set(<span class="keyword">new</span> Orange);<span class="comment">//illegal</span></div><div class="line"></div><div class="line"><span class="comment">//取出来的东西只能存放在Fruit或它的基类里</span></div><div class="line">Fruit fruit = box.get();</div><div class="line">Object fruit1 = box.get();</div><div class="line">Orange fruit2 = box.get(); <span class="comment">//illegal</span></div></pre></td></tr></table></figure></p>
<p>上面的注释已经很清楚了， 往 Box 里放东西的 set() 方法失效， 但是 get() 方法有效。</p>
<p>原因是 Java 编译器只知道容器内是 Fruit 或者它的派生类， 但是不知道是什么类型。可能是 Fruit、 可能是 Orange、可能是Apple？当编译器在看到 box 用 Box<orange> 赋值后， 它就把容器里表上占位符 “AAA” 而不是 “水果”等，当在插入时编译器不能匹配到这个占位符，所有就会出错。</orange></p>
<h2 id="下界通配符（Lower-Bounded-Wildcards）"><a href="#下界通配符（Lower-Bounded-Wildcards）" class="headerlink" title="下界通配符（Lower Bounded Wildcards）"></a>下界通配符（Lower Bounded Wildcards）</h2><p>和上界相对的就是下界 ，语法表示为：<br><code>&lt;? super T&gt;</code></p>
<p>表达的相反的概率：一个能放水果及一切水果基类的 Box。 对应上界的那种图， 下图 Box&lt;? super Fruit&gt; 覆盖黄色区域。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/lower.png" alt=""></p>
<h3 id="下界不影响往里存，但往外取只能放在Object-对象里"><a href="#下界不影响往里存，但往外取只能放在Object-对象里" class="headerlink" title="下界不影响往里存，但往外取只能放在Object 对象里"></a>下界不影响往里存，但往外取只能放在Object 对象里</h3><p>同上界的规则相反，<strong>下界不影响往里存，但往外取只能放在Object 对象里</strong>。</p>
<p>因为下界规定元素的最小的粒度，实际上是容器的元素的类型控制。所以放比 Fruit 粒度小的如 Orange、Apple 都行， 但往外取时， 只有所有类的基类Object对象才能装下。但是这样的话，元素的类型信息就全部消失了。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在使用泛型的时候可以遵循一些基本的原则，从而避免一些常见的问题。</p>
<ul>
<li>在代码中避免泛型类和原始类型的混用。比如 List<string> 和 List 不应该共同使用。这样会产生一些编译器警告和潜在的运行时异常。当需要利用 JDK 5 之前开发的遗留代码，而不得不这么做时，也尽可能的隔离相关的代码。</string></li>
<li>在使用带通配符的泛型类的时候，需要明确通配符所代表的一组类型的概念。由于具体的类型是未知的，很多操作是不允许的。</li>
<li>泛型类最好不要同数组一块使用。你只能创建 new List&lt;?&gt;[10] 这样的数组，无法创建 new List<string>[10] 这样的。这限制了数组的使用能力，而且会带来很多费解的问题。因此，当需要类似数组的功能时候，使用集合类即可。</string></li>
<li>不要忽视编译器给出的警告信息。</li>
</ul>
<h3 id="PECS-原则"><a href="#PECS-原则" class="headerlink" title="PECS 原则"></a>PECS 原则</h3><p>如果要从集合中读取类型T的数据， 并且不能写入，可以使用 上界通配符（&lt;？extends&gt;）—Producer Extends。</p>
<p>如果要从集合中写入类型T 的数据， 并且不需要读取，可以使用下界通配符（&lt;? super&gt;）—Consumer Super。</p>
<p>如果既要存又要取， 那么就不要使用任何通配符。</p>
]]></content>
    
    <summary type="html">
    
      你了解泛型通配符与上下界吗？
    
    </summary>
    
      <category term="java" scheme="http://hujiandong.com/categories/java/"/>
    
    
      <category term="java" scheme="http://hujiandong.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>编写可读代码的艺术</title>
    <link href="http://hujiandong.com/2017/02/22/readable-code/"/>
    <id>http://hujiandong.com/2017/02/22/readable-code/</id>
    <published>2017-02-22T07:30:16.000Z</published>
    <updated>2017-02-27T10:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚毕业的时候读过 Bob 大叔的《Clean Code》， 那时候只是被动接受，没有进行更有效的思考，现在也忘记的差不多了。记得在进行公司培训时一部分内容就是代码规范和公司常用的推荐写法，当时也不知道为什么这样子做， 老大告诉我们，<strong>这就是团队做出的决定，喜欢不喜欢照做就是。</strong></p>
<p>开发中我们不可避免的要阅读别人代码，一般会出现两种场景：</p>
<ul>
<li>哇，这块代码写的太棒了， 结构简单、逻辑清晰。</li>
<li>艹，这代码写的一坨坨的，也不知道他在表达什么，写的人是不是当时脑袋被门挤压后写下的代码。</li>
</ul>
<p>我们当然不想成为第二种，那什么样的代码符合可读性的特质？</p>
<blockquote>
<p><strong>可读性 == 可测试 == 代码质量 == 代码优雅 </strong><br>是的， 它们自己是等价的</p>
</blockquote>
<p>这本书译版不过170多页很薄，通过漫画的形式展示每个主题，幽默合理，直指问题要害，阅读起来很有趣，有图有真相。主要分四大部分：</p>
<ul>
<li>表面层次的改进</li>
<li>简化循环和逻辑</li>
<li>重新组织代码</li>
<li>测试与可维护</li>
</ul>
<h2 id="表面层次的改进"><a href="#表面层次的改进" class="headerlink" title="表面层次的改进"></a>表面层次的改进</h2><p><strong>谈到如何命名？</strong></p>
<ul>
<li>避免使用专业词汇。</li>
<li>避免空泛的名字。</li>
<li>为作用域大的名字采用更长的名字</li>
</ul>
<p><strong>如何添加注释？</strong></p>
<ul>
<li>不要为了写注释而写注释</li>
<li>不要给不好的名字加注释—应该改进命名和重构</li>
<li>为代码中的瑕疵写注释：这里单独提一下 HACK（以前没有注意过）—-对一个问题不得采取的粗糙解决方案</li>
</ul>
<h2 id="简化循环和逻辑"><a href="#简化循环和逻辑" class="headerlink" title="简化循环和逻辑"></a>简化循环和逻辑</h2><p>文中提到条件语句中参数的顺序、告诉我们可以通过重新排列 if/else 语句中的语句块。通常来讲，先处理正确的/简单的/有趣的情况。有时候这些准则会冲突，但是当不冲突时， 这是要遵循的经验法则。</p>
<p>通常来讲提早返回可以减少嵌套并让代码整洁。</p>
<p>一个简单的技术是引入「解释变量」来代表较长的子表达。这种方式有三个好处：</p>
<ul>
<li>它把巨大的表达拆成小段</li>
<li>它通过用简单的名字描述子表达式来让代码文档化</li>
<li>它帮助读者识别代码中的主要概率</li>
</ul>
<h2 id="重新组织代码"><a href="#重新组织代码" class="headerlink" title="重新组织代码"></a>重新组织代码</h2><p>文中提到「抽取不相关的子问题」和 Martin Fowler 在中《重构》描述的重构的「抽取方法」相似，而他写的更为详细， 感兴趣的可以去读读。</p>
<p>如何可以少写代码</p>
<ul>
<li>从项目中消除不必要的功能，不要过度设计。</li>
<li>重新考虑需求，解决版本最简单的问题，只有能完成工作就行。</li>
<li>经常性的通读标准库的整个 API，保持对它们的熟悉程度。</li>
</ul>
<h2 id="测试与可维护"><a href="#测试与可维护" class="headerlink" title="测试与可维护"></a>测试与可维护</h2><p>文中提到，在测试代码中，可读性也很重要。如果测试的代码可读性好，其结果是它们会变得很容易些， 因此大家会更多的测试。并且，如果你把真实代码设计的容易测试，代码整个设计会变得更好。</p>
<p>以下是如果改进测试的几个具体要点：</p>
<ul>
<li>每个测试的最高一层应该越简洁越好。最好每个测试的输入/输出可以用一行代码来描述。</li>
<li>如果测试失败了， 它所发出来的错误消息应该能让你容易跟踪并修正这个 bug。</li>
<li>使用最简单的并且能够完整的运用代码的测试输入。</li>
<li>给测试函数取一个完整的描述性的名字，以使每个测试所测到的东西很明确。</li>
</ul>
<p>作者也提到测试走的太远的情况：</p>
<ul>
<li>牺牲真实代码的可读性，只是为了使用测试</li>
<li>着迷于100%的 测试覆盖率</li>
<li>让测试成为产品开发的阻碍</li>
</ul>
<p><strong>思维导图</strong><br>![][<a href="http://sonicwu.com/statics/images/the-art-of-readable-code-m.jpg" target="_blank" rel="external">http://sonicwu.com/statics/images/the-art-of-readable-code-m.jpg</a>])<br>就想本书的名字一样，艺术这个东西本来就是每个人鉴别的方式不一样，但是称得上艺术的东西， 一定符合艺术评断标准的。</p>
<p>编码规范这种事情，本来都是有主观有客观的。</p>
<p>像字节编码、换行、命名之类的事情就是主观的，在公司团队开发中就应该硬性统一，以便协作流畅。</p>
<p>最近阿里巴巴发布一个Java 编码规范—《阿里巴巴Java开发手册（正式版）》，设计编码的方方面面，有兴趣的同学可以看一下。 </p>
<p>我也大致撸了一遍， 文档本身没有太大问题，不过，在网页、Github 高度发达的今天，为什么阿里没有选择将它放在网页上，而是用 PDF 的形式发布？为什么不做成类似：</p>
<blockquote>
<p>Google Java Style Guide<br>[<a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="external">https://google.github.io/styleguide/javaguide.html</a>]</p>
</blockquote>
<p>有人说，编码规范这种东西就是体现「码农」和「工程师」本质区别的地方。</p>
<p>知乎上有个相关的问题「如何写出优雅的代码？」，我很赞同下面的回答：</p>
<blockquote>
<p>多写，写的少的说啥都是空话。<br>讲语法和应用的书一般培养不出所谓的「优雅」，不是作者水平不高的问题，是这样的书就应该务实，不扯淡。<br>将编程美感的书，一般来说，如果写代码不够多，只是读书，毫无收益，只会害自己。所以还是要写。</p>
</blockquote>
<p>其实什么样的代码是优雅的， 可读性好，可能也不过是自以为罢了。掌握一些基本的技巧就好了， 如果大家都严格遵循那些条条框框， 也不会有那么多不同语言和框架了。</p>
<p>最后所谓的代码优雅不过是程序员们用来自慰的工具罢了。爽于不爽只有自己知道。</p>
]]></content>
    
    <summary type="html">
    
      编写可读代码的艺术
    
    </summary>
    
      <category term="读书" scheme="http://hujiandong.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="http://hujiandong.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>写给我心中的她</title>
    <link href="http://hujiandong.com/2017/02/14/happy-valentines-2017/"/>
    <id>http://hujiandong.com/2017/02/14/happy-valentines-2017/</id>
    <published>2017-02-14T07:30:16.000Z</published>
    <updated>2017-02-15T03:38:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想写一篇关于她的文章， 以前认为这是我们之间的事件， 不适合分享。反过来想，除了岁月我们还有诗和远方。</p>
<p>今天是情人节， 往年我都会在家附近买一支玫瑰送给她。而今年我早早的几天前我已经在网上预订定了一束，送到她的公司里去了。</p>
<p>我和她认识的时候， 我大二她大三，一个朋友介绍下我们在中秋节的晚上，我们见了面也吃了饭。当然我也知道， 像长成我这样， 肯定没几个女孩会看上我的。见面的结果可想而知—两个字「没戏」。不过爸妈从小教导我，遇到事件不要怕，要勇敢面对。</p>
<p>然后我就制定一套泡妞计划，其实也不是计划，一没钱、二没人。幸亏这时候「脸皮」同学出现了， 他说帮我在前面打前阵。就这样屡战屡败、屡败屡战情况， 终于在一个月后， 当然是我胜利了，不然我就再这里不写了。</p>
<p>有的童鞋会问， 他也给他喜欢的人打电话， 也发信息， 人家根本不 care， 咋办？给你们说一个朋友的真实例子，他当年追一个女孩的时候， 女孩不搭理他， 他就在她宿舍下面给他电话发信息说，他就在她们宿舍下面等她，如果不来，他每天都来， 直到她下来为止 。大约一周左右，那个女孩也就下来了。</p>
<p>我当然不是鼓励大家按照上面的方法去做， 只是想给我朋友说， 下次再遇到这样的事情， 请带上被子， 不然感冒了， 就没然后了。</p>
<p>像大部分大学情侣一样，我们就这样无忧无虑的交往着，因为我们不是一个学校， 除了周末在一块，平时也很少见面。当然我就有大部分时间，做我自己喜欢的事情， 打篮球、喝酒等等。 </p>
<p>因为她们老家那边，有订婚的说法（后来知道这是为了告诉别人， 我们女儿已经找好， 都不要上门提亲了）， 我大三暑假的时候双方完成订婚，其实也很简单，一块吃了顿饭，买了一个戒指，给了1万1千礼金（那是2010年）。</p>
<p>快毕业我就来北京了，以前我再xxx提到，我的第一台笔记本电脑和在北京培训的钱有一部分是她友情赞助的。 找到工作以后， 过完年她辞职给我一块来北京了， 最开始我们租的房子住在回龙观东大街那边，八九平米左右的房间， 每天挤公交和地铁上班。她也很少买衣服和化妆品，夏天的衣服一般不会超过150。</p>
<p>虽然那时候没钱， 不过也没感觉很苦（至少我是这样认为的， 因为没有和她两个这个话题，也不知道她是不是和我的观点一样）。</p>
<p>因为我们也谈了四五年时间，双方父母也催着我们结婚。 我们当时订在同年十一举办婚礼， 原本想家里都准备好了，我们只是回去就可以了。哪只离结婚还有大概二三个月时间， 家里有点变动，希望我们旅游结婚， 不要回家办婚礼了， 过年回来以后双方再一块吃个饭就行了。</p>
<p>由于我在中间没处理好， 被她误解为，她结婚什么也没找你父母要，你父母结婚连回家都不让回，是不是瞧不起她？当时我也有点生父母的气，再给我打电话说让我们回去，我也赌气说不回去办婚礼了， 十一我们去青岛玩了一周， 就这样我们算结婚了。直到现在我的一些同学还以为我们回家办的婚礼了，因为最开始的时候说的是回家办。</p>
<p>现在回想起来只能说当时 「too young too die」， 为什么赌气呢？以前要是吵架，她就会说， 你家人结婚时怎么对我的？每次被问到， 太多的解释都是演示。 </p>
<p>现在每被问到，如果结婚办婚礼还是旅游结婚时？我会说还是办场婚礼吧，谁心里苦谁知道，反正我挺苦的。 </p>
<p>可能为了缓和结婚对她的伤害，还有就是需要同年12月左右的时候，我们开始看房子， 其实当时手里就是结婚家里给了一点钱， 大概几万块吧。记得当时北京的均价在一万七八左右吧，西边和南北还会更便宜一些， 由于当时限购政策的原因，看中一套房子没弄成事。然后又去了燕郊和固安看了看，可能去的时候太堵的原因， 当时也主要考虑自住，最终放弃那两个地方。  </p>
<p>最后我把目标放到了我们上学的地方—郑州，毕竟那里有我们两个人的回忆，打了几个电话， 大致确定我们能承受的范围，就让我同学去那里交了定金选了房，事后才知道户型是置业帮忙选的。</p>
<p>其实这个价格当时已经超出我们预算了， 我当时其实想放弃的，想等等再买的。 记得那时还在上班，给她打电话时她说没事剩下的她来想办法。要不是她的这句话我也不会买，当时那套房子写的是她的名字。</p>
<p>怀孕的时候由于小孩早产， 她也遭了很多罪， 不管身体还是心理上都是。还好我们挺过来了，现在不真不想回想那段日子。</p>
<p>由于去年买房子时， 我们离了婚，但我们都知道那只是一个形式而已， 对我们没有实质性的改变。</p>
<p>你们也知道是睡了， 是的， 她就是我两任妻子，小孩的妈妈。</p>
<p>当我遇到事情的时候，她很少责备我， 总是鼓励我。说实话我为她做的事情也很少， 可能我不懂的爱情，也可能不懂的她要的爱。谢谢付出和不离不弃，我会尽里拼搏，直到感动自己的那一天到来为止。 </p>
<p>喜欢你是件很骄傲的事情，不是秘密。</p>
<p>在今天这个特殊的日子， 她并没有关注我的公众号，也不是特意给她看的。写这些只是回忆我们匆匆走过的时光。可能还有很多男男女女，如果你还单身， 请想办法脱单；如果你有伴侣，请相互珍惜，可能眼下的路并不好走， 只要认真坚持，未来一定是你们的。</p>
<p>最后，祝天下有情人终成眷属！</p>
]]></content>
    
    <summary type="html">
    
      写给我心中的她
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="随笔" scheme="http://hujiandong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>正确使用 Mac 的姿势</title>
    <link href="http://hujiandong.com/2017/01/18/mac-os-guide/"/>
    <id>http://hujiandong.com/2017/01/18/mac-os-guide/</id>
    <published>2017-01-18T02:33:33.000Z</published>
    <updated>2017-01-18T02:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>不像很多达人上大学或者更早时间就开始就使用 Mac， 我从15年12月份才开始用，到现在已经有一年多时间。Mac 现在成为我的御用电脑， 当然工作中我还没有完全切换到 Mac 上来，主要开发还在用 Ubuntu 进行开发。和 Ubuntu 一样它们都用相同的特点：</p>
<ul>
<li>没有右下角弹窗的打扰，没有流氓软件，能让你注意力更集中。</li>
<li>强大的终端操作。</li>
</ul>
<p>当然它更有别的操作系统不具备的—精美的UI设计和触摸板。如果你还没有， 那么你值得拥有，不过 New MacBook proc 的设计我不是很喜欢，可能我的审美还不到苹果设计师的 level。如果你为了打游戏就算了， 当然 Window 是你的唯一选择。 </p>
<p>下面我们说说 Mac OS X 下常用的软件及快捷键, 当然如果你想达到更正确的姿势，配着多屏和机械键盘就更佳。</p>
<h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><p><strong>Alfred</strong><br>Alfred 是一个非常强大的效率工具。快捷键呼出search框，输入你想找的任何东西得首字母或者前几位、缩写，然后上下方向键找到你的目标，回车就行。 还可以定在快捷键。<br><img src="https://user-gold-cdn.xitu.io/2016/11/29/44a17b11718e7fb3f5ccf45baa46dc18.jpg" alt=""><br><img src="https://user-gold-cdn.xitu.io/2016/11/29/2fb907101c8efd0ecf0d3b79049d91d5.png" alt=""></p>
<blockquote>
<p>Alfred3<br><a href="https://www.alfredapp.com/" target="_blank" rel="external">https://www.alfredapp.com/</a></p>
</blockquote>
<p><strong>iTerm</strong><br>专为 Mac OS 用户打造的命令行应用, 以前我还专门介绍过它， 有兴趣的可以看一下原文 <a href="http://hujiandong.com/2016/09/11/iterm2/">打造最强终端-iTerm 2</a>。</p>
<p><strong>Dash</strong><br>非常强大的文档查看器。<br>当你写东西的时候可能会同时用到好几个文档。Dash帮你管理你的文档。不用再切窗口了！<br>所有的文档都可以下载到本地，再不用忍受蜗牛速度去看国外的文档了， 我以前用来看 Android 文档。<br><img src="http://7xnilf.com1.z0.glb.clouddn.com/dash.png" alt=""></p>
<p><strong>Ulysses</strong><br>Ulysses 是我用过最好的写作软件，我在上面写出了近五万的文字。它的特点是：</p>
<ul>
<li>全平台支持</li>
<li>沉浸式写作</li>
<li>搜索功能</li>
</ul>
<p><img src="http://cdn.macrumors.com/article-new/2016/03/Ulysses-app-800x444.jpg" alt=""><br><strong> Manico</strong><br>在 OS X 下，我们想要启动或切换应用时，通常有以下三个选择：</p>
<ul>
<li>对于常用应用，将鼠标光标移动到屏幕下方打开 Dock 栏，从中选择需要启动或切换的应用打开；</li>
<li>对于已经启动的应用，按下「Command + Tab」呼出切换器，按 Tab 键或使用鼠标选择需要切换的应用打开；</li>
<li>对于既没有放在 Dock 栏也没有启动的应用，可以通过 Launchpad 或 Spotlight 搜索应用打开。</li>
</ul>
<p>对于习惯使用键盘的「效率党」而言，上面的几种方式并不够高效。有没有什么办法，可以整合这三种方式，并通过快捷键组合便能实现快速应用启动和切换呢？Manico 的出现为「效率党」提供了一个简单、易用、高效的快速启动和切换 App 的方式。</p>
<p>下图是我的快捷键配置：<br><img src="http://7xnilf.com1.z0.glb.clouddn.com/manico.png" alt=""><br><strong> Clyppan</strong><br>OS X 系统的剪切板默认只保存最后一次复制或是剪切的内容，所以你想粘贴前几次复制的内容时…不好意思，再切过去、选择、复制一遍。</p>
<p>我以前经常遇到这样的场景， 直到有一天看到大和童鞋使用 Clyppan 以后， 妈妈再也不用担心重复拷贝了。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/clippan.png" alt=""></p>
<p><strong>Hammerspoon</strong><br>有没有使用多屏的用户， 一般程序员和设计喜欢用多屏， 其实条件容许， 每个人都应该多配一个屏， 能很大提升我们的工作效率。</p>
<p>Hammerspoon 是一个多屏幕窗口管理软件，首先它是开源的，其次使用 Lua 脚本作为配置文件。</p>
<p>[<a href="http://www.hammerspoon.org/" target="_blank" rel="external">http://www.hammerspoon.org/</a>]</p>
<p><strong>awesome-mac</strong><br>这是一个 Github 项目，主要是收集非常好用的Mac应用程序、软件以及工具，主要面向开发者和设计师。</p>
<blockquote>
<p>[<a href="https://github.com/jaywcjlove/awesome-mac" target="_blank" rel="external">https://github.com/jaywcjlove/awesome-mac</a>]</p>
</blockquote>
<p>当然还有文本编辑器， 网友很多推荐 Atom 或 Sublime Text，不过我没有用过， 因为我用 emacs，选一个自己喜欢的就行。</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><blockquote>
<p>Command + C， Command + V，Command + A ：这几个大家都知道，不过尽量别用在代码拷贝上。<br>Command + Delete ： 删除当前行。选中文件的时候直接删除文件。<br>shift+方向键 ： 这个在选择文本的时候很有用，可以选择单个字符或者整行，多使用才能找到手感。<br>Command + Shift + 左右方向键：这个可以快速选择当前行，用的也很多<br>Control + A：跑到当前行的最前端，使用频次很高<br>Control + E：跑到当前行的最尾端，使用频次很高，还有 B、F 光标向前移动和向后移动<br>Command + TAB：切换应用，这是大部分人用的最多的方式，却不是最高效的方式，后面会介绍其他方式<br>Command +` : 切换同一应用的窗口，这个非常实用。比如打开多个 Android Studio 工程的情况下，快速的在不同项目之间切换。 Finder，Firefox等场景下都支持<br>Command + W：关闭当前窗口，后面会介绍其他方式，同样高效<br>Command + Q：关闭当前应用<br>Command + N：新建窗口，比如打开新的Finder窗口，配合cmd+w很实用<br>Command + I : 显示当前文件的信息，查看文件大小，图片宽高的时候有用<br>选中文件按空格预览：预览图片或者pdf文件时有用。配合方向键可以快速预览多张图片<br>Command + F：查找， Command + G 查找下一个； Command +Shift + G 向上查找<br>Control + Command + D：英文单词，完成取词翻译</p>
</blockquote>
<h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><blockquote>
<p>Command + T ： 这是基本全局打开新标签的标准键，会用的很多<br>Command + L ：光标移到地址框<br>Command + R ：刷新页面<br>Command + + ：大屏幕的时候很实用，放大页面，基本也是全局型的。 0是恢复默认大小<br>Command + W ： 关闭当前标签。不要和退出按错了<br>Command + Q ：退出当前软件，其他软件也都可以用<br>Command + D ：收藏当前页面<br>空格 ： 屏幕下滚一页<br>Command + Z ：Safari的恢复刚关闭标签就是熟悉的<br>Command + Shift + T：Chrome是和打开差不多的，Chrome这个功能更强大，就是可以按顺序恢复，但是Safari只能恢复最近的一个。这个功能我一直用，经常手抖关闭的一瞬间发现有用。</p>
</blockquote>
<p>当然如果你是 Vim 「中毒」党你也可以在 Chrome 上装上插件， 反正我是装了，不过很少用。</p>
<p>最后送自己和大家一些话， 当然做上面的事你首先有一台 Mac：</p>
<blockquote>
<p>If you’re interested, you come up with stories, excuses, reasons, and circumstances about why you can’t or why you won’t. If you’re committed, those go out the window. You just do whatever it takes.</p>
</blockquote>
<p><strong>PS</strong>：<br>又到了春运时间了， 你们需要回到父母身边吗？是不是还有人没有买到票的？今年要去我媳妇那边过年，正好今年公司年会在外地开， 开完以后就放假了，终于今年可以早点回去了。</p>
]]></content>
    
    <summary type="html">
    
      正确使用 Mac 的姿势
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>程序员最应该读的书</title>
    <link href="http://hujiandong.com/2017/01/18/programer-book/"/>
    <id>http://hujiandong.com/2017/01/18/programer-book/</id>
    <published>2017-01-18T02:26:15.000Z</published>
    <updated>2017-01-18T02:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司在推行程序员应该买什么书读的话题， 也买了一大堆书供大家阅读。以前也被别人问到类似问题—程序员都应该读什么书，你能推荐一下书单吗？最开始我是拒绝回答这总问题的。</p>
<p>第一，这种问题你可以用搜索引擎（Google）去解决，这样的问题有太多的回答了， 多找找你就会发现它们相同的地方了。还是那句话「<strong>不做伸手党</strong>」。</p>
<blockquote>
<p>因为一旦你开始不做伸手党，就会发现自己的分析能力瞬间提高了不少。就像我在 xx 写道 「分析并作出判断」才是我们我们成长的基石。</p>
</blockquote>
<p>第二，每个人的背景和行业都不一样， 你可能是 Java  工程师、C/C++ 工程师、GO 工程师、Python 工程师、数据分析师 或者全栈工程师，所以需求和成长路线就会不一样。你需要的书单就是不一样的， 没办法准确给你答案。</p>
<p>我在思考， 为什么自己会人为设置条框呢？分享就好了， 事真多，别人会去除糟粕的，就不劳烦你操心了。好吧，废话有点多， 我把我收集的关于书籍的资源整理出来，大概分为如下部分：</p>
<ul>
<li>可以下载书籍或者查找书籍的网站；</li>
<li>网友和朋友推荐的书籍；</li>
</ul>
<h2 id="可以下载书籍或者查找书籍的网站"><a href="#可以下载书籍或者查找书籍的网站" class="headerlink" title="可以下载书籍或者查找书籍的网站"></a>可以下载书籍或者查找书籍的网站</h2><ul>
<li>it-ebooks：下载IT电子书籍的网站  [<a href="http://www.it-ebooks.info/" target="_blank" rel="external">http://www.it-ebooks.info/</a>]</li>
<li>gitbook：gitbook上有很多书籍</li>
<li>经典编程书籍大全：100+ 经典技术书籍 [<a href="https://github.com/jobbole/awesome-programming-books" target="_blank" rel="external">https://github.com/jobbole/awesome-programming-books</a>]</li>
<li>oreilly Free Programming Ebooks：ORielly 的免费电子书 [<a href="http://www.oreilly.com/programming/free/" target="_blank" rel="external">http://www.oreilly.com/programming/free/</a>]</li>
<li>free-programming-books：免费的编程英文书籍索引 [<a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md" target="_blank" rel="external">https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md</a>]</li>
<li>free-programming-books-zh_CN：免费的编程中文书籍索引 [<a href="https://github.com/justjavac/free-programming-books-zh\_CN]_" target="_blank" rel="external">https://github.com/justjavac/free-programming-books-zh\_CN]_</a></li>
<li>awesome: awesome系列, 包括各种语言的， 大家到 Github 上搜索一下</li>
</ul>
<h2 id="网友和朋友推荐的书籍"><a href="#网友和朋友推荐的书籍" class="headerlink" title="网友和朋友推荐的书籍"></a>网友和朋友推荐的书籍</h2><p>张逸在 2013 写了一篇 『ThoughtWorks(中国)程序员读书雷达』，该读书雷达将书籍分为了如下四个维度： </p>
<ul>
<li>Coding Practice（编程实践） </li>
<li>Architecture &amp; Design（架构与设计） </li>
<li>Methodology（方法学） </li>
<li>Thought &amp; Leadership（思想与领导力）</li>
</ul>
<p><img src="http://agiledon.github.io/images/2013/04/reading-radar.jpg" alt=""></p>
<blockquote>
<p>ThoughtWorks(中国)程序员读书雷达（2013）:<br>[<a href="https://www.douban.com/doulist/2012097/" target="_blank" rel="external">https://www.douban.com/doulist/2012097/</a>]</p>
</blockquote>
<p>现在发现又有 2016 版的了</p>
<blockquote>
<p>ThoughtWorks读书雷达（2016）：<br>[<a href="https://www.douban.com/doulist/43272819/" target="_blank" rel="external">https://www.douban.com/doulist/43272819/</a>]</p>
</blockquote>
<p>看一下同事发给我的思维导图吧</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/%E8%AF%BB%E4%B9%A6%E9%9B%B7%E8%BE%BE.jpg" alt=""></p>
<p>以上就是我整理的关于书籍的一些资源，你也可以告诉我你的书单。</p>
<p>其实如上面提到的如果你有足够的分析能力， 知道如何阅读一本书，其实根本没有什么书单的。你什么书都去读好了， 不过要带上思考的脑子， 能快速辨别哪些书是需要精度的，哪些是不需要的。</p>
<p>IT 行业本身就是快速变化的行业， 你需要不断学习， 不断的读书。不只是你， 我也有好多书没读…</p>
]]></content>
    
    <summary type="html">
    
      程序员最应该读的书
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>我的 2016</title>
    <link href="http://hujiandong.com/2017/01/01/2016-person-summary/"/>
    <id>http://hujiandong.com/2017/01/01/2016-person-summary/</id>
    <published>2017-01-01T07:30:16.000Z</published>
    <updated>2017-01-02T02:30:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间2016走到了尽头。人们需要仪式感，所以无论情不情愿，总要和过去的自己诀别一番。尽管你我都知道，明年不会是一个更新的自己，只会是一个更老的自己。</p>
<p>只是当你在午夜检点行藏，追忆过去的365个日夜，回想年初制定的那些计划，有太多的事情值得仔细思量。</p>
<p>我最害怕这种命题作文， 因为以前一到这时候回答这个问题都逃不掉下面的一句话:</p>
<blockquote>
<p>对自己失望这件事上，我每年都没让自己失望过。</p>
</blockquote>
<p>不过今年开始往好的方向发展了， 主要发生在我身边的事件线：</p>
<ul>
<li>码字、阅读</li>
<li>置业</li>
<li>学英语</li>
</ul>
<p>提到<strong>码字</strong>是我今年做的最好的事情， 以前提到大大小小、技术和非技术写了100多篇，也有让我个人有那么一丝安慰为数不多的几篇；还有在这周微信公众号邀请「开通原创保护功能」。</p>
<p><strong>码字和阅读</strong>让我的心态变得更平和，我本身是个性子比较急的一个人， 不会控制自己的情绪，不过通过阅读、码字、思考等行动，慢慢变得不那么暴躁了。当然这个只是我个人的看法， 不知认识我的童鞋怎么看呢？还有本质的东西，不是你想控制就能控制的，现在做的远远不够。偶尔在遇到当时看来有挑战的问题时，也会骂娘。</p>
<p><strong>置业</strong>：在八月份的时候， 我选择置办房产，这次的动机很简单主要考虑以后小孩上学问题。为什么选择八月份呢？ 主要那段时间涨的太厉害，  原本计划明年要办的事情提前做了。</p>
<p>本来简单买个房子，不应该那么麻烦， 不巧的狗血的剧情在我身上发生了。在我签合同前，由于房价的持续飞涨，政府终于出台久违的限购政策， 政策导致我瞬间没有购房资格了。</p>
<p>在那之前我向开发商已经交过20%首付了， 无赖为了买这个房子只能选择离婚了。<br>所以现在的身份是个离异人士，老婆变成前妻了。有人说，「年底不买房， 等于一年白忙」，我只能呵呵，你鸭的，我们都是被逼的出来卖的， 唉， 谁信了。</p>
<p><strong>英语</strong>：说完房子我们再来说说英语， 英语这个问题， 一如既往的稳如狗， 从来没有让我失望过。预期目标没有完成， 以前的文章中我一说过问题出在哪里，最主要原因在投入的不够。不过我没有放弃， 现在已经培养中「<strong>物理习惯</strong>」了 ，下一步做就是花时间投入问题了。</p>
<p><strong>生活</strong>：这一年里， 说实话陪家人时间很少， 尤其是我们家的小布点， 有时候回去了， 给你打招呼你也不理我，我知道主要是陪你太少了，你都不认识我了。</p>
<p>我只是希望用自己行动，能影响你的成长。如果自己最终是个有足够积累的人， 起码你不用哀怨自己的命运， 就算不是「含着金钥匙出生」，管它是金是银、是铜是铁， 终归可能起码含着钥匙呢？</p>
<p>明年你又大一点了， 到时候可以多带你出去走走，我知道你很聪明（至少比我聪明），希望你以后你能找到自己的道路，这样我就能早点实现回家种地目标了。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/JlXYOcpo4ZLozCWlmqvqbr3Oy9B4EicL7vTFsXXz6JRfqnA6aHLjRE6VCzm910d7sCoEVgHTlosyhdtUKvpvxxQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>现在工作时候， 哪怕下雨，雾霾，我每天都从地铁口走到公司，不近不远1.5公里，哪怕现在可以选择单车了， 我还是选择走过去， 这段时间是我思考时间，好多实践都是这段时间决定的。</p>
<p>2016对个人成长方面的投资超过5000块，也在点滴改变自己，是的，我在做正确的事情。</p>
<p>从无忧无虑到知道人生不易，这个需要时间去打磨，就像李宗盛在「鬼迷心窍」中唱到：</p>
<blockquote>
<p>虽然岁月总是匆匆地催人老　虽然情爱总是让人烦恼<br>虽然未来如何不能知道　现在说再见会不会太早</p>
</blockquote>
<p>驰骋远方的人总有一天要踏上归途，讲完故事喝完酒也得回老家过年，再老的司机也会因为眷恋一个人的微笑，而燥不了。</p>
<p>平庸的日子一年又一年。我们总会在年初写很多 flag，而又在年末的时候亲手拔掉，开始一个新的轮回。而我，也许现在不美好，但黎明前总是最黑暗。</p>
<p>记得电影《后会无期》里有一句经典台词：</p>
<blockquote>
<p>我们听了很多的道理，可是却依旧过不好这一生。</p>
</blockquote>
<p>我们当然过不好这一生，因为我们只是听了这些道理，从来也没有行动过。也把它送给2017的自己和你们。</p>
]]></content>
    
    <summary type="html">
    
      我的 2016
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--单例模式</title>
    <link href="http://hujiandong.com/2016/12/21/design_pattern_singleton/"/>
    <id>http://hujiandong.com/2016/12/21/design_pattern_singleton/</id>
    <published>2016-12-21T07:30:16.000Z</published>
    <updated>2017-01-02T02:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们日常的工作中经常需要在应用程序中保持一个唯一的实例，如：IO处理，数据库操作等，由于这些对象都要占用重要的系统资源，所以我们必须限制这些实例的创建或始终使用一个公用的实例，这就是我们今天要介绍的——单例模式（Singleton）。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>单例模式，又称单件模式或者单子模式，指的是一个类只有一个实例，并且提供一个全局访问点。</p>
</blockquote>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在单例的类中设置一个 private 静态变量instance，instance 类型为当前类，用来持有单例唯一的实例。<br>将（无参数）构造器设置为 private，避免外部使用 new 构造多个实例。<br>提供一个 public 的静态方法，如 getInstance，用来返回该类的唯一实例 instance。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://rawgit.com/jasonim/design-patterns/develop/zh/creator-mode/singleton/image/singleton.png" alt=""></p>
<h2 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><p>由于使用场景不同，出现不同写法和模式，它们分别:</p>
<ul>
<li>懒汉式</li>
<li>恶汉式</li>
<li>双重校验锁</li>
<li>枚举</li>
<li>静态内部类</li>
</ul>
<p>由于枚举使用场景场景较少， 下面就不介绍，感兴趣的可以自行解决。</p>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式指的是单例的实例在类装载时进行创建。由于是在类装时候创建， 所以能够保证线程安全。如果单例类的构造方法中没有包含过多的操作处理，饿汉式其实是可以接受的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class SingleInstance &#123;</div><div class="line">  private final static SingleInstance instance = new SingleInstance();</div><div class="line"></div><div class="line">  public static SingleInstance getInstance() &#123;</div><div class="line">      return instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不足：</p>
<ul>
<li>如果构造方法中存在过多的处理，会导致加载这个类时比较慢，可能引起性能问题。</li>
<li>如果使用饿汉式的话，只进行了类的装载，并没有实质的调用，会造成资源的浪费。</li>
</ul>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式指的是单例实例在第一次使用时进行创建。这种情况下避免了上面饿汉式可能遇到的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SingleInstance &#123;</div><div class="line">  private static SingleInstance instance;</div><div class="line">  private SingleInstance() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static SingleInstance getInstance() &#123;</div><div class="line">      if (null == instance) &#123;</div><div class="line">          instance = new SingleInstance();</div><div class="line">      &#125;</div><div class="line">      return instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是如果上面的代码在多线程并发的情况下就会发生问题， 因为它们存在共同的「临界资源」 instance, 比如线程A进入 <code>null == instance</code> 这段代码块，而在A线程未创建完成实例时，这时线程B也进入了该代码块，必然会造成两个实例的产生。</p>
<p>所以如果多线程这里要考虑加锁同步。代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SingleInstance &#123;</div><div class="line">  private static SingleInstance instance;</div><div class="line">  private SingleInstance() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static synchronized SingleInstance getInstance() &#123;</div><div class="line">      if (null == instance) &#123;</div><div class="line">          instance = new SingleInstance();</div><div class="line">      &#125;</div><div class="line">      return instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用 synchronized 修饰 getInstance 方法后必然会导致性能下降，而且 getInstance 是一个被频繁调用的方法。虽然这种方法能解决问题，但是不推荐使用在多线程的情况下。所以伟大人类又想到了 「双重检查加锁」。</p>
<h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3><p>伟大人类想到首先进入该方法时进行 <code>null == sInstance</code> 检查，如果第一次检查通过，即没有实例创建，则进入 synchronized 控制的同步块,并再次检查实例是否创建，如果仍未创建，则创建该实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class SingleInstance &#123;</div><div class="line">  private static SingleInstance instance;</div><div class="line">  private SingleInstance() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static SingleInstance getInstance() &#123;</div><div class="line">      if (null == instance) &#123;</div><div class="line">          synchronized (SingleInstance.class) &#123;</div><div class="line">              if(null == instance) &#123;</div><div class="line">                  instance = new SingleInstance();</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      return instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>双重检查加锁保证了多线程下只创建一个实例，并且加锁代码块只在实例创建的之前进行同步。如果实例已经创建后，进入该方法，则不会执行到同步块的代码。</p>
<p>这里我们没有加 volatile ，大家可以思考一下，看看是不是必须要加 volatile？</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SingleInstance &#123;</div><div class="line">  private SingleInstance() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static SingleInstance getInstance() &#123;</div><div class="line">      return SingleInstanceHolder.sInstance;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private static class SingleInstanceHolder &#123;</div><div class="line">      private static SingleInstance sInstance = new SingleInstance();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，我想让它延迟加载， 上面就能这种方式就能达到。</p>
<p><strong>优点</strong>:</p>
<ul>
<li>单例模式（Singleton）会控制其实例对象的数量，从而确保访问对象的唯一性。</li>
<li>实例控制：单例模式防止其它对象对自己的实例化，确保所有的对象都访问一个实例。</li>
<li>伸缩性：因为由类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>系统开销。虽然这个系统开销看起来很小，但是每次引用这个类实例的时候都要进行实例是否存在的检查。这个问题可以通过静态实例来解决。</li>
<li>使用多个类加载器加载单例类，也会导致创建多个实例并存的问题。</li>
<li>使用反射，虽然构造器为非公开，但是在反射面前就不起作用了。</li>
<li>对象生命周期。因为单例模式没有提出对象的销毁， 所以使用时容易造成内存泄漏， 例如在 Android 中在 Activity 中使用单例， 所以我们要额外小心。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li>
<li>不要使用单例模式存取全局变量。这违背了单例模式的用意，最好放到对应类的静态成员中。</li>
<li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</li>
</ul>
<h2 id="Android-系统中的应用"><a href="#Android-系统中的应用" class="headerlink" title="Android 系统中的应用"></a>Android 系统中的应用</h2><p>在 Android 系统中， 大量使用单例模式， 我们来看一下。</p>
<p>饿汉式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class CallManager &#123;</div><div class="line">    ...</div><div class="line">    // Singleton instance</div><div class="line">    private static final CallManager INSTANCE = new CallManager();</div><div class="line"></div><div class="line">    public static CallManager getInstance() &#123;</div><div class="line">        return INSTANCE;</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>懒汉式非线程安全实现方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class SnackbarManager &#123;</div><div class="line">    .....</div><div class="line">    private static SnackbarManager sSnackbarManager;</div><div class="line"></div><div class="line">    static SnackbarManager getInstance() &#123;</div><div class="line">        if (sSnackbarManager == null) &#123;</div><div class="line">            sSnackbarManager = new SnackbarManager();</div><div class="line">        &#125;</div><div class="line">        return sSnackbarManager;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>懒汉式线程安全实现方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class SystemConfig &#123;</div><div class="line">    ...</div><div class="line">    static SystemConfig sInstance;</div><div class="line">    ...</div><div class="line">    public static SystemConfig getInstance() &#123;</div><div class="line">        synchronized (SystemConfig.class) &#123;</div><div class="line">            if (sInstance == null) &#123;</div><div class="line">                sInstance = new SystemConfig();</div><div class="line">            &#125;</div><div class="line">            return sInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>饿汉 VS 懒汉</strong>：<br>+饿汉：声明实例引用时就会被实例化</p>
<ul>
<li>懒汉：静态方法第一次调用前不被实例化，即懒加载。对于创建实例代价大的， 且不一定使用时，这种方式可以减少开销</li>
</ul>
<p>一般的情况下，构造方法没有太多处理时，我会使用「饿汉」方式， 因为它简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境）。只有在要明确实现延迟加载效果时我才会使用「静态内部类」方式。</p>
]]></content>
    
    <summary type="html">
    
      单例模式
    
    </summary>
    
      <category term="设计模式" scheme="http://hujiandong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://hujiandong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android 项目框架--MVP 基础</title>
    <link href="http://hujiandong.com/2016/12/13/android-mvp-basic/"/>
    <id>http://hujiandong.com/2016/12/13/android-mvp-basic/</id>
    <published>2016-12-13T09:17:19.000Z</published>
    <updated>2016-12-13T09:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="http://hujiandong.com">JasonThink</a></li>
<li>审阅者：<a href="https://github.com/shaDowZwy" target="_blank" rel="external">@shaDowZwy</a></li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天我们聊一聊传说中 Android 框架 MVP， 想必大家早就听过了， 最早接触这个名词时在今年1月份左右，那时候在 medium 上看到的一篇关于它的介绍， 看的也不是很明白， 不过被一些设计思想吸引。然后参阅一些相关的资料， 发现 Google 在 Github 有一个实现的代码， 然后模仿它例子也在 Github 上创建第一个 Android Demo。</p>
<p>现在真后悔当时没有写一篇相关的文章， 总给自己理解不深找借口， 越拖发现类似的文章越多， 现在都已经烂大街了， 本来不想凑这个热闹的，好吧， 管它了，就当来补债的 。当时还看了 MVP、MVVM、Facebook Flux 比较的文章，现在 Android 主流框架是： Retrofit + OkHttp + RxJava + MVP + Dagger 2。</p>
<p>言归正传，今天我们主要说明一下情况：</p>
<ul>
<li>什么是 MVP， 有什么优缺点。</li>
<li>如何实现。</li>
<li>实际项目中如何改造。</li>
</ul>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>全称 Model-View-Presenter，其中 Presenter 解耦了 Model 与 View，使得每个模块的职责更加单一，Model 负责获取数据，View 只关心视图的绘制，Presenter 关联 Model 和 View 处理业务逻辑。</p>
<p>需要注意的是，「Model」 这个词并不正确。严格意义上来说，它指的应该是检索或控制一个 Model 的业务逻辑层。举个例子，比如你的数据库里面包含了 User，而你的 View 想要显示一个 User 列表，那么 Presenter 会引用数据库中的业务逻辑层，查询一个 User 列表，如下图：</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/mvp.png" alt=""></p>
<p>有兴趣的大家可以参考下面的文章， 概念写的比较详细，里面讲到了， 它的的发展历程、MVX  解析。</p>
<blockquote>
<p>Android MVP 详解（上）</p>
<p><em><a href="http://www.jianshu.com/p/9a6845b26856" target="_blank" rel="external">http://www.jianshu.com/p/9a6845b26856</a></em></p>
</blockquote>
<p>我们把 MVP 的优缺点单独说一下， 「知己知彼，访客百战不殆」，不然想想下面场景：</p>
<blockquote>
<p>女朋友：你喜欢我什么？</p>
<p>我：(⊙v⊙)嗯，。。。</p>
<p>女朋友：连喜欢我什么都不知道， 走跟我回去跪方便面。</p>
<p>我：。。。。。</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>降低耦合度，实现了Model和View真正的完全分离，可以修改View而不影响Model</li>
<li>方便进行单元测试， 这个很重要。</li>
<li>Presenter可以复用，一个Presenter可以用于多个View。</li>
<li>View 可以进行组件化。在 MVP 当中，View 不依赖 Model。这样就可以让View 从特定的业务场景中脱离出来，可以说 View 可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>Presenter 中除了应用逻辑以外，还有大量的 View-&gt;Model，Model-&gt;View 的手动同步逻辑，造成 Presenter 比较笨重，维护起来会比较困难。</li>
<li>如果 Presenter 过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么 Presenter 也需要变更了。</li>
<li>View 实现接口比较多，显得代码可读性增高。</li>
</ul>
<h2 id="DEMO-展示"><a href="#DEMO-展示" class="headerlink" title="DEMO 展示"></a>DEMO 展示</h2><p>我最开始看的 Demo 就是 Google 官网提供的，给我很多启发，项目主要展示类似便签的应用。</p>
<blockquote>
<p>项目地址:</p>
<p><em><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">https://github.com/googlesamples/android-architecture</a></em></p>
</blockquote>
<p>下面是它框图：<br><img src="http://7xnilf.com1.z0.glb.clouddn.com/google-arch.jpg" alt=""></p>
<p>本来想拿官方源码进行剖析的，发现以及有人已经写了， 而且还写比我要好， 你说气人不， 下面是它的分析。</p>
<blockquote>
<p>Android官方MVP架构示例项目解析</p>
<p>[<em><a href="http://www.infoq.com/cn/articles/android-official-mvp-architecture-sample-project-analysis" target="_blank" rel="external">http://www.infoq.com/cn/articles/android-official-mvp-architecture-sample-project-analysis</a></em>]</p>
</blockquote>
<h2 id="实践项目使用"><a href="#实践项目使用" class="headerlink" title="实践项目使用"></a>实践项目使用</h2><p>我们来思考一个问题， 我们通过观察上一章 Google Demo 我们会发现一个问题， 事实上每个功能块的代码都是类似的，只是细节上会有所不同。重构的原则告诉我们，这些地方是可以进行重构的。在这个时候，一般会首先想到把一些相同的功能块抽象成一个基类。例如网络错误处理、服务器拒绝请求返回的错误处理等。但是随着项目的进行，很快就会发现，类文件量、代码量仍然会增加得很快，随之带来的问题是项目的管理会变得越来越复杂。</p>
<p>不满现状的我们又进行方案的重组和选择， 最后想到可以通过泛型和抽象，进一步简化 MVP 框架。所有view的基类是 IView（activity或fragment 也是这 view）。<br><strong>IView</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IView</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>IPresenter</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPresenter</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">IView</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(V view)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachView</span><span class="params">(<span class="keyword">boolean</span> retainInstance)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面我们提到，我们把 Activity 和 Fragment 看成 View。所以我们提供了 MVPActivity 和 MVPFragment 作为他们的基类。</p>
<p>这里我们仅仅看 <strong>MVPActivity</strong>， MVPFragment类似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MVPActivity</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">IView</span>, <span class="title">P</span> <span class="keyword">extends</span> <span class="title">IPresenter</span>&lt;<span class="title">V</span>&gt;&gt;</span></div><div class="line">        <span class="keyword">extends</span> <span class="title">BaseActivity</span> <span class="keyword">implements</span> <span class="title">IView</span>, <span class="title">IMvpBase</span>&lt;<span class="title">V</span>&gt;&#123;</div><div class="line">    <span class="keyword">protected</span> P presenter;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        presenter = createPresenter();</div><div class="line">        presenter.attachView(getMvpView());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        presenter.detachView(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> P <span class="title">createPresenter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getMvpView</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (V)<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要思想是 IView 会关联一个 IPresenter, 并且管理 IPresenter 的生命周期。大家从上面的代码片段可以看到， 通常 presenter 是绑定在该生命周期上。所有的初始化或者清理工作都放在 <code>presenter.onAttach()</code> 和 <code>presenter.detach()</code> 上进行。想大家注意到 IPresenter 是一个接口。 我们还提供一个 <strong>BasePresenter</strong>,  它只持有 View 的弱引用， 从而避免内存泄漏。所有，当 presenter 想要调用 view 的方法是， 我们需要判断 <code>isViewPresenter()</code> 并使用 <code>getView()</code>来获取引用，以坚持view是否连接当了 presenter。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/mvparch.png" alt=""></p>
<p>看一下上图我项目结构， 其中 BaseLib 下有两个库，分别是 baseapp、mvplib。</p>
<ul>
<li>baseapp：主要包含BaseActiviy、AppMain 类</li>
<li>mvplib： 主要是时 MVP 封装框架，更高效开发</li>
<li>app: 主要是我们的演示程序</li>
</ul>
<p>那么我们看 app 中演示程序，这里本身只是简单通过 Activity 自举， 别的类似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">MVPActivity</span>&lt;<span class="title">MainActivity</span>, <span class="title">HelloPresenter</span>&gt; <span class="keyword">implements</span> <span class="title">IView</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="keyword">final</span> EditText editText = (EditText) findViewById(R.id.editText);</div><div class="line">        Button button = (Button) findViewById(R.id.button);</div><div class="line">        <span class="keyword">final</span> TextView textview = (TextView)findViewById(R.id.textView);</div><div class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                String str = editText.getText().toString().trim();</div><div class="line">                presenter.submit();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> HelloPresenter <span class="title">createPresenter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloPresenter();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面代码中我们可以看到 MainActivity 继承了 MVPActivity ，实现了 IView， 其中 <code>createPresenter()</code>负责创建对应的 Presenter，下面我们看 HelloPresenter 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloPresenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</div><div class="line">        MainActivity view = getView();</div><div class="line">        TextView textView = (TextView) view.findViewById(R.id.textView);</div><div class="line">        EditText editText = (EditText) view.findViewById(R.id.editText);</div><div class="line">        <span class="keyword">assert</span> editText != <span class="keyword">null</span>;</div><div class="line">        textView.setText(editText.getText().toString().trim());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到 HelloPresenter 负责进行 UI 的更新， 这里只是简单举例， 实际项目中我们可以配合 RxJava 进行实现。<br>具体实现可以看一下本人的Github的实现。</p>
<blockquote>
<p>项目GitHub：<br><em><a href="https://github.com/jasonim/mvparchitecture" target="_blank" rel="external">https://github.com/jasonim/mvparchitecture</a></em></p>
</blockquote>
<p>这样我们上面基本上解决上面我们提出的问题， 当然我们经常可能遇到屏幕旋转的问题， 这样一般处理数据持久化问题， 一般的做法是在 <code>onSaveInstanceState()</code>处理， 简单做法记录数据。当然我们可以通过状态来修复view的状态。就不在这里说了， 感兴趣的可以参考 <strong>mosby</strong> 的做法。</p>
<blockquote>
<p>mosby:<br><em><a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">https://github.com/sockeqwe/mosby</a></em></p>
</blockquote>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>「一万个心中有一万个哈姆雷特」，没有任何事情是绝对不变的， 框架也是一样，对 MVP 的争论不断：</p>
<blockquote>
<p>MVP，太多的接口，如果项目大的话，还可以，如果不大，就建太多的类。感觉有点笨重。。。</p>
</blockquote>
<p>把握以下两点就行：</p>
<ul>
<li>我们引用项目框架目的是什么？是不是为了业务扩展，如果没有扩展需求， 什么项目框架也不需要。</li>
<li>每个人的理解不一样，实践中找到一个适合自己的就好, 如果感觉 MVVM 的双向绑定很好，那就改造一下， 没有最好，只有更好。实践、再实践。 </li>
</ul>
<p>下一篇我们来聊一聊， 怎样在 MVP 中加入 dagger、rxjava；怎么通过组件化优化项目结构。</p>
]]></content>
    
    <summary type="html">
    
      Android 项目框架--MVP 基础
    
    </summary>
    
      <category term="项目架构" scheme="http://hujiandong.com/categories/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="项目架构" scheme="http://hujiandong.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式</title>
    <link href="http://hujiandong.com/2016/12/07/factory-method/"/>
    <id>http://hujiandong.com/2016/12/07/factory-method/</id>
    <published>2016-12-07T02:43:23.000Z</published>
    <updated>2016-12-07T02:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>文章来源：ThinkKeep 的 <a href="https://github.com/ThinkKeep/design-patterns" target="_blank" rel="external">design-patterns</a> 项目</li>
<li>作者：<a href="http://hujiandong.com">JasonThink</a></li>
<li>审阅者：<a href="https://github.com/shixinzhang" target="_blank" rel="external">@shixinzhang</a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2></li>
</ul>
<p><img src="https://rawgit.com/jasonim/design-patterns/develop/zh/creator-mode/factory-method/image/factory-method.svg" alt=""></p>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//Http</span></div><div class="line">        ProtocolFactory factory = <span class="keyword">new</span> HTTPFactory();</div><div class="line">        Protocol protocol = factory.createProtocol();</div><div class="line">        protocol.performRequest();</div><div class="line"></div><div class="line">        <span class="comment">//UDP</span></div><div class="line">        factory = <span class="keyword">new</span> UDPFactory();</div><div class="line">        protocol = factory.createProtocol();</div><div class="line">        protocol.performRequest();</div><div class="line"></div><div class="line">        <span class="comment">//TCP</span></div><div class="line">        factory = <span class="keyword">new</span> TCPFactory();</div><div class="line">        protocol = factory.createProtocol();</div><div class="line">        protocol.performRequest();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码， 分别通过不同的协议工厂创建不同协议类， 方便客户端调用。这样客服端不需要关心哪种具体产品类将被实例化这一细节，也不需知道具体的类的类名， 当再有更多协议更方便扩展，也遵循「对扩展开放，对修改关闭」的原则。如果细心的同学可能会发现， 三段代码有相同的地方， 是的， 可以进一步重构， 像这样<code>createFactory(int protocol)</code>，这里为了更方便大家看懂工厂方法，就分开来写了。</p>
<p>运行结果：<br><img src="https://rawgit.com/jasonim/design-patterns/develop/zh/creator-mode/factory-method/image/factory-method-run.png" alt=""></p>
<p><strong>优点</strong>：</p>
<ul>
<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当我们遇见下列场景，可以考虑工作方法模式：</p>
<ul>
<li>我们不能预先知道被创建对象的类型，如我们在不知道发送网络请求用什么协议（TCP、UPD 或 HTTP）， 就像上面的例子。</li>
<li>一个类想要他的子类指定它的创建的实例</li>
<li>将创建的对象的任务委托给多个工厂子类中的其中一个， 调用者在使用时可以无需关系是哪个工厂子类创建产品， 需要时动态指定， 可将具体工厂类名存储在配置文件或数据中。</li>
</ul>
<h2 id="Android-应用实例"><a href="#Android-应用实例" class="headerlink" title="Android 应用实例"></a>Android 应用实例</h2><p>Android 中用到了太多的工厂类，其中有用工厂方法模式的，比如AsyncTask类中工厂的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//工厂实现类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码中 ThreadFactory 就是工厂方式的类的实现。</p>
]]></content>
    
    <summary type="html">
    
      工厂方法模式
    
    </summary>
    
      <category term="设计模式" scheme="http://hujiandong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://hujiandong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="http://hujiandong.com/2016/12/07/abstract-factory/"/>
    <id>http://hujiandong.com/2016/12/07/abstract-factory/</id>
    <published>2016-12-07T02:40:13.000Z</published>
    <updated>2016-12-07T02:42:04.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>文章来源：ThinkKeep 的 <a href="https://github.com/ThinkKeep/design-patterns" target="_blank" rel="external">design-patterns</a> 项目</li>
<li>作者：<a href="http://hujiandong.com">JasonThink</a></li>
<li>审阅者：<a href="https://github.com/shixinzhang" target="_blank" rel="external">@shixinzhang</a></li>
</ul>
<p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。我们可以想一下，有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象，即产品族。如在工厂方法中 HTTPFactory 只负责生产 HTTPProtocol 等。显然不能满足我们的需求了， 怎么办？ 抽象工厂模式给我们解决了这个问题。</p>
<p>为了让你能够更好的理解抽象工厂模式， 我们先了解以下几个概率：</p>
<ul>
<li><strong>产品等级结构</strong> ：产品等级结构即产品的继承结构，如一个抽象类是 Protocol，其子类有 HTTPProtocol、TCPProtocol、UDPProtocol，则抽象 Protocol与具体协议之间构成了一个产品等级结构，抽象Protocol是父类，而具体协议的 Procotol 是其子类。</li>
<li><strong>产品族</strong>：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如中国麦当劳店生产的巨无霸、可乐， 巨无霸位于汉堡产品等级结构中，可乐位于饮料产品等级结构中。</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes。为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>大家都去麦当劳吃过汉堡吧， 还有中国的麦当劳产品和国外的麦当劳，不一样吧， 至少原料不一样吧， 鸡肉都是本地产的吧，还有汉堡的大小不一样吧。套餐的品种也不样吧， 下面我们就用麦当劳举例吧。</p>
<p><strong>类图</strong>：</p>
<p><img src="https://rawgit.com/jasonim/design-patterns/develop/zh/creator-mode/abstract-factory/image/abstract-factory.svg" alt=""></p>
<p><strong>代码</strong>：</p>
<p><strong>AbsFactory</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbsFactory</span> </span>&#123;</div><div class="line">    <span class="function">Hamburg <span class="title">createhamburg</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Drink <span class="title">createDrink</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//套餐....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Store</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        AbsFactory factory = <span class="keyword">new</span> ChineseFactory();</div><div class="line">        factory.createDrink();</div><div class="line">        factory.createhamburg();</div><div class="line"></div><div class="line">        factory = <span class="keyword">new</span> NYFactory();</div><div class="line">        factory.createDrink();</div><div class="line">        factory.createhamburg();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>运行结果</strong>：</p>
<p><img src="https://rawgit.com/jasonim/design-patterns/develop/zh/creator-mode/abstract-factory/image/run.png" alt=""></p>
<p><strong>优点</strong>：</p>
<ul>
<li>封装性，每个产品的实现类不是高层模块要关系的，要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类。</li>
<li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>抽象工厂模式的最大缺点就是产品族扩展非常困难，如实例中如果再添加新产品， 就需要在抽象工厂类添加对应的产品，开闭原则的倾斜性。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<p>如某个 APP多套主题时， 青春版、老人版、自恋办等， 可以考虑抽象工厂模式。</p>
<h2 id="抽象工厂模式与工厂方法模式区别及联系"><a href="#抽象工厂模式与工厂方法模式区别及联系" class="headerlink" title="抽象工厂模式与工厂方法模式区别及联系"></a>抽象工厂模式与工厂方法模式区别及联系</h2><p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。</p>
<p>他们自己没有绝对界限，当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>
<h2 id="Android-源码中的应用"><a href="#Android-源码中的应用" class="headerlink" title="Android 源码中的应用"></a>Android 源码中的应用</h2><p>在java 的连接数据库的操作中，对不同的数据库的操作而形成的对象操作族，就是一种很好的抽象工厂模式的应用。而在 Android 系统中 WebViewFactoryProvider/WebViewChromiumFactoryProvider 也应用抽象工厂。</p>
<p><strong>WebViewFactoryProvider</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebViewFactoryProvider</span> </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function">WebViewProvider <span class="title">createWebView</span><span class="params">(WebView webView, WebView.PrivateAccess privateAccess)</span></span>;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function">CookieManager <span class="title">getCookieManager</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>WebViewChromiumFactoryProvider</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewChromiumFactoryProvider</span> <span class="keyword">implements</span> <span class="title">WebViewFactoryProvider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> WebViewProvider <span class="title">createWebView</span><span class="params">(WebView webView,</span></span></div><div class="line">    	WebView.PrivateAccess privateAccess) &#123;</div><div class="line">        WebViewChromium wvc = <span class="keyword">new</span> WebViewChromium(<span class="keyword">this</span>,</div><div class="line">        	webView, privateAccess);</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">return</span> wvc;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CookieManager <span class="title">getCookieManager</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            <span class="keyword">if</span> (mCookieManager == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                ...</div><div class="line"></div><div class="line">                mCookieManager = <span class="keyword">new</span> CookieManagerAdapter(<span class="keyword">new</span> AwCookieManager());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mCookieManager;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WebViewFactoryProvider是抽象工厂接口，定义了WebView及周边功能所需要对象的创建方法，这些方法大部分为工厂方法，它们返回的对象类型是抽象的，属于面向接口的编程风格。抽象工厂WebViewFactoryProvider创建的对象有：实现Webview核心功能的WebViewProvider，管理Cookie的CookieManager，地理位置相关的GeolocationPermissions和存储Web表单数据的WebviewDatabase等等。WebViewChromiumFactoryProvider是抽象工厂的具体实现者，它提供“Chromium”主题的产品族，也是目前最新版本Webview正在使用的产品族。如果将来有新的浏览器引擎内核出现(以前用得是 Apple Webkit 内核， 听说 google 搞了一套自己的，不知道现在加进去没)，那么只需按照WebViewFactoryProvider接口创建该主题下产品，然后替换现有的「Chromium」就可以完成换代，不用改动其他地方任何代码。</p>
]]></content>
    
    <summary type="html">
    
      抽象工厂模式
    
    </summary>
    
      <category term="设计模式" scheme="http://hujiandong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://hujiandong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>那些年我的编程之路（上）</title>
    <link href="http://hujiandong.com/2016/11/28/my-program-away-1/"/>
    <id>http://hujiandong.com/2016/11/28/my-program-away-1/</id>
    <published>2016-11-28T06:49:48.000Z</published>
    <updated>2016-11-28T06:54:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>我接触编程比较晚， 大学时候才开学习编程的， 和阿里的『道哥』、Thoughwork 的 『Phodal』 比起来都要晚， 当然和『云舒』比起来要早， 哪又怎样，人家都能甩我几个银河系。 问我当初为什么学习编程呢？因为我的计算专业的。那你为什么选计算机专业呢？因为当初我上的那个学校，计算机专业没招满， 我被调剂到这个专业了，我当时报的可是生物技术啊。是不是好多同学和我一样， 恭喜。 现在想想真应该感谢我的母校。如果当时学了生物技术， 现在不敢想我能做什么， 实验小白鼠、研究甜玉米、在制药公司买药， 可惜人生没有假设， 不然呢？</p>
<p>和很多大一新生一样， 好不容易离开父母的监管， 记得一般英语课都在上午前两节， 由于晚上玩的比较晚，当然上午就起不来了， 结果导致一般英语课就不去了。那时候主要的活动是 喝酒、Dtao、篮球，记得以前提过喝酒最高纪录，也是那时候创下的。我们吃饭喝酒一般都在学校旁边的 『老地方水煮鱼』，一般一份水煮鱼、一份花生米、四份米饭、8瓶啤酒，齐活。60左右， 现在看来真便宜，而且他家的水煮鱼是一绝，就现在来看也是。前段时间有点事回去，还和同学特意去吃了一次， 还是那个味道， 只是地方变大了， 还和老板说，  「以后不干这行了， 加盟你的水煮鱼可否」。 </p>
<p>大二除了做上面的事情， 做了另一件最主要的事情，找了一个女朋友， 主要动机我想不能重复做大一的事情了，太没意思了，那就找个朋友刷刷吧。由于时间就那么多， 喝酒、打游戏、篮球， 我就出掉了打游戏， 当然不是完全不玩， 只是频率少了很多。女朋友是外校的，  具体是怎么认识的，怎么追的。今天不再这里展开说了， 上次我就说写一写我和她的故事， 一直也没有写，哪天一定要把债补上。总之她是我生命中最主要的女人之一。正好今天是感恩节， 她刚刚发微信告诉我，今天是感恩节， 我是这样回的 「<strong>谢谢你的把我收了，不然我就砸手里了</strong>」 。</p>
<p>大三我又做了一件事情，真正学习编程。 当时感觉应该考虑毕业之后该做什么，回家种地？ 既然学了这个专业， 又没有更好的出路，那就认真搞一把， 由于专业课没有怎么逃课，感觉基础还行。可是自学了一段时间， 一直徘徊于 Hello world 上面。 我就找到当时交我们 C# 老师聊了聊， 说明我的一些想法。他说可以， 你先给做个东西， 拿给他看看。 然后我就给他用 C# 做了一个计算器。也是在网上找的，其实好多代码都看不懂， 勉强让它跑起来。他看后没有说行还是不行，我就回去等结果， 一周我去找他一次， 这样连续去了两周。他说行吧， 你再给我找一个同学， 你两一块；我就找了一个喜欢编程的也喜欢喝酒的。</p>
<p>就这样我们跟这那个老师，边做项目边学习， 持续大概一年时间， 中间为了提高效率我们搬进我们学院提供实验室， 当然学习氛围更好一些， 至少很少看见在那打游戏的了。在哪里我也接触到 Linux，可以说那里是我 『计算机的启蒙、也是我 Linux 的启蒙』，那段时间是我状态最好的， 虽然没有学到什么东西， 但是现在看来让我走上编程道理的主要原因， 不然我不会选择编程之路。</p>
<hr>
<p>PS：<br>不知道微信公众号里都有多少是刚刚工作不久，或者还没有毕业的。虽然我的公众号里并没有多少人，关注我的都是我的种子用户，你们不离不弃， 必将芳龄永继。哈哈， 言归正传， 还没有毕业的或刚刚毕业， 一定要做好下面几件事：</p>
<ol>
<li>如果是男生一定要找一个女朋友， 如果是女生就算了，因为关注我公众号的女生都抢手哈， 不要急，发现上进的男人就同意了；不要太挑了， 这也是一种投资， 当然也有投资失败的情况， 不要在意。 不要听别人说，「现在谈了， 毕业就会分手， 还不如不谈」。这样的论断， 因为每个个体都不一样， 不试试怎么知道呢？我不能说一定不会分手， 至少我身边的有一两个包括我自己都没有分手， 而且还结婚了。是不是让吃瓜群众失望了。当然我们几个只是个体，不适用普遍规律。但是一点是真的恋爱能让人成长。还有最主要的原因是看你们怎么对待这段感谢的， 也就是对待感情的态度， 我看到的好多分手的，都是对待感情很随意。好多人会说那时候年轻不懂，其实不是不懂， 是拿年轻找借口。如果刚毕业也要抓紧找， 不然以后成本会越来越高。当然你认为你很优秀，优秀到地球都装不下你了， 那最好别找。把机会让给不那么优秀的人吧。<strong>还有找朋友，真的那么难吗</strong>？ 多发点时间， 多用点心， 多一点厚脸皮。能跨专业找就跨专业找，如果你会写程序， 你就在特殊的日子，写一点特殊的东西， 其实不难。不会写程序， 总会修电脑、装软件吧， 如果你还说不会， 那就活该你没有女朋友。真替你们着急， 写的我都想再找一次女朋友了， 你们难道没有感觉吗？</li>
<li><strong>好好学习， 多和别人沟通，多参加一些活动 ，哪怕这个专业你不喜欢，你也认真听课，特别是英语。这个就是你于别人不同的地方， 也是你的价值。现在网络特别发达，  如果你有喜欢的方向， 就去学。还有一定要学会科学上网（翻墙），如果不会， 就先把这个学会， 不管你是什么专业，以后从事行业，如果你学习编程就上 Github，什么都有</strong>。</li>
<li>一定要重视第一份工作， 好好想想你要什么， 如果真不知道， 就要去一个中型以上的公司， 最好不要去 Start Up 公司， 这个对以后的最终成为什么样的人， 起到很重要的作用。 当然那些公司不好进， 这个就需要平时多下功夫，特别是那些和我一样学校背景一般的童鞋，更应该多努力， 因为我们可利用的资源少。每个行业切入点不一样，但是差别不大。</li>
<li>除非特殊原因， 前面两三年不要换行业、 城市， 当然工作时间越久，换行业的成本越高。自己把握一个度就行， 以前面试的时候， 有一个童鞋看他简历上写着以前在上海工作， 问他为什么来北京， 他说 「女朋友在北京」，这种鼓励。</li>
</ol>
<p><strong>本篇文章，首发于微信公众号！</strong></p>
]]></content>
    
    <summary type="html">
    
      那些年我的编程之路（上）
    
    </summary>
    
      <category term="杂谈" scheme="http://hujiandong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://hujiandong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>设计模式几大原则</title>
    <link href="http://hujiandong.com/2016/11/21/design-principle/"/>
    <id>http://hujiandong.com/2016/11/21/design-principle/</id>
    <published>2016-11-21T10:06:26.000Z</published>
    <updated>2016-12-07T05:56:58.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>文章来源：ThinkKeep 的 <a href="https://github.com/ThinkKeep/design-patterns" target="_blank" rel="external">design-patterns</a> 项目</li>
<li>作者：<a href="http://hujiandong.com">JasonThink</a></li>
<li>审阅者：<a href="https://github.com/shixinzhang" target="_blank" rel="external">@shixinzhang</a></li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>天下武林，林林总总。名门正宗如少林武当，诚然名扬天下，而武林之大，但凡修得暗镖神剑者，亦可独步江湖。所以门派无尊贵，只有适合不适合。设计的本质：即使最懂设计的人，也要心胸坦荡，认识到自我局限性，不可以名门正宗自居，须认识到获得真理是一个学无止境、永远追求的过程。</p>
<p>十八般武艺样样精通，仅出现在武侠传说中， 现实中即使是全栈工程师也不敢说十八般武艺样样精通， 对于普通的IT从业者来说， 如何从码农变为一个合格的工程师来说， 软件设计是必经之路。 当然要软件设计一定要遵循设计的六大原则。在工作的初期，我们可能会经常有这样的感受，自己的代码接口设计混乱、代码耦合较为严重、一个类的代码过多等等，当自己回头再看这些代码时可能会感慨，怎么能写成这个鸟样。再看那些知名的开源库，它们大多有整洁的代码、清晰简单的接口、职责单一的类，这个时候我们会通常会捶胸顿足而感慨：什么时候老夫才能写出这样的代码！</p>
<p>在做开发的这些年中，我渐渐的感觉到，其实国内的一些初、中级工程师写的东西不规范或者说不够清晰的原因是缺乏一些指导规则。他们手中挥舞着面向对象的大旗，写出来的东西却充斥着面向过程的气味。也许是他们不知道有这些规则，也许是他们知道但是不能很好的运用到实际的代码中，亦或是他们没有在实战项目中体会到这些原则能够带来的优点，以至于他们对这些原则并没有足够的重视。</p>
<h2 id="设计的六大原则"><a href="#设计的六大原则" class="headerlink" title="设计的六大原则"></a>设计的六大原则</h2><p>在此之前，有一点需要大家知道，熟悉这些原则并不是说你写出的程序就一定灵活、清晰，只是为你优秀的代码之路铺上了一层栅栏，在这些原则的指导下，你才能避免陷入一些常见的代码泥沼，从而让你写出优秀的东西。</p>
<h3 id="单一原则-Single-Responsibility-Principle"><a href="#单一原则-Single-Responsibility-Principle" class="headerlink" title="单一原则(Single Responsibility Principle)"></a>单一原则(Single Responsibility Principle)</h3><p>单一职责原则的英文名称是 Single Responsibility Principle，简称是 SPR，简单地说就是一个类只做一件事，这个设计原则备受争议却又极其重要。只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的。因为单一职责的划分界限并不是如马路上的行车道那么清晰，很多时候都是需要个人经验来界定。当然，最大的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。这跟我们社会分工一样， 一些人干这个， 另一些人干那个，只有大家都这样做了， 我们的社会才更和谐。</p>
<p>试想一下，如果你遵守了这个原则，那么你的类就会划分的很细，每个类都有比较单一的职责，这不就是高内聚、低耦合么！当然，如何界定类的职责就需要你的个人经验了。</p>
<p>当然，软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离，就是抽象的能力。其实要去判断是否应该分离出类来，也不难，那就是如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>
<p>我们来定义一个网络类，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHttp</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 发送 Http 请求，并且返回一个 Response</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request&lt;?&gt; request)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，IHttp 只有一个 sendRequest 函数，它的职责就是执行网络请求并且返回一个 Response，它的职责很单一，这样在需要修改执行网络请求的相关代码时，只需要修改实现 Http 接口的类，而不会影响其他类的代码。如果某个类的职责包含有执行网络请求、解析网络请求、进行 gzip 压缩、封装请求参数等，那么在你修改某处代码时就必须谨慎，以免修改的代码影响了其它的功能。当你修改的代码能够基本上不影响其他功能。这就一定程度上保证了代码的可维护性。注意，单一职责原则并不是一个类只能有一个函数，而是说这个类中的函数所做的工作是高度相关的，也就是高内聚。</p>
<p>基本判断原则， 就是一个特定的类，当确认以后， 它的责任就确定了，不能增加它行为以外的功能。 例如一般我们定义 API 接口的时候，如果这个接口干了很多事情， 就是一些隐含的事情，我们就认为它设计没有遵循<strong>单一原则</strong>。<br><strong>优点</strong></p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义。</li>
<li>可读性提高，复杂性降低，那当然可读性提高了。</li>
<li>可维护性提高，可读性提高了，那当然更容易维护了。</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<h3 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)"></a>里氏替换原则(Liskov Substitution Principle)</h3><p>里氏替换原则本质就是继承和多态的应用。继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。<br>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ul>
<p>还拿上面的 Http 类举例， 我们用 Restful API 方式进行 Http 网络请求，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulClient</span> </span>&#123;</div><div class="line">    ....</div><div class="line">    <span class="function">Public <span class="title">RestfulClient</span><span class="params">(IHttp http)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.http = http != <span class="keyword">null</span> ? http : createHttp();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(String url, List&lt;Header&gt; list, Body body)</span> </span>&#123;</div><div class="line"></div><div class="line">        ...<span class="comment">//先创建Request</span></div><div class="line">        <span class="comment">//发送数据</span></div><div class="line">        http.sendRequest(request)；</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//创建IHttp 类 TODO 这个可以重构到Factory 里， 这里先偷个懒</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHttp <span class="title">createHttp</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//我们可以根据 Android SDK 选择不同的HTTP</span></div><div class="line">        <span class="keyword">int</span> runtimeSDKApi = Build.VERSION.SDK_INT;</div><div class="line">        <span class="keyword">if</span> (runtimeSDKApi &gt;= GINGERBREAD_SDK_NUM) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpUrlConnImpl();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpClientImpl();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中， RestfulClient 类中依赖的是 IHttp 接口，而通过 createHttp 函数返回的是 IHttp 的实现类 HttpClientImpl 或 HttpUrlConnImpl。这就是所谓的里氏替换原则，任何父类、父接口出现的地方子类都可以出现，这不就保证了可扩展性吗！如果我们现在将网络请求库改成 OKHttp， 是不是将依赖传进去就行了。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性。</li>
<li>提高代码的重用性。</li>
<li>提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，很多开源框架的扩展接口都是通过继承父类来完成的。</li>
<li>提高产品或项目的开放性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>继承是侵入性的。只要继承，就必须拥有父类所有的属性和方法。</li>
<li>降低了代码的灵活性。子类必须父类的属性和方法，让子类自由的世界中多了些约束。</li>
<li>增强了耦合性。当父类的常亮、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的后果—大量的代码需要重构。</li>
</ul>
<h2 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h2><p>电脑在以前维修的话是根本不可能的事，可是现在却特别容易，比如说内存坏了，买个内存条，硬盘坏了，买个硬盘换上。为啥这么方便？从修电脑里面就有面相对象的几大设计原则，比如单一职责原则，内存坏了，不应该成为更换CPU的理由，它们各自的职责是明确的。再比如开放－封闭原则，内存不够只要插槽足够就可以添加。还有依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象，说白了，就是要针对接口编程，不要对实现编程，无论主板，CPU，内存，硬盘都是针对接口设计的，如果是针对实现来设计，内存就要对应的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬。</p>
<h3 id="为什么叫反转呢？"><a href="#为什么叫反转呢？" class="headerlink" title="为什么叫反转呢？"></a>为什么叫反转呢？</h3><p>面对过程开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们做新项目时，去调用这些底层的函数就可以了。比如我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时就去调用，这就叫做高层模块依赖底层模块。</p>
<p>但是要做新项目是 业务逻辑的高层模块都是一样的，客户却希望使用不同的数据库或存储信息方式，这时出现麻烦了。我们希望能再次利用这些高层模块，但高层模块都是与底层的访问数据库绑定在一起的，没办法复用这些高层模块，这就非常糟糕了。就像刚才说的，PC里如果CPU，内存，硬盘都是需要依赖具体的主板，主板一坏，所有的部件都没法用了，显然不合理，而如果不管高层模块还是底层模块，它们都依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其它受影响，这就使得无论高层模块还是底层模块都可以很容易被复用，这才是最好的办法。</p>
<p>在前面我们的例子中， RefusClient 实现类依赖于 IHttp 接口（抽象），而不依赖于 HttpClientImpl 与 HttpUrlConnImpl 实现类（细节），这就是依赖倒置原则的体现。</p>
<p>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和 setter 方法传递，相信用过 Dagger、Spring 框架的，对依赖的传递方式一定不会陌生。 在实际编程中，我们一般需要做到如下：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则。 依赖倒置原则的核心就是要我们面向接口编程。<br><strong>优点</strong>：</li>
<li>可扩展性好</li>
<li>耦合度低</li>
</ul>
<h2 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h2><p>接口隔离原则（英语：interface-segregation principles， 缩写：ISP）指明没有客户(client)应该被迫依赖于它不使用方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为角色接口（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。接口隔离原则是在SOLID (面向对象设计)中五个面向对象设计(OOD)的原则之一，类似于在GRASP (面向对象设计)中的高内聚性。</p>
<p>下面是看到网上的举的例子：</p>
<blockquote>
<p>可能描述起来不是很好理解，我们还是以示例来加强理解吧。 我们知道，在网络框架中，网络队列中是会对请求进行排序的。内部使用 PriorityBlockingQueue 来维护网络请求队列，PriorityBlockingQueue 需要调用 Request 类的排序方法就可以了，其他的接口他根本不需要，即 PriorityBlockingQueue 只需要 compareTo 这个接口，而这个 compareTo 方法就是我们所说的最小接口方法，而是 Java 中的 Comparable 接口，但我们这里是指为了学习，至于哪里定义的无关紧要。</p>
<p>在元素排序时，PriorityBlockingQueue 只需要知道元素是个 Comparable 对象即可，不需要知道这个对象是不是 Request 类以及这个类的其他接口。它只需要排序，因此，只要知道它是实现了 Comparable 对象即可，Comparable 就是它的最小接口，也是通过 Comparable 隔离了 PriorityBlockingQueue 类对 Request 类的其他方法的可见性。</p>
</blockquote>
<p>很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构。 采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</li>
</ul>
<h2 id="迪米特原则-Law-of-Demeter"><a href="#迪米特原则-Law-of-Demeter" class="headerlink" title="迪米特原则( Law of Demeter)"></a>迪米特原则( Law of Demeter)</h2><p>迪米特原则（Law of Demeter，缩写LoD）等同于“最少知识原则（Principle of Least Knowledge）”，是一种软件开发的设计指导原则，特别是面向对象的程序设计。迪米特原则是松耦合的一种具体案例。该原则是美国东北大学在1987年末在发明的，可以简单地以下面任一中方式总结。</p>
<p>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元； 每个单元只能和它的朋友交谈：不能和陌生单元交谈； 只和自己直接的朋友交谈。 这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。</p>
<p>很多面向对象程序设计语言用”.”表示对象的域的解析算符，因此迪米特原则可以简单地陈述为“只使用一个.算符”。因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p>
<p>通俗地讲，一个类应该对自己需要耦合或者调用的类知道得最少，这有点类似于接口隔离原则中的最小接口的概念。类的内部如何实现、如何复杂都与调用者或者依赖者没有关系，调用者或者依赖者只需要知道它需要它需要的方法即可，其他的一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>降低复杂度</li>
<li>降低耦合性</li>
<li>增加稳定性</li>
</ul>
<h2 id="开闭原则-Open-Close-Principle"><a href="#开闭原则-Open-Close-Principle" class="headerlink" title="开闭原则(Open-Close Principle)"></a>开闭原则(Open-Close Principle)</h2><p>开闭原则是 Java 世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。开闭原则的定义是：一个软件实体类，模块和函数应该对扩展开放，对修改关闭。在软件的生命周期内，因为变化、升级和维护等原因，需要对软件原有的代码进行修改时，可能会给旧代码引入错误。因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。</p>
<p>在软件开发过程中，永远不变的就是变化。开闭原则是使我们的软件系统拥抱变化的核心原则之一。对扩展开放，对修改关闭这样的高层次概括，即在需要对软件进行升级、变化时应该通过扩展的形式来实现，而非修改原有代码。当然这只是一种比较理想的状态，是通过扩展还是通过修改旧代码需要依据代码自身来定。</p>
<p>还是上面的例子， HttpUrlConnImpl 和 HttpClientImpl 实现了 IHttp 接口， 当我们实现 OKHttp 的时候就可以实现 HttpOKImpl， 这样通过扩展的形式来应对软件的变化或者说用户需求的多样性，既避免了破坏原有系统，又保证了软件系统的可维护性。依赖于抽象，而不依赖于具体，使得对扩展开放，对修改关闭。开闭原则与依赖倒置原则，里氏替换原则一样，实际上都遵循一句话：面向接口编程。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>增加稳定性</li>
<li>可扩展性高</li>
</ul>
<h3 id="避免掉进过度设计的怪圈"><a href="#避免掉进过度设计的怪圈" class="headerlink" title="避免掉进过度设计的怪圈"></a>避免掉进过度设计的怪圈</h3><p>当你掌握一些设计模式或者手法之后，比较容易出现的问题就是过度设计。有的人甚至在一个应用中一定要将 23 种常见的设计模式运用上，这就本末倒置了。设计模式的四大要素中就明确指出，模式的运用应该根据软件系统所面临的问题来决定是否需要使用现有的设计。也就是说，再出现问题或者你预计会出现那样的问题时，才推荐使用特定的设计模式，而不是将各种设计模式套进你的软件中。</p>
<p>不管在设计、实现、测试之间有多少时间都应该避免过度设计，它会打破你的反馈回路，使你的设计得不到反馈，从而慢慢陷入危险中。所以你只需要保持简单的设计，这样就有时间来测试该设计是否真的可行，然后作出最后的决策。</p>
<p>当设计一款软件时，从整体高度上设定一种架构模式，确定应用的整体架构，然后再分析一些重要的设计思路，并且保证他们的简单性、清晰性，如果有时间可以使用 Java 代码模拟一个简单的原型，确保设计是可行的，最后就可以付诸行动了。切实不要过度的追求设计，适当就好，当我们发现或者预计到将要出现问题时，在判断是否需要运用设计模式。</p>
]]></content>
    
    <summary type="html">
    
      设计模式原则
    
    </summary>
    
      <category term="设计模式" scheme="http://hujiandong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://hujiandong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android 单元测试--Mock及Mockito</title>
    <link href="http://hujiandong.com/2016/11/07/android-unit-test-mock/"/>
    <id>http://hujiandong.com/2016/11/07/android-unit-test-mock/</id>
    <published>2016-11-07T11:22:29.000Z</published>
    <updated>2016-11-18T09:22:30.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="http://hujiandong.com">JasonThink</a></li>
<li>审阅者：<a href="https://github.com/itsMelo" target="_blank" rel="external">@Melo</a></li>
</ul>
<p>以前我在<strong><a href="http://hujiandong.com/2016/04/10/how_code_auto_test/">内功之自动化测试</a></strong>中说到测试在项目中的重要性。单元测试是一个个「点」（细胞）的重构，是重构的基石，今天我们说单元测试中如何使用 <strong><a href="https://en.wikipedia.org/wiki/Mock_object" target="_blank" rel="external">Mock</a></strong> 及 <strong><a href="http://mockito.org/" target="_blank" rel="external">Mockito</a></strong> 的。</p>
<h2 id="Mock-概念"><a href="#Mock-概念" class="headerlink" title="Mock 概念"></a>Mock 概念</h2><p>所谓的 Mock 就是创建一个类的虚假的对象，在测试环境中，用来替换掉真实的对象，主要提供两大功能：</p>
<ul>
<li>验证这个对象的某些方法的调用情况，调用了多少次，参数是什么等等</li>
<li>指定这个对象的某些方法的行为，返回特定的值，或者是执行特定的动作</li>
</ul>
<p>要使用 Mock，一般需要用到 Mock 框架，这篇文章我们使用 Mockito 这个框架，这个是Java界使用最广泛的一个mock框架。</p>
<h2 id="在-Gradle-添加-Mockito-依赖"><a href="#在-Gradle-添加-Mockito-依赖" class="headerlink" title="在 Gradle 添加 Mockito 依赖"></a>在 Gradle 添加 Mockito 依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">repositories &#123; jcenter() &#125;</div><div class="line">dependencies &#123; testCompile &quot;org.mockito:mockito-core:1.+&quot; &#125;</div></pre></td></tr></table></figure>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>我们首先看一下官方的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//mock creation List</span></div><div class="line">mockedList = mock(List.class);</div><div class="line"><span class="comment">//using mock object - it does not throw any "unexpected interaction" exception</span></div><div class="line">mockedList.add(<span class="string">"one"</span>);</div><div class="line"><span class="comment">// selective, explicit, highly readable verification</span></div><div class="line">verify(mockedList).add(<span class="string">"one"</span>);</div></pre></td></tr></table></figure></p>
<p>一般使用 Mockito 需要执行下面三步:</p>
<ul>
<li>模拟并替换测试代码中外部依赖。</li>
<li>执行测试代码</li>
<li>验证测试代码是否被正确的执行</li>
</ul>
<p>创建 Mock 对象的方式：</p>
<ul>
<li>mock(toMockObject.class)</li>
<li>注解的方式 @Mock，注意要利用注解， 首先要告诉 Mockito 框架， 可以<code>@Rule public MockitoRule mockitoRule = MockitoJUnit.rule);</code> 或者它的实现<code>MockitoAnnotations.initMocks(target);</code></li>
</ul>
<h3 id="误区一"><a href="#误区一" class="headerlink" title="误区一"></a>误区一</h3><p>上面的例子我们进行修改 ==&gt; 为不同于上面的地方，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//mock creation List</span></div><div class="line">mock(List.class);</div><div class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="comment">//using mock object - it does not throw any "unexpected interaction" exception</span></div><div class="line">list.add(<span class="string">"one"</span>);</div><div class="line"><span class="comment">// selective, explicit, highly readable verification</span></div><div class="line">verify(list).add(<span class="string">"one"</span>);</div></pre></td></tr></table></figure></p>
<p>运行发现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">org.mockito.exceptions.misusing.NotAMockException: </div><div class="line">Argument passed to verify() is of type ArrayList and is not a mock!</div><div class="line">Make sure you place the parenthesis correctly!</div><div class="line">See the examples of correct verifications:</div><div class="line">verify(mock).someMethod();</div><div class="line">verify(mock, times(10)).someMethod();</div><div class="line">verify(mock, atLeastOnce()).someMethod();</div></pre></td></tr></table></figure>
<p>这就是mock的误区一：<br><strong>Mockito.mock()并不是mock一整个类，而是根据传进去的一个类，mock出属于这个类的一个对象，并且返回这个mock对象；而传进去的这个类本身并没有改变，用这个类new出来的对象也没有受到任何改变！</strong></p>
<p>结合上面的例子，Mockito.mock(ArrayList.class);只是返回了一个属于ArrayList这个类的一个mock对象。ArrayList这个类本身没有受到任何影响，而 list 不是一个mock对象。Mockito.verify()的参数必须是mock对象，也就是说，Mockito只能验证mock对象的方法调用情况。因此，上面那种写法就出错了。</p>
<h3 id="误区二"><a href="#误区二" class="headerlink" title="误区二"></a>误区二</h3><p>我们先看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> UserLoginTask mAuthTask;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</div><div class="line">        mAuthTask = <span class="keyword">new</span> UserLoginTask(email, password);</div><div class="line">        </div><div class="line">        <span class="comment">//执行登录操作</span></div><div class="line">        mAuthTask.execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面是一个登录操作， 现在我们来验证 login() 函数， 因为它没有返回值，这时候我们只要验证 execute() 有没有执行就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    UserLoginTask mockLoginTask = mock(UserLoginTask.class);</div><div class="line">    LoginPresenter loginPresenter = <span class="keyword">new</span> LoginPresenter();</div><div class="line">    loginPresenter.login(<span class="string">"jason@gmail.com"</span>, <span class="string">"123456"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//验证是否执行 excute()</span></div><div class="line">    verify(mockLoginTask).excute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于 UserLoginTask 继承 AsyncTask， 所以会报错，同误区一中的问题一样（not  mock），这时候我们需要用到 Robolectric 框架，这个可以参考我<strong><a href="http://hujiandong.com/2016/05/20/android-unit-test/">以前写的</a></strong>。解决这个问题以后你会发现，fuck，怎么还有问题， 什么鬼。。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/mock_wanted.png" alt=""></p>
<p>mock的误区二：<br><strong>mock出来的对象并不会自动替换掉正式代码里面的对象，你必须要有某种方式把mock对象应用到正式代码里面。</strong></p>
<p>这个时候我们可以通过 构造方式将依赖传进去，就 OK 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> UserLoginTask mAuthTask; <span class="comment">//===&gt;</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginPresenter</span><span class="params">(UserLoginTask mAuthTask)</span> </span>&#123;</div><div class="line">        <span class="comment">//TODO test argument</span></div><div class="line">        <span class="comment">//执行登录操作</span></div><div class="line">        mAuthTask.execute(email, password);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改测试用例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">…</div><div class="line">LoginPresenter loginPresenter = new LoginPresenter(mockLonginTask); //==&gt;</div></pre></td></tr></table></figure></p>
<p>运行发现终于成功了， 不容易。。</p>
<h3 id="验证方法调用及参数"><a href="#验证方法调用及参数" class="headerlink" title="验证方法调用及参数"></a>验证方法调用及参数</h3><p>使用Mockito，验证一个对象的方法调用情况：<br>Mockito.verify(objectToVerify).methodToVerify(arguments);<br>其中 objectToVerify 和 methodToVerify 对应上面的 mockedList 和 add，表示验证 mockedList 的 add 方法是否传入参数是 one。</p>
<p>很多时候你并不关心被调用方法的参数具体是什么，或者是你也不知道，你只关心这个方法得到调用了就行。这种情况下，Mockito 提供了一系列的 any 方法，来表示任何的参数都行。</p>
<p>anyString() 表示任何一个字符串都可以。类似 anyString，还有 anyInt, anyLong, anyDouble 等等。anyObject 表示任何对象，any(clazz) 表示任何属于clazz的对象。 举个栗子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   <span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDoGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	Http http = spy(<span class="keyword">new</span> Http(<span class="number">5000</span>, <span class="number">5000</span>));</div><div class="line">	URL url = createUrlConnection();</div><div class="line">	http.doGet(url, ContentType.HTML.str);</div><div class="line">	verify(http).createHttpUrlConnection(any(URL.class), any(Http.Method.class), anyString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="指定-Mock-对象的某些方法的行为"><a href="#指定-Mock-对象的某些方法的行为" class="headerlink" title="指定 Mock 对象的某些方法的行为"></a>指定 Mock 对象的某些方法的行为</h3><p>那么接下来，我们就来介绍 Mock 的第二大作用，先介绍其中的第一点：指定 Mock 对象的某个方法返回特定的值。<br>我们见面的 login() 进行修改， 添加对网络的判断， 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</div><div class="line">    <span class="comment">//TODO test argument</span></div><div class="line">    <span class="keyword">if</span>(!NetManager.isConnected()) &#123; <span class="comment">//添加网络判断===&gt;</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//执行登录操作</span></div><div class="line">    mAuthTask.execute(email, password);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NetManagerWraper netManagerWraper = mock(NetManagerWraper.class); <span class="comment">//==&gt;</span></div><div class="line">when(netManagerWraper.isConnected()).thenReturn(<span class="keyword">false</span>); ==&gt;</div></pre></td></tr></table></figure></p>
<p>下面我们说说怎么样指定一个方法执行特定的动作，这个功能一般是用在目标的方法是 void 类型的时候。<br>现在假设我们的 LoginPresenter 的 login() 方法是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行登录操作, 并且处理网络返回</span></div><div class="line">mAuthTask.execute(email, password, <span class="keyword">new</span> NetworkCallBack() &#123;</div><div class="line">                         <span class="meta">@Override</span></div><div class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object data)</span> </span>&#123;</div><div class="line"></div><div class="line">                         &#125;</div><div class="line"></div><div class="line">                         <span class="meta">@Override</span></div><div class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>&#123;</div><div class="line"></div><div class="line">                         &#125;</div><div class="line">                         &#125;);</div></pre></td></tr></table></figure></p>
<p>我们想进一步测试传给 NetworkCallback 里面的代码，验证 view 得到了更新等等。在测试环境下，我们并不想依赖 excute 的真实逻辑，而是让 mAuthTask<br>直接调用传入的 NetworkCallback 的 onSuccess 或 onFailed 方法。这种指定 Mock 对象执行特定的动作的写法如下：<br>`Mockito.doAnswer(desiredAnswer).when(mockObject).targetMethod(args);<br>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">doAnswer(<span class="keyword">new</span> Answer() &#123;</div><div class="line">             <span class="meta">@Override</span></div><div class="line">             <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">             <span class="comment">//这里可以获得传给performLogin的参数</span></div><div class="line">             Object[] arguments = invocation.getArguments();</div><div class="line"></div><div class="line">             <span class="comment">//callback是第三个参数</span></div><div class="line">             NetworkCallBack callback = (NetworkCallBack) arguments[<span class="number">2</span>];</div><div class="line"></div><div class="line">             callback.onSuccess(<span class="keyword">null</span>);</div><div class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">             &#125;</div><div class="line">             &#125;).when(mockLonginTask).execute(anyString(), anyString(), any(NetworkCallBack.class));</div></pre></td></tr></table></figure>
<p>我们想在调用某些无返回值函数的时候抛出异常，那么可以使用 doThrow 方法。如果想简单的指定目标方法“什么都不做”，那么可以使用 Mockito.doNothing()。如果你想让目标方法调用真实的逻辑，可以使用 Mockito.doCallRealMethod()（默认不是的， 请看下文）。</p>
<h2 id="Spy"><a href="#Spy" class="headerlink" title="Spy"></a>Spy</h2><p>如果我们不指定 Mock 对象方法的行为， 那么他是不是走真实逻辑呢？ 答案是否定的。如果没我们不指定它的行为，对于 Mock 对象的所有非 void 方法都将返回默认值 int，long 类型方法将返回0，boolean 方法将返回 false，对象方法将返回 null 等等；而 void 方法将什么都不做。</p>
<p>然而很多时候，你希望达到这样的效果：除非指定，否者调用这个对象的默认实现，同时又能拥有验证方法调用的功能。这正好是 spy 对象所能实现的效果。<br>创建Spy方式：</p>
<ul>
<li>Mockito.spy(toMockObject);</li>
<li>通过注解的方式@Spy</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpy</span><span class="params">()</span> </span>&#123;</div><div class="line">    NetManagerWraper spy = spy(<span class="keyword">new</span> NetManagerWraper());</div><div class="line">    assertTrue(spy.isConnected());</div><div class="line">    when(spy.isConnected()).thenReturn(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>spy 与 mock 的唯一区别就是默认行为不一样： spy 对象的方法默认调用真实的逻辑，mock 对象的方法默认什么都不做，或直接返回默认值。</strong></p>
<h2 id="Mockito-Annotation"><a href="#Mockito-Annotation" class="headerlink" title="Mockito Annotation"></a>Mockito Annotation</h2><p>通过 Mockito 注解可以快速创建 Mock 对象， 这样对于我们这样的懒人来说，是不是很爽。 上面我也简单提到了， 我们可以通过 mock() 和 @Mock 创建， @Mock 就是通过注解的方式创建的， 由于我们使用注解， 当然我们要告诉 Mockito 框架， 不然它怎样知道你使用注解了， 难道它是神吗？ 加上@Rule 就行了， 这样JUnit Rule（？）就会每个测试方法测试前进行检查。添加方法：<code>@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();</code>， 当然创建 spy 对象也可以加 @Spy。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上面的就是 Mockito 的基本使用， 当然由于并不是很全，更全面的可以看<strong><a href="http://www.vogella.com/tutorials/Mockito/article.html" target="_blank" rel="external">这里</a></strong>。基本的概念都有了， 下面的就是多用， 在项目中发现问题， 然后带着问题去查看文档。 Android 下还可以用 Dagger 动态依赖框架进行测试， 由于涉及到 Dagger 框架的使用，这个我们可以单独来说， 前提是你知道 Dagger 怎样用。</p>
<p>上面代码在 <strong><a href="https://github.com/jasonim/JasonAndroidSimple/tree/master/mocksample" target="_blank" rel="external">Github</a> 上</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.vogella.com/tutorials/Mockito/article.html" target="_blank" rel="external">http://www.vogella.com/tutorials/Mockito/article.html</a></p>
<p><a href="http://chriszou.com/2016/04/29/android-unit-testing-mockito.html" target="_blank" rel="external">http://chriszou.com/2016/04/29/android-unit-testing-mockito.html</a></p>
<p><a href="https://medium.com/square-corner-blog/mockito-on-android-88f84656910" target="_blank" rel="external">https://medium.com/square-corner-blog/mockito-on-android-88f84656910</a></p>
]]></content>
    
    <summary type="html">
    
      Android 单元测试--Mock及Mockito
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
      <category term="单元测试" scheme="http://hujiandong.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android常用的开源项目及其比较系列-序列化篇</title>
    <link href="http://hujiandong.com/2016/11/07/android-open-source-serial/"/>
    <id>http://hujiandong.com/2016/11/07/android-open-source-serial/</id>
    <published>2016-11-07T08:48:27.000Z</published>
    <updated>2016-11-07T08:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进入今天的主题之前我们来说一下当下比较火的话题， 一个AR类游戏刷爆国外网络社交平台？是的，它就是<strong>Pokemon Go</strong>，中文意思就是皮卡丘；一个抓精灵手游，通过你的位置信息，根据不同场景的显示不同精灵。不过可惜国内没有开服，听说东北一些地区可以玩。本来不怎么关注游戏的， 也荡起涟漪想体验体验。另一个就是和电影明星赵薇相关的，大家都称“赵薇事件”，一个微博电影宣传照引发的事件。事情刚开始时本来想写一点对此事一些看法的，但还没来得及写，整个事情就像我想想的方向发展了。你猜猜还会不会再次反转，你们还是洗洗睡吧；所以你会发现有些东西不一定是我们看到的， 特别是涉及到政治相关的。</p>
<h1 id="动态注入"><a href="#动态注入" class="headerlink" title="动态注入"></a>动态注入</h1><h2 id="AndroidAnnotations"><a href="#AndroidAnnotations" class="headerlink" title="AndroidAnnotations"></a>AndroidAnnotations</h2><h2 id="butterknife"><a href="#butterknife" class="headerlink" title="butterknife"></a>butterknife</h2><h2 id="Dagger"><a href="#Dagger" class="headerlink" title="Dagger"></a>Dagger</h2><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="Jackjson"><a href="#Jackjson" class="headerlink" title="Jackjson"></a>Jackjson</h2><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2>]]></content>
    
    <summary type="html">
    
      介绍常用的序列化框架和注解框架
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
      <category term="开源项目" scheme="http://hujiandong.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Android Log打印的正确姿势</title>
    <link href="http://hujiandong.com/2016/11/07/android-log-used/"/>
    <id>http://hujiandong.com/2016/11/07/android-log-used/</id>
    <published>2016-11-07T08:48:27.000Z</published>
    <updated>2016-11-07T08:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家对输出Log肯定不陌生吧， 任何语言任何程序都少不了Log读出， 程序交付前我们可以用它来调试code， 交付后我们可以用它来排除问题。记得当时用C写程序时，我们经常唱“print 大法好哎！print 大法好哎！print 大法好哎！”</p>
<p>Log 的输出是耗时的， 正确的Log打印可以提供工作效率，反之会带来副作用，所以要善用Log打印。有人把程序员分为五类，你可能多多少少有它们中一类或多类的影子。</p>
<blockquote>
<ul>
<li>IDD（IDE-Driven Development），也就是IDE驱动开发，几乎是初学者进入软件开发的殿堂的必经之路。IDE开发者屏蔽了很多细节，并且几乎不用配置（相对于 vim / emacs / sublime）就可以使用代码自动补全，代码跳转，搜索，以及签入签出等软件开发中将会使用到的几乎所有工作。</li>
<li>DDD（Debugger-Driven Development）<br>DDD，面向调试器开发，是 IDD 依赖到一定程度的必然反应。这种开发模式的典型表现为：写出来的代码不知道对不对，从头到尾设置无数个断点，然后进入到调试模式，一个断点一个断点跟踪。发现一个问题，解决一个问题（也许引入一个新的问题），直到所有断点走数遍，所有遇到的问题被消灭，抹一抹头上的汗，心里骂上一句：妈的，这段代码老子（娘）终于调通了！</li>
<li>BDD（Bug-Driven Development）<br>看到 BDD，也就是问题单驱动开发，相信大家都相视一笑。本来这里我想用 TDD（Ticket-Driven Development），更接近我的原意，为了不和 Test-Driven Development 混淆，故而只好改成 BDD。这可能是我们最熟悉的开发模式了 —— 在一个业务稳定的软件公司（甭管规模大小），勉力维护现有的代码，小心地添加新功能是多数程序员的主要职责。在这些公司里，与其说我们是工程师，不如说我们是补锅匠。看不懂代码？没关系，只要你会读日志（出错信息）；解决不了问题？不打紧，能找到 workaround 把问题绕过去也可以，更有甚者，遇到神问题，看不懂，想不明，解不了，还没有 workaround，大笔一挥：not reproducible，就把问题关了，几个月半年后，说不定自己已经去补别的锅了。</li>
<li>RDD（Rat-race-game-Driven Development）<br>RDD，老鼠赛跑驱动的开发，是指那些整个职业生涯都在原地打转的开发模式。Rat race game 是『富爸爸穷爸爸』中的经典例子 —— 老鼠在环形的笼子里拼命地奔跑。</li>
</ul>
</blockquote>
<p>如想了解更多， 请参见<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=402343575&amp;idx=1&amp;sn=cf5bd19b7eb979c0904692475c5f997d&amp;scene=0#wechat_redirect" target="_blank" rel="external">原文</a>, 看看作者怎么分析每类人的， 你值得拥有。 </p>
<p>好了， 来说说Android的Log打印的一些方法和技巧，为了简单起见，下文中AS就是Android Studio的缩写。</p>
<h1 id="善用adb-logcat"><a href="#善用adb-logcat" class="headerlink" title="善用adb logcat"></a>善用adb logcat</h1><p>我看到有些测试人员为了，看程序的Log， 还特意装一个AS。有时候想问为什么不用adb logcat，难道是没有linux下的shell命令吗， 好吧， 被你的无邪打败了。</p>
<p>有时候我们要看一个Java层的奔溃，我仅仅需要下面命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">adb logcat | grep -i &quot;system.err&quot;</div></pre></td></tr></table></figure>
<p>想看看别的，使用process输出格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">adb logcat -v process</div></pre></td></tr></table></figure>
<h1 id="AS-使用技巧"><a href="#AS-使用技巧" class="headerlink" title="AS 使用技巧"></a>AS 使用技巧</h1><p>AS提供了很多的模板功能, 自己也可以根据情况自己定义：</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/live-template.png" alt="template设置"></p>
<p>自动填写Tag、方法名和返回值：</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/log.gif" alt=""></p>
<h1 id="动态设置值"><a href="#动态设置值" class="headerlink" title="动态设置值"></a>动态设置值</h1><p>你在调试时会不也遇到这样的情况，为了进入不同分支，最笨的办法是每次都有修改一下条件变量的代码， 然后重新编译运行。现在我们可以利用debug的setValue(Mac F2)方法动态设置值, 下面代码 变量b 开始等于0， 正常情况下会进入catch条件; 现在我将它修改为2， 它就不会进入catch条件了。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/setvalue.gif" alt=""> </p>
<h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><p>你可以用第三方库（<a href="https://github.com/orhanobut/logger" target="_blank" rel="external">logger</a>、<a href="https://github.com/pengwei1024/LogUtils" target="_blank" rel="external">LogUtils</a>、<a href="https://github.com/JakeWharton/timber" target="_blank" rel="external">timber</a>）或自己改造log框架， 让打印更美观。</p>
<p><img src="http://7xnilf.com1.z0.glb.clouddn.com/logger-log.png" alt="Logger效果图"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一万个人心中有一万个丘比特，所有找到一个自己适合的打印方式。</p>
<p><strong>希望大家使用愉快！</strong></p>
]]></content>
    
    <summary type="html">
    
      Android Log打印的正确姿势
    
    </summary>
    
      <category term="Android" scheme="http://hujiandong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://hujiandong.com/tags/Android/"/>
    
  </entry>
  
</feed>
