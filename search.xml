<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F04%2F15%2Fcommunity-talk%2F</url>
      <content type="text"><![CDATA[在上篇七年后你还是你吗中我是这样说的：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七年后你还是你吗]]></title>
      <url>%2F2017%2F03%2F27%2Fseven-year-later%2F</url>
      <content type="text"><![CDATA[李笑来老师说七年就是一辈子，我不知道他为什么这么说，可能七年时间足够能改变一个人一辈子的命运。 七年前的我还没大学毕业，坐着学校门口的旁边小店里，吃着水煮鱼喝着啤酒，同学们之间相互吹着牛皮。记得刚毕业的时候给自己定一个大目标和几个小目标— 给自己五年时间，寻找自己，自己能不能在这个行业站住脚。 五年时间很快过去， 获得答案也是肯定的，基本上按照当初设定目标来的，二十四岁结婚、二十五岁置业、二十七岁生子等，其实目的只有一个，在三十而立之年时能腾出更多精力做更有意义的事情。 可能有些人和我的观点不一样， 他认为出名要趁早，结婚生子可以往后排。如果你背景好或者天赋异禀或者才能出众再或者可以靠脸吃饭，那么什么时候都不晚。我是上述条件都没有， 你告诉我等等吧，等来的只会是失望和更高的房价。而立之年后还为结婚生子浪费精力， 个人认为不值。当然前提是你要有个靠谱的女（男）朋友，这个需要你个人判断，判断标准就是要为我们做的事情负责，这点很重要，特别当你是个男人的时候。 当然这中间也暴露一些问题， 走了一些弯路。13年底由于没有找到方向，又捡起大一玩的 DOTA ， 下班除了游戏就是 NBA，这样的状态一直持续到 14年年中，因为无意间在播客的上听了一堂创业课， 现在也记不得是谁讲的， 那时候听到最多的话就是『在风口上，猪都能飞起来』。 当时被这种情绪点燃， 整天就涮投资圈， 今天 XX 融了多少钱明天又一个 XX 又融多少。然后就看他们的公司背景、老板背景和项目背景， 想想是不是能够复制。整天把刚看到的东西，不带思考的转诉给他人，博得他人的认同感。 现在只想对那时的自己说: 嗨， 你真是个大傻叉，你以为你看到就是自己的吗 那时说的多，做的少，就是个“嘴炮”。也没有把注意放在自己成长上，就像笑来老师说的： 很多人总在说“懂得那么多道理，却依然过不好一生”。其实，你在当下知道这个道理，和面临选择时依然想得起这个道理是不一样的。 现在又进入以罗振宇为首的内容卖家宣扬的知识学习， 已经恐慌了一大批人，很多人像无头苍蝇一样到处付费，到头来却一无所获。我也是其中一员。这其中有一大部分原因： 没有找到优质的资源对接，网上的垃圾信息和粗制滥造的付费内容太多。 没有一个优质的推荐平台，要不然那么多付费内容，新手进入的时候怎么选择。 其实看完牛人的东西，看到刷新甚至颠覆三观的文字，我们要做的不是直接将这些思想刻进脑子，而是去用自己的话去梳理一遍， 梳理其中的逻辑，用文字记录下来， 不断打磨，让我们真正在选择的时候用的上。 不断问自己，自己在阅读时有哪些「认知习惯」是需要注意的？哪些需要改掉的阅读“原罪”，我们要做的第一件事不是去积累多少知识，开阔多广的视野，而是要把这个与生俱来的缺陷克服，即使不能时时刻刻都克服，也要有意识的去抵消其影响。 同样我们的另一个陷阱是无目的的学习，没有一个战略上的目标，任何战术上的胜利都会最终被时间耗散成一团散沙。安兰德说过: 当你说我爱你的时候，你要明白你有我吗？只有有我的人才有权利说爱别人。 这句话的意思是如果爱只是被本能驱使，你不可能是“我”，你是随便一个人。如果你说你爱知识，爱学习，却不清楚自己学习的长远目标，那么不是你在学习，是你在表演学习这种行为艺术给自己看，给朋友圈看，就是我们通常说的“假学习”， 寻求自嗨。 反思发现自己以前做那些事情， 其实就是「自嗨」行为， 以后也要调整， 考虑「他嗨」，当然这件事件，需要极强的能力，我会用接下来的七年时间不断打磨。 以前一直有一个误区，做出好的产品，写出感动自己的代码，才是王道。其实根据个人实际情况，对自己很难。为什么不从用户需求做起，深挖周边资源，真正解决部分用户需求。这也是下一步我主要要学要做的事情。 七年后我37岁，也将到达不惑之年，活着或生活以及我将变成什么样？更好的自己还是更坏的自己？是否还在北京？ 这些其实都不知道。唯独能做的就是用心写作，用心做事，做对别人有用的事，从而实现个人价值。但是有一点是肯定的就是回归家庭， 多陪陪家人。那时小硕硕九岁，大概上小学三、四年级，多带他去看看远方，看看世界，他的人生才刚刚开始，希望能用我的行动去影响他。 把更多的注意力放在做事上面，尽快摆脱现在出售时间这种不划算的事情上面， 让自己有更多话语权。 七年后你还是你吗？ 希望自己还能保持一颗初心，一颗不断学习的初心，真正实现做自己，让身边的家人和朋友更好。未来不可期，与君共勉！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android正确的Log打印姿势—中级篇]]></title>
      <url>%2F2017%2F03%2F24%2Fandroid-log-used-debug%2F</url>
      <content type="text"><![CDATA[以前写过Android Log打印的正确姿势， 今天我们来谈谈怎么控制 Log 的输出? 第一种：自定义常量， 例如将配置文件放到 asset 下，里面配置是否需要打开 log，Debug 设为 true，Release 设为 false。 第二种：通过 Log.isLogable 去判断，每次需要手动开启。 第三种：Gradle 中 BuildConfig.DEBUG 判断是否是 Debug 模式， 从而做到一些在 Debug 模式下开启， 这样好处是不用再发布前去主动修改。 第一种类似最原始的方式，每次生产环境和开发环境下切换，容易出错，另外在给其他模块提供服务时也不会通用。人类是个不靠谱的东西，机器才是我们目前为止更应该相信的。例如我们经常说的： 作为研发不要相信产品、作为测试不要相信研发、作为运维谁都不要相信、作为产品谁都不要相信… 今天我们就不讨论第一种模式，着重说说第二种和第三种情况， 并讨论他们的优缺点。 第二种 Log.isLoagable直接上代码： 123456789101112131415161718public class LogUtils &#123; private static final int LEVEL = Log.DEBUG; private static boolean isDebug(String tag, int level) &#123; return level &gt;= LEVEL &amp;&amp; Log.isLaggable(tag, level); &#125; public static void println(String tag, int level, String msg) &#123; if (isDebug(level)) &#123; Log.println(level, tag, msg); &#125; &#125; public static void d(String tag, String msg) &#123; println(tag, Log.DEBUG, msg); &#125;&#125; 上面的代码主要作用，判断当前 level 是否大于 Log.DEBUG 并且判断 Log.isLoggable() 是否为 true，如果条件成立调用 println()。最后问题就回归到怎么通过改变 isLoggable() 状态呢？ 最后我们发现可以通过 adb shell 进行设置，方法如下： adb shell setprop log.tag.MYTAG D 第三种 BuildConfig.DEBUG我们直到 Debug 模式下 BuildConfig.DEBUG 会始终为 true。我们将上面的代码改造一下， 只需要修改 isDubug(）函数：123private static boolean isDebug(int level) &#123; retrun level &gt;= LEVEL &amp;&amp; BuildConfig.DEBUG;&#125; 实际开发中我们一般将 LogUtils 放到 Utils Module 中， 而不是放到 app Module 里， 我们会发现 BuildConfig.DEBUG 永远为 false。 Why？ 难道遇到假的系统吗？ WHY原来 BUildConfig.java 是编译时自动生成的， 每个 Module 都会自己生成一份。所以如果你的应用拥有多个 Module 就会有多个 BuildConfig.java, 而上面的 LogUtils 被放到 Utils, 而 app Module 又依赖 Utils，编译时被依赖的 Utils Module 默认会提供 Release 版给其他 Module 或 工程，这就导致该 BuildConfig.DEBUG 会始终为 false。那么如何解决了？ HOW为了解决上面的问题，我们反编译 Debug 包和 Release 包发现，在AndroidManifest.xml 中 application 节点的 android:debuggable 值是不同的。Debug 版本值为 true，Release 版本值为 false。所以我们可以通过 ApplicationInfo 的这个属性来判断是否是 Debug 版本，代码如下：1234567891011121314public class AppUtils &#123; private static Boolean isDebug = false; public static boolean isDebug() &#123; return isDebug == null ? false : isDebug; &#125; public static void debugMode(Context context) &#123; if (isDebug == null) &#123; isDebug = context.getApplicationInfo() != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; &#125; &#125;&#125; 在自己的 Application 内调用： AppUtils.debugMode(getApplicationContext()); 修改 LogUtils 的 isDubug() : 123private static boolean isDebug(int level) &#123; return level &gt;= LEVEL &amp;&amp; AppUtils.isDebug();&#125; 好了， 这样就解决上面的问题了。注意：上面的解决方案，不能再 app Module 中主动设置 android:debuggable, 否则无论 Debug 还是 Release 版会始终是设置的值。 优缺点第二种优点： 不用手动修改， 从而减少出错的概率 灵活，能在 Release 也能动态控制输出结果 缺点： 当我们重启手机以后上面的设置就不会起作用了，每次重启需要重新设置 第三种优点： 不用手动修改， 从而减少出错的概率缺点： 不够灵活，不能在 Release 也能动态控制输出结果 写在最后上面的方案可以根据开发中的使用场景来确定，没有最好，只有更好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你了解泛型通配符与上下界吗？]]></title>
      <url>%2F2017%2F03%2F11%2Fjava_generices_bounded%2F</url>
      <content type="text"><![CDATA[你了解泛型通配符与上下界吗？在进入主题之前， 我们先简单说一下 Java 的泛型（generics）。它是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。 今天我们主要说如下类型： 泛型的背景 通配符以及上下界 泛型及通配符的使用场景 为什么使用泛型及背后的问题？我们来看一下官方的说法： Stronger type checks at compile time. A Java compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find. Elimination of casts. Enabling programmers to implement generic algorithms. By using generics, programmers can implement generic algorithms that work on collections of different types, can be customized, and are type safe and easier to read. 是的， 终止目的就是想把程序员解放出来，关注他们更应该关注的事情上面去。当我第一次学习 Java 的泛型时，总感觉它类似于 C++ 中的模板。但随着慢慢的深入了解发现它们之间有本质的区别。 Java 中的泛型基本上完全在编译器中实现，由编译器执行类型检查和类型推断，然后生成普通的非泛型的字节码。这种实现技术称为 擦除（erasure）（编译器使用泛型类型信息保证类型安全，然后在生成字节码之前将其清除），这项技术有一些奇怪，并且有时会带来一些令人迷惑的后果。 对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面来说，上面已经说了，主要是在编译时刻就能发现很多明显的错误。而从不好的地方来说，主要是为了保证与旧有版本的兼容性，Java 泛型的实现上存在着一些不够优雅的地方。 下面我们来看一下，泛型类型的一个定义，后面我们要在这个的基础上进行改造：12345678public class Box&lt;T&gt; &#123; // T stands for "Type" private T t; public Box(T t) ￼ ￼&#123; this.t = t;￼ &#125;￼ public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; 接下来下面我们来聊聊 Java 泛型的通配符， 记得刚开始看到通配符（？）时我是惊喜的，因为既然有通配符那么就可以这样定义：123public void doSometing(List&lt;?&gt; list) &#123; list.add(1); //illegal&#125; 可是我们如上写法，总是出现编译错误，然后从惊喜变成惊吓，心想有什么卵用了。最后发现原因是在于通配符的表示的类型是未知的。那在这种情况下，我们可以使用上下界来限制未知类型的范围。好吧，写了那么多， 终于等到今天的主角登场了，容易吗？ 还记得我们上面定义的 Box 吗， 现在我们再定义 Fruit 类以及它的子类 Orange 类。12class Fruit &#123; &#125;class Orange extends Fruit &#123;&#125; 现在我们想它里面能装水果，那么我可以这么写。Box&lt;Fruit&gt; box = new Box&lt;Orange&gt;(new Orange()) //illegal 不幸的是编译器会报错，这就尴尬了，why？why？ why？实际上，编译器认为的容器之间没有继承关系。所以我们不能这样做。 为了解决这样的问题， 大神们想出来了&lt;? extens T&gt; 和 &lt;? super T&gt; 的办法，来让它们之间发生关系。 上界通配符（Upper Bounded Wildcards）现在我们把上面的 Box 定义改成：Box&lt;? extends Fruit&gt; 这就是上界通配符， 这样 Box 及它的子类如 Box 就可以赋值了。Box&lt;? extends Fruit&gt; box = new Box&lt;Orange&gt;(new Orange) 当我们扩展一下上面的类， 食物分成为水果和蔬菜类， 水果有苹果和橘子。在上面的结构中， Box&lt;? extends Fruit&gt; 涵盖下面的蓝色的区域。 上界只能外围取，不能往里放我们先看一下下面的例子：12345678910Box&lt;? extends Fruit&gt; box = new Box&lt;Orange&gt;(new Orange);//不能存入任何元素box.set(new Fruit); //illegalbox.set(new Orange);//illegal//取出来的东西只能存放在Fruit或它的基类里Fruit fruit = box.get();Object fruit1 = box.get();Orange fruit2 = box.get(); //illegal 上面的注释已经很清楚了， 往 Box 里放东西的 set() 方法失效， 但是 get() 方法有效。 原因是 Java 编译器只知道容器内是 Fruit 或者它的派生类， 但是不知道是什么类型。可能是 Fruit、 可能是 Orange、可能是Apple？当编译器在看到 box 用 Box 赋值后， 它就把容器里表上占位符 “AAA” 而不是 “水果”等，当在插入时编译器不能匹配到这个占位符，所有就会出错。 下界通配符（Lower Bounded Wildcards）和上界相对的就是下界 ，语法表示为：&lt;? super T&gt; 表达的相反的概率：一个能放水果及一切水果基类的 Box。 对应上界的那种图， 下图 Box&lt;? super Fruit&gt; 覆盖黄色区域。 下界不影响往里存，但往外取只能放在Object 对象里同上界的规则相反，下界不影响往里存，但往外取只能放在Object 对象里。 因为下界规定元素的最小的粒度，实际上是容器的元素的类型控制。所以放比 Fruit 粒度小的如 Orange、Apple 都行， 但往外取时， 只有所有类的基类Object对象才能装下。但是这样的话，元素的类型信息就全部消失了。 写在最后使用场景在使用泛型的时候可以遵循一些基本的原则，从而避免一些常见的问题。 在代码中避免泛型类和原始类型的混用。比如 List 和 List 不应该共同使用。这样会产生一些编译器警告和潜在的运行时异常。当需要利用 JDK 5 之前开发的遗留代码，而不得不这么做时，也尽可能的隔离相关的代码。 在使用带通配符的泛型类的时候，需要明确通配符所代表的一组类型的概念。由于具体的类型是未知的，很多操作是不允许的。 泛型类最好不要同数组一块使用。你只能创建 new List&lt;?&gt;[10] 这样的数组，无法创建 new List[10] 这样的。这限制了数组的使用能力，而且会带来很多费解的问题。因此，当需要类似数组的功能时候，使用集合类即可。 不要忽视编译器给出的警告信息。 PECS 原则如果要从集合中读取类型T的数据， 并且不能写入，可以使用 上界通配符（&lt;？extends&gt;）—Producer Extends。 如果要从集合中写入类型T 的数据， 并且不需要读取，可以使用下界通配符（&lt;? super&gt;）—Consumer Super。 如果既要存又要取， 那么就不要使用任何通配符。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编写可读代码的艺术]]></title>
      <url>%2F2017%2F02%2F22%2Freadable-code%2F</url>
      <content type="text"><![CDATA[刚毕业的时候读过 Bob 大叔的《Clean Code》， 那时候只是被动接受，没有进行更有效的思考，现在也忘记的差不多了。记得在进行公司培训时一部分内容就是代码规范和公司常用的推荐写法，当时也不知道为什么这样子做， 老大告诉我们，这就是团队做出的决定，喜欢不喜欢照做就是。 开发中我们不可避免的要阅读别人代码，一般会出现两种场景： 哇，这块代码写的太棒了， 结构简单、逻辑清晰。 艹，这代码写的一坨坨的，也不知道他在表达什么，写的人是不是当时脑袋被门挤压后写下的代码。 我们当然不想成为第二种，那什么样的代码符合可读性的特质？ 可读性 == 可测试 == 代码质量 == 代码优雅 是的， 它们自己是等价的 这本书译版不过170多页很薄，通过漫画的形式展示每个主题，幽默合理，直指问题要害，阅读起来很有趣，有图有真相。主要分四大部分： 表面层次的改进 简化循环和逻辑 重新组织代码 测试与可维护 表面层次的改进谈到如何命名？ 避免使用专业词汇。 避免空泛的名字。 为作用域大的名字采用更长的名字 如何添加注释？ 不要为了写注释而写注释 不要给不好的名字加注释—应该改进命名和重构 为代码中的瑕疵写注释：这里单独提一下 HACK（以前没有注意过）—-对一个问题不得采取的粗糙解决方案 简化循环和逻辑文中提到条件语句中参数的顺序、告诉我们可以通过重新排列 if/else 语句中的语句块。通常来讲，先处理正确的/简单的/有趣的情况。有时候这些准则会冲突，但是当不冲突时， 这是要遵循的经验法则。 通常来讲提早返回可以减少嵌套并让代码整洁。 一个简单的技术是引入「解释变量」来代表较长的子表达。这种方式有三个好处： 它把巨大的表达拆成小段 它通过用简单的名字描述子表达式来让代码文档化 它帮助读者识别代码中的主要概率 重新组织代码文中提到「抽取不相关的子问题」和 Martin Fowler 在中《重构》描述的重构的「抽取方法」相似，而他写的更为详细， 感兴趣的可以去读读。 如何可以少写代码 从项目中消除不必要的功能，不要过度设计。 重新考虑需求，解决版本最简单的问题，只有能完成工作就行。 经常性的通读标准库的整个 API，保持对它们的熟悉程度。 测试与可维护文中提到，在测试代码中，可读性也很重要。如果测试的代码可读性好，其结果是它们会变得很容易些， 因此大家会更多的测试。并且，如果你把真实代码设计的容易测试，代码整个设计会变得更好。 以下是如果改进测试的几个具体要点： 每个测试的最高一层应该越简洁越好。最好每个测试的输入/输出可以用一行代码来描述。 如果测试失败了， 它所发出来的错误消息应该能让你容易跟踪并修正这个 bug。 使用最简单的并且能够完整的运用代码的测试输入。 给测试函数取一个完整的描述性的名字，以使每个测试所测到的东西很明确。 作者也提到测试走的太远的情况： 牺牲真实代码的可读性，只是为了使用测试 着迷于100%的 测试覆盖率 让测试成为产品开发的阻碍 思维导图![][http://sonicwu.com/statics/images/the-art-of-readable-code-m.jpg])就想本书的名字一样，艺术这个东西本来就是每个人鉴别的方式不一样，但是称得上艺术的东西， 一定符合艺术评断标准的。 编码规范这种事情，本来都是有主观有客观的。 像字节编码、换行、命名之类的事情就是主观的，在公司团队开发中就应该硬性统一，以便协作流畅。 最近阿里巴巴发布一个Java 编码规范—《阿里巴巴Java开发手册（正式版）》，设计编码的方方面面，有兴趣的同学可以看一下。 我也大致撸了一遍， 文档本身没有太大问题，不过，在网页、Github 高度发达的今天，为什么阿里没有选择将它放在网页上，而是用 PDF 的形式发布？为什么不做成类似： Google Java Style Guide[https://google.github.io/styleguide/javaguide.html] 有人说，编码规范这种东西就是体现「码农」和「工程师」本质区别的地方。 知乎上有个相关的问题「如何写出优雅的代码？」，我很赞同下面的回答： 多写，写的少的说啥都是空话。讲语法和应用的书一般培养不出所谓的「优雅」，不是作者水平不高的问题，是这样的书就应该务实，不扯淡。将编程美感的书，一般来说，如果写代码不够多，只是读书，毫无收益，只会害自己。所以还是要写。 其实什么样的代码是优雅的， 可读性好，可能也不过是自以为罢了。掌握一些基本的技巧就好了， 如果大家都严格遵循那些条条框框， 也不会有那么多不同语言和框架了。 最后所谓的代码优雅不过是程序员们用来自慰的工具罢了。爽于不爽只有自己知道。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[写给我心中的她]]></title>
      <url>%2F2017%2F02%2F14%2Fhappy-valentines-2017%2F</url>
      <content type="text"><![CDATA[一直想写一篇关于她的文章， 以前认为这是我们之间的事件， 不适合分享。反过来想，除了岁月我们还有诗和远方。 今天是情人节， 往年我都会在家附近买一支玫瑰送给她。而今年我早早的几天前我已经在网上预订定了一束，送到她的公司里去了。 我和她认识的时候， 我大二她大三，一个朋友介绍下我们在中秋节的晚上，我们见了面也吃了饭。当然我也知道， 像长成我这样， 肯定没几个女孩会看上我的。见面的结果可想而知—两个字「没戏」。不过爸妈从小教导我，遇到事件不要怕，要勇敢面对。 然后我就制定一套泡妞计划，其实也不是计划，一没钱、二没人。幸亏这时候「脸皮」同学出现了， 他说帮我在前面打前阵。就这样屡战屡败、屡败屡战情况， 终于在一个月后， 当然是我胜利了，不然我就再这里不写了。 有的童鞋会问， 他也给他喜欢的人打电话， 也发信息， 人家根本不 care， 咋办？给你们说一个朋友的真实例子，他当年追一个女孩的时候， 女孩不搭理他， 他就在她宿舍下面给他电话发信息说，他就在她们宿舍下面等她，如果不来，他每天都来， 直到她下来为止 。大约一周左右，那个女孩也就下来了。 我当然不是鼓励大家按照上面的方法去做， 只是想给我朋友说， 下次再遇到这样的事情， 请带上被子， 不然感冒了， 就没然后了。 像大部分大学情侣一样，我们就这样无忧无虑的交往着，因为我们不是一个学校， 除了周末在一块，平时也很少见面。当然我就有大部分时间，做我自己喜欢的事情， 打篮球、喝酒等等。 因为她们老家那边，有订婚的说法（后来知道这是为了告诉别人， 我们女儿已经找好， 都不要上门提亲了）， 我大三暑假的时候双方完成订婚，其实也很简单，一块吃了顿饭，买了一个戒指，给了1万1千礼金（那是2010年）。 快毕业我就来北京了，以前我再xxx提到，我的第一台笔记本电脑和在北京培训的钱有一部分是她友情赞助的。 找到工作以后， 过完年她辞职给我一块来北京了， 最开始我们租的房子住在回龙观东大街那边，八九平米左右的房间， 每天挤公交和地铁上班。她也很少买衣服和化妆品，夏天的衣服一般不会超过150。 虽然那时候没钱， 不过也没感觉很苦（至少我是这样认为的， 因为没有和她两个这个话题，也不知道她是不是和我的观点一样）。 因为我们也谈了四五年时间，双方父母也催着我们结婚。 我们当时订在同年十一举办婚礼， 原本想家里都准备好了，我们只是回去就可以了。哪只离结婚还有大概二三个月时间， 家里有点变动，希望我们旅游结婚， 不要回家办婚礼了， 过年回来以后双方再一块吃个饭就行了。 由于我在中间没处理好， 被她误解为，她结婚什么也没找你父母要，你父母结婚连回家都不让回，是不是瞧不起她？当时我也有点生父母的气，再给我打电话说让我们回去，我也赌气说不回去办婚礼了， 十一我们去青岛玩了一周， 就这样我们算结婚了。直到现在我的一些同学还以为我们回家办的婚礼了，因为最开始的时候说的是回家办。 现在回想起来只能说当时 「too young too die」， 为什么赌气呢？以前要是吵架，她就会说， 你家人结婚时怎么对我的？每次被问到， 太多的解释都是演示。 现在每被问到，如果结婚办婚礼还是旅游结婚时？我会说还是办场婚礼吧，谁心里苦谁知道，反正我挺苦的。 可能为了缓和结婚对她的伤害，还有就是需要同年12月左右的时候，我们开始看房子， 其实当时手里就是结婚家里给了一点钱， 大概几万块吧。记得当时北京的均价在一万七八左右吧，西边和南北还会更便宜一些， 由于当时限购政策的原因，看中一套房子没弄成事。然后又去了燕郊和固安看了看，可能去的时候太堵的原因， 当时也主要考虑自住，最终放弃那两个地方。 最后我把目标放到了我们上学的地方—郑州，毕竟那里有我们两个人的回忆，打了几个电话， 大致确定我们能承受的范围，就让我同学去那里交了定金选了房，事后才知道户型是置业帮忙选的。 其实这个价格当时已经超出我们预算了， 我当时其实想放弃的，想等等再买的。 记得那时还在上班，给她打电话时她说没事剩下的她来想办法。要不是她的这句话我也不会买，当时那套房子写的是她的名字。 怀孕的时候由于小孩早产， 她也遭了很多罪， 不管身体还是心理上都是。还好我们挺过来了，现在不真不想回想那段日子。 由于去年买房子时， 我们离了婚，但我们都知道那只是一个形式而已， 对我们没有实质性的改变。 你们也知道是睡了， 是的， 她就是我两任妻子，小孩的妈妈。 当我遇到事情的时候，她很少责备我， 总是鼓励我。说实话我为她做的事情也很少， 可能我不懂的爱情，也可能不懂的她要的爱。谢谢付出和不离不弃，我会尽里拼搏，直到感动自己的那一天到来为止。 喜欢你是件很骄傲的事情，不是秘密。 在今天这个特殊的日子， 她并没有关注我的公众号，也不是特意给她看的。写这些只是回忆我们匆匆走过的时光。可能还有很多男男女女，如果你还单身， 请想办法脱单；如果你有伴侣，请相互珍惜，可能眼下的路并不好走， 只要认真坚持，未来一定是你们的。 最后，祝天下有情人终成眷属！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正确使用 Mac 的姿势]]></title>
      <url>%2F2017%2F01%2F18%2Fmac-os-guide%2F</url>
      <content type="text"><![CDATA[不像很多达人上大学或者更早时间就开始就使用 Mac， 我从15年12月份才开始用，到现在已经有一年多时间。Mac 现在成为我的御用电脑， 当然工作中我还没有完全切换到 Mac 上来，主要开发还在用 Ubuntu 进行开发。和 Ubuntu 一样它们都用相同的特点： 没有右下角弹窗的打扰，没有流氓软件，能让你注意力更集中。 强大的终端操作。 当然它更有别的操作系统不具备的—精美的UI设计和触摸板。如果你还没有， 那么你值得拥有，不过 New MacBook proc 的设计我不是很喜欢，可能我的审美还不到苹果设计师的 level。如果你为了打游戏就算了， 当然 Window 是你的唯一选择。 下面我们说说 Mac OS X 下常用的软件及快捷键, 当然如果你想达到更正确的姿势，配着多屏和机械键盘就更佳。 常用软件AlfredAlfred 是一个非常强大的效率工具。快捷键呼出search框，输入你想找的任何东西得首字母或者前几位、缩写，然后上下方向键找到你的目标，回车就行。 还可以定在快捷键。 Alfred3https://www.alfredapp.com/ iTerm专为 Mac OS 用户打造的命令行应用, 以前我还专门介绍过它， 有兴趣的可以看一下原文 打造最强终端-iTerm 2。 Dash非常强大的文档查看器。当你写东西的时候可能会同时用到好几个文档。Dash帮你管理你的文档。不用再切窗口了！所有的文档都可以下载到本地，再不用忍受蜗牛速度去看国外的文档了， 我以前用来看 Android 文档。 UlyssesUlysses 是我用过最好的写作软件，我在上面写出了近五万的文字。它的特点是： 全平台支持 沉浸式写作 搜索功能 Manico在 OS X 下，我们想要启动或切换应用时，通常有以下三个选择： 对于常用应用，将鼠标光标移动到屏幕下方打开 Dock 栏，从中选择需要启动或切换的应用打开； 对于已经启动的应用，按下「Command + Tab」呼出切换器，按 Tab 键或使用鼠标选择需要切换的应用打开； 对于既没有放在 Dock 栏也没有启动的应用，可以通过 Launchpad 或 Spotlight 搜索应用打开。 对于习惯使用键盘的「效率党」而言，上面的几种方式并不够高效。有没有什么办法，可以整合这三种方式，并通过快捷键组合便能实现快速应用启动和切换呢？Manico 的出现为「效率党」提供了一个简单、易用、高效的快速启动和切换 App 的方式。 下图是我的快捷键配置： ClyppanOS X 系统的剪切板默认只保存最后一次复制或是剪切的内容，所以你想粘贴前几次复制的内容时…不好意思，再切过去、选择、复制一遍。 我以前经常遇到这样的场景， 直到有一天看到大和童鞋使用 Clyppan 以后， 妈妈再也不用担心重复拷贝了。 Hammerspoon有没有使用多屏的用户， 一般程序员和设计喜欢用多屏， 其实条件容许， 每个人都应该多配一个屏， 能很大提升我们的工作效率。 Hammerspoon 是一个多屏幕窗口管理软件，首先它是开源的，其次使用 Lua 脚本作为配置文件。 [http://www.hammerspoon.org/] awesome-mac这是一个 Github 项目，主要是收集非常好用的Mac应用程序、软件以及工具，主要面向开发者和设计师。 [https://github.com/jaywcjlove/awesome-mac] 当然还有文本编辑器， 网友很多推荐 Atom 或 Sublime Text，不过我没有用过， 因为我用 emacs，选一个自己喜欢的就行。 常用快捷键 Command + C， Command + V，Command + A ：这几个大家都知道，不过尽量别用在代码拷贝上。Command + Delete ： 删除当前行。选中文件的时候直接删除文件。shift+方向键 ： 这个在选择文本的时候很有用，可以选择单个字符或者整行，多使用才能找到手感。Command + Shift + 左右方向键：这个可以快速选择当前行，用的也很多Control + A：跑到当前行的最前端，使用频次很高Control + E：跑到当前行的最尾端，使用频次很高，还有 B、F 光标向前移动和向后移动Command + TAB：切换应用，这是大部分人用的最多的方式，却不是最高效的方式，后面会介绍其他方式Command +` : 切换同一应用的窗口，这个非常实用。比如打开多个 Android Studio 工程的情况下，快速的在不同项目之间切换。 Finder，Firefox等场景下都支持Command + W：关闭当前窗口，后面会介绍其他方式，同样高效Command + Q：关闭当前应用Command + N：新建窗口，比如打开新的Finder窗口，配合cmd+w很实用Command + I : 显示当前文件的信息，查看文件大小，图片宽高的时候有用选中文件按空格预览：预览图片或者pdf文件时有用。配合方向键可以快速预览多张图片Command + F：查找， Command + G 查找下一个； Command +Shift + G 向上查找Control + Command + D：英文单词，完成取词翻译 浏览器相关 Command + T ： 这是基本全局打开新标签的标准键，会用的很多Command + L ：光标移到地址框Command + R ：刷新页面Command + + ：大屏幕的时候很实用，放大页面，基本也是全局型的。 0是恢复默认大小Command + W ： 关闭当前标签。不要和退出按错了Command + Q ：退出当前软件，其他软件也都可以用Command + D ：收藏当前页面空格 ： 屏幕下滚一页Command + Z ：Safari的恢复刚关闭标签就是熟悉的Command + Shift + T：Chrome是和打开差不多的，Chrome这个功能更强大，就是可以按顺序恢复，但是Safari只能恢复最近的一个。这个功能我一直用，经常手抖关闭的一瞬间发现有用。 当然如果你是 Vim 「中毒」党你也可以在 Chrome 上装上插件， 反正我是装了，不过很少用。 最后送自己和大家一些话， 当然做上面的事你首先有一台 Mac： If you’re interested, you come up with stories, excuses, reasons, and circumstances about why you can’t or why you won’t. If you’re committed, those go out the window. You just do whatever it takes. PS：又到了春运时间了， 你们需要回到父母身边吗？是不是还有人没有买到票的？今年要去我媳妇那边过年，正好今年公司年会在外地开， 开完以后就放假了，终于今年可以早点回去了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[程序员最应该读的书]]></title>
      <url>%2F2017%2F01%2F18%2Fprogramer-book%2F</url>
      <content type="text"><![CDATA[最近公司在推行程序员应该买什么书读的话题， 也买了一大堆书供大家阅读。以前也被别人问到类似问题—程序员都应该读什么书，你能推荐一下书单吗？最开始我是拒绝回答这总问题的。 第一，这种问题你可以用搜索引擎（Google）去解决，这样的问题有太多的回答了， 多找找你就会发现它们相同的地方了。还是那句话「不做伸手党」。 因为一旦你开始不做伸手党，就会发现自己的分析能力瞬间提高了不少。就像我在 xx 写道 「分析并作出判断」才是我们我们成长的基石。 第二，每个人的背景和行业都不一样， 你可能是 Java 工程师、C/C++ 工程师、GO 工程师、Python 工程师、数据分析师 或者全栈工程师，所以需求和成长路线就会不一样。你需要的书单就是不一样的， 没办法准确给你答案。 我在思考， 为什么自己会人为设置条框呢？分享就好了， 事真多，别人会去除糟粕的，就不劳烦你操心了。好吧，废话有点多， 我把我收集的关于书籍的资源整理出来，大概分为如下部分： 可以下载书籍或者查找书籍的网站； 网友和朋友推荐的书籍； 可以下载书籍或者查找书籍的网站 it-ebooks：下载IT电子书籍的网站 [http://www.it-ebooks.info/] gitbook：gitbook上有很多书籍 经典编程书籍大全：100+ 经典技术书籍 [https://github.com/jobbole/awesome-programming-books] oreilly Free Programming Ebooks：ORielly 的免费电子书 [http://www.oreilly.com/programming/free/] free-programming-books：免费的编程英文书籍索引 [https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md] free-programming-books-zh_CN：免费的编程中文书籍索引 [https://github.com/justjavac/free-programming-books-zh\_CN]_ awesome: awesome系列, 包括各种语言的， 大家到 Github 上搜索一下 网友和朋友推荐的书籍张逸在 2013 写了一篇 『ThoughtWorks(中国)程序员读书雷达』，该读书雷达将书籍分为了如下四个维度： Coding Practice（编程实践） Architecture &amp; Design（架构与设计） Methodology（方法学） Thought &amp; Leadership（思想与领导力） ThoughtWorks(中国)程序员读书雷达（2013）:[https://www.douban.com/doulist/2012097/] 现在发现又有 2016 版的了 ThoughtWorks读书雷达（2016）：[https://www.douban.com/doulist/43272819/] 看一下同事发给我的思维导图吧 以上就是我整理的关于书籍的一些资源，你也可以告诉我你的书单。 其实如上面提到的如果你有足够的分析能力， 知道如何阅读一本书，其实根本没有什么书单的。你什么书都去读好了， 不过要带上思考的脑子， 能快速辨别哪些书是需要精度的，哪些是不需要的。 IT 行业本身就是快速变化的行业， 你需要不断学习， 不断的读书。不只是你， 我也有好多书没读…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的 2016]]></title>
      <url>%2F2017%2F01%2F01%2F2016-person-summary%2F</url>
      <content type="text"><![CDATA[转眼间2016走到了尽头。人们需要仪式感，所以无论情不情愿，总要和过去的自己诀别一番。尽管你我都知道，明年不会是一个更新的自己，只会是一个更老的自己。 只是当你在午夜检点行藏，追忆过去的365个日夜，回想年初制定的那些计划，有太多的事情值得仔细思量。 我最害怕这种命题作文， 因为以前一到这时候回答这个问题都逃不掉下面的一句话: 对自己失望这件事上，我每年都没让自己失望过。 不过今年开始往好的方向发展了， 主要发生在我身边的事件线： 码字、阅读 置业 学英语 提到码字是我今年做的最好的事情， 以前提到大大小小、技术和非技术写了100多篇，也有让我个人有那么一丝安慰为数不多的几篇；还有在这周微信公众号邀请「开通原创保护功能」。 码字和阅读让我的心态变得更平和，我本身是个性子比较急的一个人， 不会控制自己的情绪，不过通过阅读、码字、思考等行动，慢慢变得不那么暴躁了。当然这个只是我个人的看法， 不知认识我的童鞋怎么看呢？还有本质的东西，不是你想控制就能控制的，现在做的远远不够。偶尔在遇到当时看来有挑战的问题时，也会骂娘。 置业：在八月份的时候， 我选择置办房产，这次的动机很简单主要考虑以后小孩上学问题。为什么选择八月份呢？ 主要那段时间涨的太厉害， 原本计划明年要办的事情提前做了。 本来简单买个房子，不应该那么麻烦， 不巧的狗血的剧情在我身上发生了。在我签合同前，由于房价的持续飞涨，政府终于出台久违的限购政策， 政策导致我瞬间没有购房资格了。 在那之前我向开发商已经交过20%首付了， 无赖为了买这个房子只能选择离婚了。所以现在的身份是个离异人士，老婆变成前妻了。有人说，「年底不买房， 等于一年白忙」，我只能呵呵，你鸭的，我们都是被逼的出来卖的， 唉， 谁信了。 英语：说完房子我们再来说说英语， 英语这个问题， 一如既往的稳如狗， 从来没有让我失望过。预期目标没有完成， 以前的文章中我一说过问题出在哪里，最主要原因在投入的不够。不过我没有放弃， 现在已经培养中「物理习惯」了 ，下一步做就是花时间投入问题了。 生活：这一年里， 说实话陪家人时间很少， 尤其是我们家的小布点， 有时候回去了， 给你打招呼你也不理我，我知道主要是陪你太少了，你都不认识我了。 我只是希望用自己行动，能影响你的成长。如果自己最终是个有足够积累的人， 起码你不用哀怨自己的命运， 就算不是「含着金钥匙出生」，管它是金是银、是铜是铁， 终归可能起码含着钥匙呢？ 明年你又大一点了， 到时候可以多带你出去走走，我知道你很聪明（至少比我聪明），希望你以后你能找到自己的道路，这样我就能早点实现回家种地目标了。 现在工作时候， 哪怕下雨，雾霾，我每天都从地铁口走到公司，不近不远1.5公里，哪怕现在可以选择单车了， 我还是选择走过去， 这段时间是我思考时间，好多实践都是这段时间决定的。 2016对个人成长方面的投资超过5000块，也在点滴改变自己，是的，我在做正确的事情。 从无忧无虑到知道人生不易，这个需要时间去打磨，就像李宗盛在「鬼迷心窍」中唱到： 虽然岁月总是匆匆地催人老 虽然情爱总是让人烦恼虽然未来如何不能知道 现在说再见会不会太早 驰骋远方的人总有一天要踏上归途，讲完故事喝完酒也得回老家过年，再老的司机也会因为眷恋一个人的微笑，而燥不了。 平庸的日子一年又一年。我们总会在年初写很多 flag，而又在年末的时候亲手拔掉，开始一个新的轮回。而我，也许现在不美好，但黎明前总是最黑暗。 记得电影《后会无期》里有一句经典台词： 我们听了很多的道理，可是却依旧过不好这一生。 我们当然过不好这一生，因为我们只是听了这些道理，从来也没有行动过。也把它送给2017的自己和你们。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式--单例模式]]></title>
      <url>%2F2016%2F12%2F21%2Fdesign_pattern_singleton%2F</url>
      <content type="text"><![CDATA[在我们日常的工作中经常需要在应用程序中保持一个唯一的实例，如：IO处理，数据库操作等，由于这些对象都要占用重要的系统资源，所以我们必须限制这些实例的创建或始终使用一个公用的实例，这就是我们今天要介绍的——单例模式（Singleton）。 定义 单例模式，又称单件模式或者单子模式，指的是一个类只有一个实例，并且提供一个全局访问点。 实现思路在单例的类中设置一个 private 静态变量instance，instance 类型为当前类，用来持有单例唯一的实例。将（无参数）构造器设置为 private，避免外部使用 new 构造多个实例。提供一个 public 的静态方法，如 getInstance，用来返回该类的唯一实例 instance。 类图 几种实现方式由于使用场景不同，出现不同写法和模式，它们分别: 懒汉式 恶汉式 双重校验锁 枚举 静态内部类 由于枚举使用场景场景较少， 下面就不介绍，感兴趣的可以自行解决。 饿汉式饿汉式指的是单例的实例在类装载时进行创建。由于是在类装时候创建， 所以能够保证线程安全。如果单例类的构造方法中没有包含过多的操作处理，饿汉式其实是可以接受的。1234567public class SingleInstance &#123; private final static SingleInstance instance = new SingleInstance(); public static SingleInstance getInstance() &#123; return instance; &#125;&#125; 不足： 如果构造方法中存在过多的处理，会导致加载这个类时比较慢，可能引起性能问题。 如果使用饿汉式的话，只进行了类的装载，并没有实质的调用，会造成资源的浪费。 懒汉式懒汉式指的是单例实例在第一次使用时进行创建。这种情况下避免了上面饿汉式可能遇到的问题。123456789101112public class SingleInstance &#123; private static SingleInstance instance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == instance) &#123; instance = new SingleInstance(); &#125; return instance; &#125;&#125; 但是如果上面的代码在多线程并发的情况下就会发生问题， 因为它们存在共同的「临界资源」 instance, 比如线程A进入 null == instance 这段代码块，而在A线程未创建完成实例时，这时线程B也进入了该代码块，必然会造成两个实例的产生。 所以如果多线程这里要考虑加锁同步。代码实现如下：123456789101112public class SingleInstance &#123; private static SingleInstance instance; private SingleInstance() &#123; &#125; public static synchronized SingleInstance getInstance() &#123; if (null == instance) &#123; instance = new SingleInstance(); &#125; return instance; &#125;&#125; 如果使用 synchronized 修饰 getInstance 方法后必然会导致性能下降，而且 getInstance 是一个被频繁调用的方法。虽然这种方法能解决问题，但是不推荐使用在多线程的情况下。所以伟大人类又想到了 「双重检查加锁」。 双重校验锁伟大人类想到首先进入该方法时进行 null == sInstance 检查，如果第一次检查通过，即没有实例创建，则进入 synchronized 控制的同步块,并再次检查实例是否创建，如果仍未创建，则创建该实例。12345678910111213141516public class SingleInstance &#123; private static SingleInstance instance; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; if (null == instance) &#123; synchronized (SingleInstance.class) &#123; if(null == instance) &#123; instance = new SingleInstance(); &#125; &#125; &#125; return instance; &#125;&#125; 双重检查加锁保证了多线程下只创建一个实例，并且加锁代码块只在实例创建的之前进行同步。如果实例已经创建后，进入该方法，则不会执行到同步块的代码。 这里我们没有加 volatile ，大家可以思考一下，看看是不是必须要加 volatile？ 静态内部类123456789101112public class SingleInstance &#123; private SingleInstance() &#123; &#125; public static SingleInstance getInstance() &#123; return SingleInstanceHolder.sInstance; &#125; private static class SingleInstanceHolder &#123; private static SingleInstance sInstance = new SingleInstance(); &#125;&#125; 上面的代码 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，我想让它延迟加载， 上面就能这种方式就能达到。 优点: 单例模式（Singleton）会控制其实例对象的数量，从而确保访问对象的唯一性。 实例控制：单例模式防止其它对象对自己的实例化，确保所有的对象都访问一个实例。 伸缩性：因为由类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 缺点: 系统开销。虽然这个系统开销看起来很小，但是每次引用这个类实例的时候都要进行实例是否存在的检查。这个问题可以通过静态实例来解决。 使用多个类加载器加载单例类，也会导致创建多个实例并存的问题。 使用反射，虽然构造器为非公开，但是在反射面前就不起作用了。 对象生命周期。因为单例模式没有提出对象的销毁， 所以使用时容易造成内存泄漏， 例如在 Android 中在 Activity 中使用单例， 所以我们要额外小心。 使用场景 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。 不要使用单例模式存取全局变量。这违背了单例模式的用意，最好放到对应类的静态成员中。 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式 Android 系统中的应用在 Android 系统中， 大量使用单例模式， 我们来看一下。 饿汉式：12345678910public class CallManager &#123; ... // Singleton instance private static final CallManager INSTANCE = new CallManager(); public static CallManager getInstance() &#123; return INSTANCE; &#125; ....&#125; 懒汉式非线程安全实现方式:1234567891011class SnackbarManager &#123; ..... private static SnackbarManager sSnackbarManager; static SnackbarManager getInstance() &#123; if (sSnackbarManager == null) &#123; sSnackbarManager = new SnackbarManager(); &#125; return sSnackbarManager; &#125;&#125; 懒汉式线程安全实现方式: 12345678910111213public class SystemConfig &#123; ... static SystemConfig sInstance; ... public static SystemConfig getInstance() &#123; synchronized (SystemConfig.class) &#123; if (sInstance == null) &#123; sInstance = new SystemConfig(); &#125; return sInstance; &#125; &#125;&#125; 总结饿汉 VS 懒汉：+饿汉：声明实例引用时就会被实例化 懒汉：静态方法第一次调用前不被实例化，即懒加载。对于创建实例代价大的， 且不一定使用时，这种方式可以减少开销 一般的情况下，构造方法没有太多处理时，我会使用「饿汉」方式， 因为它简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境）。只有在要明确实现延迟加载效果时我才会使用「静态内部类」方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 项目框架--MVP 基础]]></title>
      <url>%2F2016%2F12%2F13%2Fandroid-mvp-basic%2F</url>
      <content type="text"><![CDATA[文章来源：itsCoder 的 WeeklyBolg 项目 itsCoder主页：http://itscoder.com/ 作者：JasonThink 审阅者：@shaDowZwy 写在前面今天我们聊一聊传说中 Android 框架 MVP， 想必大家早就听过了， 最早接触这个名词时在今年1月份左右，那时候在 medium 上看到的一篇关于它的介绍， 看的也不是很明白， 不过被一些设计思想吸引。然后参阅一些相关的资料， 发现 Google 在 Github 有一个实现的代码， 然后模仿它例子也在 Github 上创建第一个 Android Demo。 现在真后悔当时没有写一篇相关的文章， 总给自己理解不深找借口， 越拖发现类似的文章越多， 现在都已经烂大街了， 本来不想凑这个热闹的，好吧， 管它了，就当来补债的 。当时还看了 MVP、MVVM、Facebook Flux 比较的文章，现在 Android 主流框架是： Retrofit + OkHttp + RxJava + MVP + Dagger 2。 言归正传，今天我们主要说明一下情况： 什么是 MVP， 有什么优缺点。 如何实现。 实际项目中如何改造。 MVP全称 Model-View-Presenter，其中 Presenter 解耦了 Model 与 View，使得每个模块的职责更加单一，Model 负责获取数据，View 只关心视图的绘制，Presenter 关联 Model 和 View 处理业务逻辑。 需要注意的是，「Model」 这个词并不正确。严格意义上来说，它指的应该是检索或控制一个 Model 的业务逻辑层。举个例子，比如你的数据库里面包含了 User，而你的 View 想要显示一个 User 列表，那么 Presenter 会引用数据库中的业务逻辑层，查询一个 User 列表，如下图： 有兴趣的大家可以参考下面的文章， 概念写的比较详细，里面讲到了， 它的的发展历程、MVX 解析。 Android MVP 详解（上） http://www.jianshu.com/p/9a6845b26856 我们把 MVP 的优缺点单独说一下， 「知己知彼，访客百战不殆」，不然想想下面场景： 女朋友：你喜欢我什么？ 我：(⊙v⊙)嗯，。。。 女朋友：连喜欢我什么都不知道， 走跟我回去跪方便面。 我：。。。。。 优点： 降低耦合度，实现了Model和View真正的完全分离，可以修改View而不影响Model 方便进行单元测试， 这个很重要。 Presenter可以复用，一个Presenter可以用于多个View。 View 可以进行组件化。在 MVP 当中，View 不依赖 Model。这样就可以让View 从特定的业务场景中脱离出来，可以说 View 可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。 缺点： Presenter 中除了应用逻辑以外，还有大量的 View-&gt;Model，Model-&gt;View 的手动同步逻辑，造成 Presenter 比较笨重，维护起来会比较困难。 如果 Presenter 过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么 Presenter 也需要变更了。 View 实现接口比较多，显得代码可读性增高。 DEMO 展示我最开始看的 Demo 就是 Google 官网提供的，给我很多启发，项目主要展示类似便签的应用。 项目地址: https://github.com/googlesamples/android-architecture 下面是它框图： 本来想拿官方源码进行剖析的，发现以及有人已经写了， 而且还写比我要好， 你说气人不， 下面是它的分析。 Android官方MVP架构示例项目解析 [http://www.infoq.com/cn/articles/android-official-mvp-architecture-sample-project-analysis] 实践项目使用我们来思考一个问题， 我们通过观察上一章 Google Demo 我们会发现一个问题， 事实上每个功能块的代码都是类似的，只是细节上会有所不同。重构的原则告诉我们，这些地方是可以进行重构的。在这个时候，一般会首先想到把一些相同的功能块抽象成一个基类。例如网络错误处理、服务器拒绝请求返回的错误处理等。但是随着项目的进行，很快就会发现，类文件量、代码量仍然会增加得很快，随之带来的问题是项目的管理会变得越来越复杂。 不满现状的我们又进行方案的重组和选择， 最后想到可以通过泛型和抽象，进一步简化 MVP 框架。所有view的基类是 IView（activity或fragment 也是这 view）。IView:12public interface IView &#123;&#125; IPresenter:1234public interface IPresenter&lt;V extends IView&gt; &#123; void attachView(V view); void detachView(boolean retainInstance);&#125; 上面我们提到，我们把 Activity 和 Fragment 看成 View。所以我们提供了 MVPActivity 和 MVPFragment 作为他们的基类。 这里我们仅仅看 MVPActivity， MVPFragment类似。123456789101112131415161718192021222324public abstract class MVPActivity&lt;V extends IView, P extends IPresenter&lt;V&gt;&gt; extends BaseActivity implements IView, IMvpBase&lt;V&gt;&#123; protected P presenter; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); presenter = createPresenter(); presenter.attachView(getMvpView()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); presenter.detachView(false); &#125; public abstract P createPresenter(); @Override public V getMvpView() &#123; return (V)this; &#125;&#125; 主要思想是 IView 会关联一个 IPresenter, 并且管理 IPresenter 的生命周期。大家从上面的代码片段可以看到， 通常 presenter 是绑定在该生命周期上。所有的初始化或者清理工作都放在 presenter.onAttach() 和 presenter.detach() 上进行。想大家注意到 IPresenter 是一个接口。 我们还提供一个 BasePresenter, 它只持有 View 的弱引用， 从而避免内存泄漏。所有，当 presenter 想要调用 view 的方法是， 我们需要判断 isViewPresenter() 并使用 getView()来获取引用，以坚持view是否连接当了 presenter。 看一下上图我项目结构， 其中 BaseLib 下有两个库，分别是 baseapp、mvplib。 baseapp：主要包含BaseActiviy、AppMain 类 mvplib： 主要是时 MVP 封装框架，更高效开发 app: 主要是我们的演示程序 那么我们看 app 中演示程序，这里本身只是简单通过 Activity 自举， 别的类似。1234567891011121314151617181920212223public class MainActivity extends MVPActivity&lt;MainActivity, HelloPresenter&gt; implements IView &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final EditText editText = (EditText) findViewById(R.id.editText); Button button = (Button) findViewById(R.id.button); final TextView textview = (TextView)findViewById(R.id.textView); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String str = editText.getText().toString().trim(); presenter.submit(); &#125; &#125;); &#125; @Override public HelloPresenter createPresenter() &#123; return new HelloPresenter(); &#125;&#125; 从上面代码中我们可以看到 MainActivity 继承了 MVPActivity ，实现了 IView， 其中 createPresenter()负责创建对应的 Presenter，下面我们看 HelloPresenter 的实现。 12345678910public class HelloPresenter extends BasePresenter&lt;MainActivity&gt; &#123; public void submit() &#123; MainActivity view = getView(); TextView textView = (TextView) view.findViewById(R.id.textView); EditText editText = (EditText) view.findViewById(R.id.editText); assert editText != null; textView.setText(editText.getText().toString().trim()); &#125;&#125; 我们可以看到 HelloPresenter 负责进行 UI 的更新， 这里只是简单举例， 实际项目中我们可以配合 RxJava 进行实现。具体实现可以看一下本人的Github的实现。 项目GitHub：https://github.com/jasonim/mvparchitecture 这样我们上面基本上解决上面我们提出的问题， 当然我们经常可能遇到屏幕旋转的问题， 这样一般处理数据持久化问题， 一般的做法是在 onSaveInstanceState()处理， 简单做法记录数据。当然我们可以通过状态来修复view的状态。就不在这里说了， 感兴趣的可以参考 mosby 的做法。 mosby:https://github.com/sockeqwe/mosby 写在最后「一万个心中有一万个哈姆雷特」，没有任何事情是绝对不变的， 框架也是一样，对 MVP 的争论不断： MVP，太多的接口，如果项目大的话，还可以，如果不大，就建太多的类。感觉有点笨重。。。 把握以下两点就行： 我们引用项目框架目的是什么？是不是为了业务扩展，如果没有扩展需求， 什么项目框架也不需要。 每个人的理解不一样，实践中找到一个适合自己的就好, 如果感觉 MVVM 的双向绑定很好，那就改造一下， 没有最好，只有更好。实践、再实践。 下一篇我们来聊一聊， 怎样在 MVP 中加入 dagger、rxjava；怎么通过组件化优化项目结构。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工厂方法模式]]></title>
      <url>%2F2016%2F12%2F07%2Ffactory-method%2F</url>
      <content type="text"><![CDATA[文章来源：ThinkKeep 的 design-patterns 项目 作者：JasonThink 审阅者：@shixinzhang定义工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。类图 代码：1234567891011121314151617public static void main(String[] args) &#123; //Http ProtocolFactory factory = new HTTPFactory(); Protocol protocol = factory.createProtocol(); protocol.performRequest(); //UDP factory = new UDPFactory(); protocol = factory.createProtocol(); protocol.performRequest(); //TCP factory = new TCPFactory(); protocol = factory.createProtocol(); protocol.performRequest();&#125; 上面的代码， 分别通过不同的协议工厂创建不同协议类， 方便客户端调用。这样客服端不需要关心哪种具体产品类将被实例化这一细节，也不需知道具体的类的类名， 当再有更多协议更方便扩展，也遵循「对扩展开放，对修改关闭」的原则。如果细心的同学可能会发现， 三段代码有相同的地方， 是的， 可以进一步重构， 像这样createFactory(int protocol)，这里为了更方便大家看懂工厂方法，就分开来写了。 运行结果： 优点： 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 使用场景当我们遇见下列场景，可以考虑工作方法模式： 我们不能预先知道被创建对象的类型，如我们在不知道发送网络请求用什么协议（TCP、UPD 或 HTTP）， 就像上面的例子。 一个类想要他的子类指定它的创建的实例 将创建的对象的任务委托给多个工厂子类中的其中一个， 调用者在使用时可以无需关系是哪个工厂子类创建产品， 需要时动态指定， 可将具体工厂类名存储在配置文件或数据中。 Android 应用实例Android 中用到了太多的工厂类，其中有用工厂方法模式的，比如AsyncTask类中工厂的具体实现如下：12345678//工厂实现类private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;; 上面代码中 ThreadFactory 就是工厂方式的类的实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抽象工厂模式]]></title>
      <url>%2F2016%2F12%2F07%2Fabstract-factory%2F</url>
      <content type="text"><![CDATA[文章来源：ThinkKeep 的 design-patterns 项目 作者：JasonThink 审阅者：@shixinzhang 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。我们可以想一下，有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象，即产品族。如在工厂方法中 HTTPFactory 只负责生产 HTTPProtocol 等。显然不能满足我们的需求了， 怎么办？ 抽象工厂模式给我们解决了这个问题。 为了让你能够更好的理解抽象工厂模式， 我们先了解以下几个概率： 产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是 Protocol，其子类有 HTTPProtocol、TCPProtocol、UDPProtocol，则抽象 Protocol与具体协议之间构成了一个产品等级结构，抽象Protocol是父类，而具体协议的 Procotol 是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如中国麦当劳店生产的巨无霸、可乐， 巨无霸位于汉堡产品等级结构中，可乐位于饮料产品等级结构中。 定义 Provide an interface for creating families of related or dependent objects without specifying their concrete classes。为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。 实例大家都去麦当劳吃过汉堡吧， 还有中国的麦当劳产品和国外的麦当劳，不一样吧， 至少原料不一样吧， 鸡肉都是本地产的吧，还有汉堡的大小不一样吧。套餐的品种也不样吧， 下面我们就用麦当劳举例吧。 类图： 代码： AbsFactory12345public interface AbsFactory &#123; Hamburg createhamburg(); Drink createDrink(); //套餐....&#125; Store1234567891011public class Store &#123; public static void main(String[] args) &#123; AbsFactory factory = new ChineseFactory(); factory.createDrink(); factory.createhamburg(); factory = new NYFactory(); factory.createDrink(); factory.createhamburg(); &#125;&#125; 运行结果： 优点： 封装性，每个产品的实现类不是高层模块要关系的，要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。 缺点： 抽象工厂模式的最大缺点就是产品族扩展非常困难，如实例中如果再添加新产品， 就需要在抽象工厂类添加对应的产品，开闭原则的倾斜性。 使用场景 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 系统中有多于一个的产品族，而每次只使用其中某一产品族。 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 如某个 APP多套主题时， 青春版、老人版、自恋办等， 可以考虑抽象工厂模式。 抽象工厂模式与工厂方法模式区别及联系抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 他们自己没有绝对界限，当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。 Android 源码中的应用在java 的连接数据库的操作中，对不同的数据库的操作而形成的对象操作族，就是一种很好的抽象工厂模式的应用。而在 Android 系统中 WebViewFactoryProvider/WebViewChromiumFactoryProvider 也应用抽象工厂。 WebViewFactoryProvider12345678910public interface WebViewFactoryProvider &#123; ... WebViewProvider createWebView(WebView webView, WebView.PrivateAccess privateAccess); ... CookieManager getCookieManager();&#125; WebViewChromiumFactoryProvider12345678910111213141516171819202122232425262728public class WebViewChromiumFactoryProvider implements WebViewFactoryProvider &#123; @Override public WebViewProvider createWebView(WebView webView, WebView.PrivateAccess privateAccess) &#123; WebViewChromium wvc = new WebViewChromium(this, webView, privateAccess); ... return wvc; &#125; @Override public CookieManager getCookieManager() &#123; synchronized (mLock) &#123; if (mCookieManager == null) &#123; ... mCookieManager = new CookieManagerAdapter(new AwCookieManager()); &#125; &#125; return mCookieManager; &#125; ...&#125; WebViewFactoryProvider是抽象工厂接口，定义了WebView及周边功能所需要对象的创建方法，这些方法大部分为工厂方法，它们返回的对象类型是抽象的，属于面向接口的编程风格。抽象工厂WebViewFactoryProvider创建的对象有：实现Webview核心功能的WebViewProvider，管理Cookie的CookieManager，地理位置相关的GeolocationPermissions和存储Web表单数据的WebviewDatabase等等。WebViewChromiumFactoryProvider是抽象工厂的具体实现者，它提供“Chromium”主题的产品族，也是目前最新版本Webview正在使用的产品族。如果将来有新的浏览器引擎内核出现(以前用得是 Apple Webkit 内核， 听说 google 搞了一套自己的，不知道现在加进去没)，那么只需按照WebViewFactoryProvider接口创建该主题下产品，然后替换现有的「Chromium」就可以完成换代，不用改动其他地方任何代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[那些年我的编程之路（上）]]></title>
      <url>%2F2016%2F11%2F28%2Fmy-program-away-1%2F</url>
      <content type="text"><![CDATA[我接触编程比较晚， 大学时候才开学习编程的， 和阿里的『道哥』、Thoughwork 的 『Phodal』 比起来都要晚， 当然和『云舒』比起来要早， 哪又怎样，人家都能甩我几个银河系。 问我当初为什么学习编程呢？因为我的计算专业的。那你为什么选计算机专业呢？因为当初我上的那个学校，计算机专业没招满， 我被调剂到这个专业了，我当时报的可是生物技术啊。是不是好多同学和我一样， 恭喜。 现在想想真应该感谢我的母校。如果当时学了生物技术， 现在不敢想我能做什么， 实验小白鼠、研究甜玉米、在制药公司买药， 可惜人生没有假设， 不然呢？ 和很多大一新生一样， 好不容易离开父母的监管， 记得一般英语课都在上午前两节， 由于晚上玩的比较晚，当然上午就起不来了， 结果导致一般英语课就不去了。那时候主要的活动是 喝酒、Dtao、篮球，记得以前提过喝酒最高纪录，也是那时候创下的。我们吃饭喝酒一般都在学校旁边的 『老地方水煮鱼』，一般一份水煮鱼、一份花生米、四份米饭、8瓶啤酒，齐活。60左右， 现在看来真便宜，而且他家的水煮鱼是一绝，就现在来看也是。前段时间有点事回去，还和同学特意去吃了一次， 还是那个味道， 只是地方变大了， 还和老板说， 「以后不干这行了， 加盟你的水煮鱼可否」。 大二除了做上面的事情， 做了另一件最主要的事情，找了一个女朋友， 主要动机我想不能重复做大一的事情了，太没意思了，那就找个朋友刷刷吧。由于时间就那么多， 喝酒、打游戏、篮球， 我就出掉了打游戏， 当然不是完全不玩， 只是频率少了很多。女朋友是外校的， 具体是怎么认识的，怎么追的。今天不再这里展开说了， 上次我就说写一写我和她的故事， 一直也没有写，哪天一定要把债补上。总之她是我生命中最主要的女人之一。正好今天是感恩节， 她刚刚发微信告诉我，今天是感恩节， 我是这样回的 「谢谢你的把我收了，不然我就砸手里了」 。 大三我又做了一件事情，真正学习编程。 当时感觉应该考虑毕业之后该做什么，回家种地？ 既然学了这个专业， 又没有更好的出路，那就认真搞一把， 由于专业课没有怎么逃课，感觉基础还行。可是自学了一段时间， 一直徘徊于 Hello world 上面。 我就找到当时交我们 C# 老师聊了聊， 说明我的一些想法。他说可以， 你先给做个东西， 拿给他看看。 然后我就给他用 C# 做了一个计算器。也是在网上找的，其实好多代码都看不懂， 勉强让它跑起来。他看后没有说行还是不行，我就回去等结果， 一周我去找他一次， 这样连续去了两周。他说行吧， 你再给我找一个同学， 你两一块；我就找了一个喜欢编程的也喜欢喝酒的。 就这样我们跟这那个老师，边做项目边学习， 持续大概一年时间， 中间为了提高效率我们搬进我们学院提供实验室， 当然学习氛围更好一些， 至少很少看见在那打游戏的了。在哪里我也接触到 Linux，可以说那里是我 『计算机的启蒙、也是我 Linux 的启蒙』，那段时间是我状态最好的， 虽然没有学到什么东西， 但是现在看来让我走上编程道理的主要原因， 不然我不会选择编程之路。 PS：不知道微信公众号里都有多少是刚刚工作不久，或者还没有毕业的。虽然我的公众号里并没有多少人，关注我的都是我的种子用户，你们不离不弃， 必将芳龄永继。哈哈， 言归正传， 还没有毕业的或刚刚毕业， 一定要做好下面几件事： 如果是男生一定要找一个女朋友， 如果是女生就算了，因为关注我公众号的女生都抢手哈， 不要急，发现上进的男人就同意了；不要太挑了， 这也是一种投资， 当然也有投资失败的情况， 不要在意。 不要听别人说，「现在谈了， 毕业就会分手， 还不如不谈」。这样的论断， 因为每个个体都不一样， 不试试怎么知道呢？我不能说一定不会分手， 至少我身边的有一两个包括我自己都没有分手， 而且还结婚了。是不是让吃瓜群众失望了。当然我们几个只是个体，不适用普遍规律。但是一点是真的恋爱能让人成长。还有最主要的原因是看你们怎么对待这段感谢的， 也就是对待感情的态度， 我看到的好多分手的，都是对待感情很随意。好多人会说那时候年轻不懂，其实不是不懂， 是拿年轻找借口。如果刚毕业也要抓紧找， 不然以后成本会越来越高。当然你认为你很优秀，优秀到地球都装不下你了， 那最好别找。把机会让给不那么优秀的人吧。还有找朋友，真的那么难吗？ 多发点时间， 多用点心， 多一点厚脸皮。能跨专业找就跨专业找，如果你会写程序， 你就在特殊的日子，写一点特殊的东西， 其实不难。不会写程序， 总会修电脑、装软件吧， 如果你还说不会， 那就活该你没有女朋友。真替你们着急， 写的我都想再找一次女朋友了， 你们难道没有感觉吗？ 好好学习， 多和别人沟通，多参加一些活动 ，哪怕这个专业你不喜欢，你也认真听课，特别是英语。这个就是你于别人不同的地方， 也是你的价值。现在网络特别发达， 如果你有喜欢的方向， 就去学。还有一定要学会科学上网（翻墙），如果不会， 就先把这个学会， 不管你是什么专业，以后从事行业，如果你学习编程就上 Github，什么都有。 一定要重视第一份工作， 好好想想你要什么， 如果真不知道， 就要去一个中型以上的公司， 最好不要去 Start Up 公司， 这个对以后的最终成为什么样的人， 起到很重要的作用。 当然那些公司不好进， 这个就需要平时多下功夫，特别是那些和我一样学校背景一般的童鞋，更应该多努力， 因为我们可利用的资源少。每个行业切入点不一样，但是差别不大。 除非特殊原因， 前面两三年不要换行业、 城市， 当然工作时间越久，换行业的成本越高。自己把握一个度就行， 以前面试的时候， 有一个童鞋看他简历上写着以前在上海工作， 问他为什么来北京， 他说 「女朋友在北京」，这种鼓励。 本篇文章，首发于微信公众号！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式几大原则]]></title>
      <url>%2F2016%2F11%2F21%2Fdesign-principle%2F</url>
      <content type="text"><![CDATA[文章来源：ThinkKeep 的 design-patterns 项目 作者：JasonThink 审阅者：@shixinzhang 写在前面天下武林，林林总总。名门正宗如少林武当，诚然名扬天下，而武林之大，但凡修得暗镖神剑者，亦可独步江湖。所以门派无尊贵，只有适合不适合。设计的本质：即使最懂设计的人，也要心胸坦荡，认识到自我局限性，不可以名门正宗自居，须认识到获得真理是一个学无止境、永远追求的过程。 十八般武艺样样精通，仅出现在武侠传说中， 现实中即使是全栈工程师也不敢说十八般武艺样样精通， 对于普通的IT从业者来说， 如何从码农变为一个合格的工程师来说， 软件设计是必经之路。 当然要软件设计一定要遵循设计的六大原则。在工作的初期，我们可能会经常有这样的感受，自己的代码接口设计混乱、代码耦合较为严重、一个类的代码过多等等，当自己回头再看这些代码时可能会感慨，怎么能写成这个鸟样。再看那些知名的开源库，它们大多有整洁的代码、清晰简单的接口、职责单一的类，这个时候我们会通常会捶胸顿足而感慨：什么时候老夫才能写出这样的代码！ 在做开发的这些年中，我渐渐的感觉到，其实国内的一些初、中级工程师写的东西不规范或者说不够清晰的原因是缺乏一些指导规则。他们手中挥舞着面向对象的大旗，写出来的东西却充斥着面向过程的气味。也许是他们不知道有这些规则，也许是他们知道但是不能很好的运用到实际的代码中，亦或是他们没有在实战项目中体会到这些原则能够带来的优点，以至于他们对这些原则并没有足够的重视。 设计的六大原则在此之前，有一点需要大家知道，熟悉这些原则并不是说你写出的程序就一定灵活、清晰，只是为你优秀的代码之路铺上了一层栅栏，在这些原则的指导下，你才能避免陷入一些常见的代码泥沼，从而让你写出优秀的东西。 单一原则(Single Responsibility Principle)单一职责原则的英文名称是 Single Responsibility Principle，简称是 SPR，简单地说就是一个类只做一件事，这个设计原则备受争议却又极其重要。只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的。因为单一职责的划分界限并不是如马路上的行车道那么清晰，很多时候都是需要个人经验来界定。当然，最大的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。这跟我们社会分工一样， 一些人干这个， 另一些人干那个，只有大家都这样做了， 我们的社会才更和谐。 试想一下，如果你遵守了这个原则，那么你的类就会划分的很细，每个类都有比较单一的职责，这不就是高内聚、低耦合么！当然，如何界定类的职责就需要你的个人经验了。 当然，软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离，就是抽象的能力。其实要去判断是否应该分离出类来，也不难，那就是如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。 我们来定义一个网络类，代码如下：123456public interface IHttp &#123; /** * 发送 Http 请求，并且返回一个 Response */ public Response sendRequest(Request&lt;?&gt; request);&#125; 我们可以看到，IHttp 只有一个 sendRequest 函数，它的职责就是执行网络请求并且返回一个 Response，它的职责很单一，这样在需要修改执行网络请求的相关代码时，只需要修改实现 Http 接口的类，而不会影响其他类的代码。如果某个类的职责包含有执行网络请求、解析网络请求、进行 gzip 压缩、封装请求参数等，那么在你修改某处代码时就必须谨慎，以免修改的代码影响了其它的功能。当你修改的代码能够基本上不影响其他功能。这就一定程度上保证了代码的可维护性。注意，单一职责原则并不是一个类只能有一个函数，而是说这个类中的函数所做的工作是高度相关的，也就是高内聚。 基本判断原则， 就是一个特定的类，当确认以后， 它的责任就确定了，不能增加它行为以外的功能。 例如一般我们定义 API 接口的时候，如果这个接口干了很多事情， 就是一些隐含的事情，我们就认为它设计没有遵循单一原则。优点 类的复杂性降低，实现什么职责都有清晰明确的定义。 可读性提高，复杂性降低，那当然可读性提高了。 可维护性提高，可读性提高了，那当然更容易维护了。 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。 里氏替换原则(Liskov Substitution Principle)里氏替换原则本质就是继承和多态的应用。继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 还拿上面的 Http 类举例， 我们用 Restful API 方式进行 Http 网络请求，代码如下：12345678910111213141516171819202122232425public class RestfulClient &#123; .... Public RestfulClient(IHttp http) &#123; this.http = http != null ? http : createHttp(); &#125; public void doGet(String url, List&lt;Header&gt; list, Body body) &#123; ...//先创建Request //发送数据 http.sendRequest(request)； &#125; //创建IHttp 类 TODO 这个可以重构到Factory 里， 这里先偷个懒 public static IHttp createHttp() &#123; //我们可以根据 Android SDK 选择不同的HTTP int runtimeSDKApi = Build.VERSION.SDK_INT; if (runtimeSDKApi &gt;= GINGERBREAD_SDK_NUM) &#123; return new HttpUrlConnImpl(); &#125; return new HttpClientImpl(); &#125;&#125; 上述代码中， RestfulClient 类中依赖的是 IHttp 接口，而通过 createHttp 函数返回的是 IHttp 的实现类 HttpClientImpl 或 HttpUrlConnImpl。这就是所谓的里氏替换原则，任何父类、父接口出现的地方子类都可以出现，这不就保证了可扩展性吗！如果我们现在将网络请求库改成 OKHttp， 是不是将依赖传进去就行了。 优点： 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性。 提高代码的重用性。 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，很多开源框架的扩展接口都是通过继承父类来完成的。 提高产品或项目的开放性。 缺点： 继承是侵入性的。只要继承，就必须拥有父类所有的属性和方法。 降低了代码的灵活性。子类必须父类的属性和方法，让子类自由的世界中多了些约束。 增强了耦合性。当父类的常亮、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的后果—大量的代码需要重构。 依赖倒置原则(Dependence Inversion Principle)电脑在以前维修的话是根本不可能的事，可是现在却特别容易，比如说内存坏了，买个内存条，硬盘坏了，买个硬盘换上。为啥这么方便？从修电脑里面就有面相对象的几大设计原则，比如单一职责原则，内存坏了，不应该成为更换CPU的理由，它们各自的职责是明确的。再比如开放－封闭原则，内存不够只要插槽足够就可以添加。还有依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象，说白了，就是要针对接口编程，不要对实现编程，无论主板，CPU，内存，硬盘都是针对接口设计的，如果是针对实现来设计，内存就要对应的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬。 为什么叫反转呢？面对过程开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们做新项目时，去调用这些底层的函数就可以了。比如我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时就去调用，这就叫做高层模块依赖底层模块。 但是要做新项目是 业务逻辑的高层模块都是一样的，客户却希望使用不同的数据库或存储信息方式，这时出现麻烦了。我们希望能再次利用这些高层模块，但高层模块都是与底层的访问数据库绑定在一起的，没办法复用这些高层模块，这就非常糟糕了。就像刚才说的，PC里如果CPU，内存，硬盘都是需要依赖具体的主板，主板一坏，所有的部件都没法用了，显然不合理，而如果不管高层模块还是底层模块，它们都依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其它受影响，这就使得无论高层模块还是底层模块都可以很容易被复用，这才是最好的办法。 在前面我们的例子中， RefusClient 实现类依赖于 IHttp 接口（抽象），而不依赖于 HttpClientImpl 与 HttpUrlConnImpl 实现类（细节），这就是依赖倒置原则的体现。 传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和 setter 方法传递，相信用过 Dagger、Spring 框架的，对依赖的传递方式一定不会陌生。 在实际编程中，我们一般需要做到如下： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 依赖倒置原则的核心就是要我们面向接口编程。优点： 可扩展性好 耦合度低 接口隔离原则(Interface Segregation Principle)接口隔离原则（英语：interface-segregation principles， 缩写：ISP）指明没有客户(client)应该被迫依赖于它不使用方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为角色接口（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。接口隔离原则是在SOLID (面向对象设计)中五个面向对象设计(OOD)的原则之一，类似于在GRASP (面向对象设计)中的高内聚性。 下面是看到网上的举的例子： 可能描述起来不是很好理解，我们还是以示例来加强理解吧。 我们知道，在网络框架中，网络队列中是会对请求进行排序的。内部使用 PriorityBlockingQueue 来维护网络请求队列，PriorityBlockingQueue 需要调用 Request 类的排序方法就可以了，其他的接口他根本不需要，即 PriorityBlockingQueue 只需要 compareTo 这个接口，而这个 compareTo 方法就是我们所说的最小接口方法，而是 Java 中的 Comparable 接口，但我们这里是指为了学习，至于哪里定义的无关紧要。 在元素排序时，PriorityBlockingQueue 只需要知道元素是个 Comparable 对象即可，不需要知道这个对象是不是 Request 类以及这个类的其他接口。它只需要排序，因此，只要知道它是实现了 Comparable 对象即可，Comparable 就是它的最小接口，也是通过 Comparable 隔离了 PriorityBlockingQueue 类对 Request 类的其他方法的可见性。 很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 迪米特原则( Law of Demeter)迪米特原则（Law of Demeter，缩写LoD）等同于“最少知识原则（Principle of Least Knowledge）”，是一种软件开发的设计指导原则，特别是面向对象的程序设计。迪米特原则是松耦合的一种具体案例。该原则是美国东北大学在1987年末在发明的，可以简单地以下面任一中方式总结。 每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元； 每个单元只能和它的朋友交谈：不能和陌生单元交谈； 只和自己直接的朋友交谈。 这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。 很多面向对象程序设计语言用”.”表示对象的域的解析算符，因此迪米特原则可以简单地陈述为“只使用一个.算符”。因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。 通俗地讲，一个类应该对自己需要耦合或者调用的类知道得最少，这有点类似于接口隔离原则中的最小接口的概念。类的内部如何实现、如何复杂都与调用者或者依赖者没有关系，调用者或者依赖者只需要知道它需要它需要的方法即可，其他的一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 优点： 降低复杂度 降低耦合性 增加稳定性 开闭原则(Open-Close Principle)开闭原则是 Java 世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。开闭原则的定义是：一个软件实体类，模块和函数应该对扩展开放，对修改关闭。在软件的生命周期内，因为变化、升级和维护等原因，需要对软件原有的代码进行修改时，可能会给旧代码引入错误。因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。 在软件开发过程中，永远不变的就是变化。开闭原则是使我们的软件系统拥抱变化的核心原则之一。对扩展开放，对修改关闭这样的高层次概括，即在需要对软件进行升级、变化时应该通过扩展的形式来实现，而非修改原有代码。当然这只是一种比较理想的状态，是通过扩展还是通过修改旧代码需要依据代码自身来定。 还是上面的例子， HttpUrlConnImpl 和 HttpClientImpl 实现了 IHttp 接口， 当我们实现 OKHttp 的时候就可以实现 HttpOKImpl， 这样通过扩展的形式来应对软件的变化或者说用户需求的多样性，既避免了破坏原有系统，又保证了软件系统的可维护性。依赖于抽象，而不依赖于具体，使得对扩展开放，对修改关闭。开闭原则与依赖倒置原则，里氏替换原则一样，实际上都遵循一句话：面向接口编程。 优点： 增加稳定性 可扩展性高 避免掉进过度设计的怪圈当你掌握一些设计模式或者手法之后，比较容易出现的问题就是过度设计。有的人甚至在一个应用中一定要将 23 种常见的设计模式运用上，这就本末倒置了。设计模式的四大要素中就明确指出，模式的运用应该根据软件系统所面临的问题来决定是否需要使用现有的设计。也就是说，再出现问题或者你预计会出现那样的问题时，才推荐使用特定的设计模式，而不是将各种设计模式套进你的软件中。 不管在设计、实现、测试之间有多少时间都应该避免过度设计，它会打破你的反馈回路，使你的设计得不到反馈，从而慢慢陷入危险中。所以你只需要保持简单的设计，这样就有时间来测试该设计是否真的可行，然后作出最后的决策。 当设计一款软件时，从整体高度上设定一种架构模式，确定应用的整体架构，然后再分析一些重要的设计思路，并且保证他们的简单性、清晰性，如果有时间可以使用 Java 代码模拟一个简单的原型，确保设计是可行的，最后就可以付诸行动了。切实不要过度的追求设计，适当就好，当我们发现或者预计到将要出现问题时，在判断是否需要运用设计模式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 单元测试--Mock及Mockito]]></title>
      <url>%2F2016%2F11%2F07%2Fandroid-unit-test-mock%2F</url>
      <content type="text"><![CDATA[文章来源：itsCoder 的 WeeklyBolg 项目 itsCoder主页：http://itscoder.com/ 作者：JasonThink 审阅者：@Melo 以前我在内功之自动化测试中说到测试在项目中的重要性。单元测试是一个个「点」（细胞）的重构，是重构的基石，今天我们说单元测试中如何使用 Mock 及 Mockito 的。 Mock 概念所谓的 Mock 就是创建一个类的虚假的对象，在测试环境中，用来替换掉真实的对象，主要提供两大功能： 验证这个对象的某些方法的调用情况，调用了多少次，参数是什么等等 指定这个对象的某些方法的行为，返回特定的值，或者是执行特定的动作 要使用 Mock，一般需要用到 Mock 框架，这篇文章我们使用 Mockito 这个框架，这个是Java界使用最广泛的一个mock框架。 在 Gradle 添加 Mockito 依赖12repositories &#123; jcenter() &#125;dependencies &#123; testCompile &quot;org.mockito:mockito-core:1.+&quot; &#125; 如何使用？我们首先看一下官方的例子:123456//mock creation ListmockedList = mock(List.class);//using mock object - it does not throw any "unexpected interaction" exceptionmockedList.add("one");// selective, explicit, highly readable verificationverify(mockedList).add("one"); 一般使用 Mockito 需要执行下面三步: 模拟并替换测试代码中外部依赖。 执行测试代码 验证测试代码是否被正确的执行 创建 Mock 对象的方式： mock(toMockObject.class) 注解的方式 @Mock，注意要利用注解， 首先要告诉 Mockito 框架， 可以@Rule public MockitoRule mockitoRule = MockitoJUnit.rule); 或者它的实现MockitoAnnotations.initMocks(target); 误区一上面的例子我们进行修改 ==&gt; 为不同于上面的地方，如下:1234567//mock creation Listmock(List.class);List&lt;String&gt; list = new ArrayList&lt;&gt;();//using mock object - it does not throw any "unexpected interaction" exceptionlist.add("one");// selective, explicit, highly readable verificationverify(list).add("one"); 运行发现如下错误： 1234567org.mockito.exceptions.misusing.NotAMockException: Argument passed to verify() is of type ArrayList and is not a mock!Make sure you place the parenthesis correctly!See the examples of correct verifications:verify(mock).someMethod();verify(mock, times(10)).someMethod();verify(mock, atLeastOnce()).someMethod(); 这就是mock的误区一：Mockito.mock()并不是mock一整个类，而是根据传进去的一个类，mock出属于这个类的一个对象，并且返回这个mock对象；而传进去的这个类本身并没有改变，用这个类new出来的对象也没有受到任何改变！ 结合上面的例子，Mockito.mock(ArrayList.class);只是返回了一个属于ArrayList这个类的一个mock对象。ArrayList这个类本身没有受到任何影响，而 list 不是一个mock对象。Mockito.verify()的参数必须是mock对象，也就是说，Mockito只能验证mock对象的方法调用情况。因此，上面那种写法就出错了。 误区二我们先看一个例子：12345678910public class LoginPresenter &#123; private UserLoginTask mAuthTask; public void login(String email, String password) &#123; mAuthTask = new UserLoginTask(email, password); //执行登录操作 mAuthTask.execute(); &#125;&#125; 上面是一个登录操作， 现在我们来验证 login() 函数， 因为它没有返回值，这时候我们只要验证 execute() 有没有执行就可以了。 123456789@Testpublic void testLogin() throws Exception &#123; UserLoginTask mockLoginTask = mock(UserLoginTask.class); LoginPresenter loginPresenter = new LoginPresenter(); loginPresenter.login("jason@gmail.com", "123456"); //验证是否执行 excute() verify(mockLoginTask).excute();&#125; 由于 UserLoginTask 继承 AsyncTask， 所以会报错，同误区一中的问题一样（not mock），这时候我们需要用到 Robolectric 框架，这个可以参考我以前写的。解决这个问题以后你会发现，fuck，怎么还有问题， 什么鬼。。 mock的误区二：mock出来的对象并不会自动替换掉正式代码里面的对象，你必须要有某种方式把mock对象应用到正式代码里面。 这个时候我们可以通过 构造方式将依赖传进去，就 OK 了。 123456789public class LoginPresenter &#123; private UserLoginTask mAuthTask; //===&gt; public LoginPresenter(UserLoginTask mAuthTask) &#123; //TODO test argument //执行登录操作 mAuthTask.execute(email, password); &#125;&#125; 修改测试用例12…LoginPresenter loginPresenter = new LoginPresenter(mockLonginTask); //==&gt; 运行发现终于成功了， 不容易。。 验证方法调用及参数使用Mockito，验证一个对象的方法调用情况：Mockito.verify(objectToVerify).methodToVerify(arguments);其中 objectToVerify 和 methodToVerify 对应上面的 mockedList 和 add，表示验证 mockedList 的 add 方法是否传入参数是 one。 很多时候你并不关心被调用方法的参数具体是什么，或者是你也不知道，你只关心这个方法得到调用了就行。这种情况下，Mockito 提供了一系列的 any 方法，来表示任何的参数都行。 anyString() 表示任何一个字符串都可以。类似 anyString，还有 anyInt, anyLong, anyDouble 等等。anyObject 表示任何对象，any(clazz) 表示任何属于clazz的对象。 举个栗子：1234567 @Testpublic void testDoGet() throws IOException &#123; Http http = spy(new Http(5000, 5000)); URL url = createUrlConnection(); http.doGet(url, ContentType.HTML.str); verify(http).createHttpUrlConnection(any(URL.class), any(Http.Method.class), anyString());&#125; 指定 Mock 对象的某些方法的行为那么接下来，我们就来介绍 Mock 的第二大作用，先介绍其中的第一点：指定 Mock 对象的某个方法返回特定的值。我们见面的 login() 进行修改， 添加对网络的判断， 代码如下： 123456789public void login(String email, String password) &#123; //TODO test argument if(!NetManager.isConnected()) &#123; //添加网络判断===&gt; return; &#125; //执行登录操作 mAuthTask.execute(email, password);&#125; 修改测试代码：12NetManagerWraper netManagerWraper = mock(NetManagerWraper.class); //==&gt;when(netManagerWraper.isConnected()).thenReturn(false); ==&gt; 下面我们说说怎么样指定一个方法执行特定的动作，这个功能一般是用在目标的方法是 void 类型的时候。现在假设我们的 LoginPresenter 的 login() 方法是这样的：123456789101112//执行登录操作, 并且处理网络返回mAuthTask.execute(email, password, new NetworkCallBack() &#123; @Override public void onSuccess(Object data) &#123; &#125; @Override public void onFailed(int code, String msg) &#123; &#125; &#125;); 我们想进一步测试传给 NetworkCallback 里面的代码，验证 view 得到了更新等等。在测试环境下，我们并不想依赖 excute 的真实逻辑，而是让 mAuthTask直接调用传入的 NetworkCallback 的 onSuccess 或 onFailed 方法。这种指定 Mock 对象执行特定的动作的写法如下：`Mockito.doAnswer(desiredAnswer).when(mockObject).targetMethod(args);测试代码如下： 12345678910111213doAnswer(new Answer() &#123; @Override public Object answer(InvocationOnMock invocation) throws Throwable &#123; //这里可以获得传给performLogin的参数 Object[] arguments = invocation.getArguments(); //callback是第三个参数 NetworkCallBack callback = (NetworkCallBack) arguments[2]; callback.onSuccess(null); return null; &#125; &#125;).when(mockLonginTask).execute(anyString(), anyString(), any(NetworkCallBack.class)); 我们想在调用某些无返回值函数的时候抛出异常，那么可以使用 doThrow 方法。如果想简单的指定目标方法“什么都不做”，那么可以使用 Mockito.doNothing()。如果你想让目标方法调用真实的逻辑，可以使用 Mockito.doCallRealMethod()（默认不是的， 请看下文）。 Spy如果我们不指定 Mock 对象方法的行为， 那么他是不是走真实逻辑呢？ 答案是否定的。如果没我们不指定它的行为，对于 Mock 对象的所有非 void 方法都将返回默认值 int，long 类型方法将返回0，boolean 方法将返回 false，对象方法将返回 null 等等；而 void 方法将什么都不做。 然而很多时候，你希望达到这样的效果：除非指定，否者调用这个对象的默认实现，同时又能拥有验证方法调用的功能。这正好是 spy 对象所能实现的效果。创建Spy方式： Mockito.spy(toMockObject); 通过注解的方式@Spy 123456@Testpublic void testSpy() &#123; NetManagerWraper spy = spy(new NetManagerWraper()); assertTrue(spy.isConnected()); when(spy.isConnected()).thenReturn(false);&#125; spy 与 mock 的唯一区别就是默认行为不一样： spy 对象的方法默认调用真实的逻辑，mock 对象的方法默认什么都不做，或直接返回默认值。 Mockito Annotation通过 Mockito 注解可以快速创建 Mock 对象， 这样对于我们这样的懒人来说，是不是很爽。 上面我也简单提到了， 我们可以通过 mock() 和 @Mock 创建， @Mock 就是通过注解的方式创建的， 由于我们使用注解， 当然我们要告诉 Mockito 框架， 不然它怎样知道你使用注解了， 难道它是神吗？ 加上@Rule 就行了， 这样JUnit Rule（？）就会每个测试方法测试前进行检查。添加方法：@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();， 当然创建 spy 对象也可以加 @Spy。 写在最后上面的就是 Mockito 的基本使用， 当然由于并不是很全，更全面的可以看这里。基本的概念都有了， 下面的就是多用， 在项目中发现问题， 然后带着问题去查看文档。 Android 下还可以用 Dagger 动态依赖框架进行测试， 由于涉及到 Dagger 框架的使用，这个我们可以单独来说， 前提是你知道 Dagger 怎样用。 上面代码在 Github 上。 参考http://www.vogella.com/tutorials/Mockito/article.html http://chriszou.com/2016/04/29/android-unit-testing-mockito.html https://medium.com/square-corner-blog/mockito-on-android-88f84656910]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Log打印的正确姿势]]></title>
      <url>%2F2016%2F11%2F07%2Fandroid-log-used%2F</url>
      <content type="text"><![CDATA[大家对输出Log肯定不陌生吧， 任何语言任何程序都少不了Log读出， 程序交付前我们可以用它来调试code， 交付后我们可以用它来排除问题。记得当时用C写程序时，我们经常唱“print 大法好哎！print 大法好哎！print 大法好哎！” Log 的输出是耗时的， 正确的Log打印可以提供工作效率，反之会带来副作用，所以要善用Log打印。有人把程序员分为五类，你可能多多少少有它们中一类或多类的影子。 IDD（IDE-Driven Development），也就是IDE驱动开发，几乎是初学者进入软件开发的殿堂的必经之路。IDE开发者屏蔽了很多细节，并且几乎不用配置（相对于 vim / emacs / sublime）就可以使用代码自动补全，代码跳转，搜索，以及签入签出等软件开发中将会使用到的几乎所有工作。 DDD（Debugger-Driven Development）DDD，面向调试器开发，是 IDD 依赖到一定程度的必然反应。这种开发模式的典型表现为：写出来的代码不知道对不对，从头到尾设置无数个断点，然后进入到调试模式，一个断点一个断点跟踪。发现一个问题，解决一个问题（也许引入一个新的问题），直到所有断点走数遍，所有遇到的问题被消灭，抹一抹头上的汗，心里骂上一句：妈的，这段代码老子（娘）终于调通了！ BDD（Bug-Driven Development）看到 BDD，也就是问题单驱动开发，相信大家都相视一笑。本来这里我想用 TDD（Ticket-Driven Development），更接近我的原意，为了不和 Test-Driven Development 混淆，故而只好改成 BDD。这可能是我们最熟悉的开发模式了 —— 在一个业务稳定的软件公司（甭管规模大小），勉力维护现有的代码，小心地添加新功能是多数程序员的主要职责。在这些公司里，与其说我们是工程师，不如说我们是补锅匠。看不懂代码？没关系，只要你会读日志（出错信息）；解决不了问题？不打紧，能找到 workaround 把问题绕过去也可以，更有甚者，遇到神问题，看不懂，想不明，解不了，还没有 workaround，大笔一挥：not reproducible，就把问题关了，几个月半年后，说不定自己已经去补别的锅了。 RDD（Rat-race-game-Driven Development）RDD，老鼠赛跑驱动的开发，是指那些整个职业生涯都在原地打转的开发模式。Rat race game 是『富爸爸穷爸爸』中的经典例子 —— 老鼠在环形的笼子里拼命地奔跑。 如想了解更多， 请参见原文, 看看作者怎么分析每类人的， 你值得拥有。 好了， 来说说Android的Log打印的一些方法和技巧，为了简单起见，下文中AS就是Android Studio的缩写。 善用adb logcat我看到有些测试人员为了，看程序的Log， 还特意装一个AS。有时候想问为什么不用adb logcat，难道是没有linux下的shell命令吗， 好吧， 被你的无邪打败了。 有时候我们要看一个Java层的奔溃，我仅仅需要下面命令 12adb logcat | grep -i &quot;system.err&quot; 想看看别的，使用process输出格式 12adb logcat -v process AS 使用技巧AS提供了很多的模板功能, 自己也可以根据情况自己定义： 自动填写Tag、方法名和返回值： 动态设置值你在调试时会不也遇到这样的情况，为了进入不同分支，最笨的办法是每次都有修改一下条件变量的代码， 然后重新编译运行。现在我们可以利用debug的setValue(Mac F2)方法动态设置值, 下面代码 变量b 开始等于0， 正常情况下会进入catch条件; 现在我将它修改为2， 它就不会进入catch条件了。 打印你可以用第三方库（logger、LogUtils、timber）或自己改造log框架， 让打印更美观。 总结一万个人心中有一万个丘比特，所有找到一个自己适合的打印方式。 希望大家使用愉快！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android常用的开源项目及其比较系列-网络篇]]></title>
      <url>%2F2016%2F11%2F07%2Fandroid_open_source_network%2F</url>
      <content type="text"><![CDATA[上篇我们谈了谈图片的加载相关的库，在开发中我们少不了请求网络， 主要用到http协议这篇我们继续这个系列，说说开发中我们常用的和网络相关的开源框架有哪些。首先我们去Github上看看排在前几位的和网络相关框架。 通过上图是通过star排序的结果，我们可以发现它们就是Retrofit、okhttp、android-async-http、xUtils。由于xUtils公共的库它不是只支持http，还支持orm、bitmap、view注解，本着专一原则我们项目中就不会选择xUtils， 这里我们就不介绍它了。 下面我们就分别说说Retrofit、okhttp、android-async-http、还要volley。 VolleyGoogle提供网络通信库，在2013年Google I/O大会上推出了一个新的网络通信框架，官方是这样说的: Easy, Fast Networking for Android 特点： 自动调度网络请求 多线程并发网络连接、请求优先级 请求Cache和内存管理 扩展性强 如：支持自定义重连等 支持请求取消 强大的Debug、tracing 缺点： 对于大数据量的网络操作糟糕， 如：下载文件等 下图是它的工作原理图 它的设计目标就是非常适合去进行数据量不大，但通信频繁的网络操作，如list加载等等 项目地址：https://android.googlesource.com/platform/frameworks/volley 技术文档：http://commondatastorage.googleapis.com/io-2013/presentations/110%20-%20Volley-%20Easy,%20Fast%20Networking%20for%20Android.pdf okhttpsquare 开源的 http协议 工具类，Android系统API 19以后HttpURLConnection内部实现就是使用了okhttp 特点： 支持Http/2，Http/2主要支持 SPDY( http://zh.wikipedia.org/wiki/SPDY )协议。SPDY 协议是 Google 开发的基于传输控制协议的应用层协议，通过压缩，多路复用(一个 TCP 链接传送网页和图片等资源)和优先级来缩短加载时间。 如果 Http/2 不可用，利用连接池减少请求延迟 Gzip 压缩 Response 缓存减少不必要的请求 支持请求取消 缺点： 在服务器不支持speedy的情况下没有特别明显的优化 工作原理图 项目地址：https://github.com/square/okhttp RetrofitSquare 开源RESTFUL API库， Retrofit的跟Volley是一个套路，但解耦的更彻底。同时自己内部对OkHtttp客户端做了封装， 用Retrofit+OkHttp基本上已经可以处理任何业务场景了。 特点： 简化了网络请求流程，支持注解请求 支持多种Converter、还可以自定义， 如：Gson、Jackson、protobuf、xml 可以配合RxJava使用 缺点： 看不出缺点是最大的缺点 下面的工作原理图是网友Stay的作品，如下： 项目地址：https://github.com/square/retrofit android-async-http由于HttpClient在Android API 23后就不能使用了， android-async-http内部实现了HttpClient。 这个库我也没有用过， 只是看过一些介绍，下面摘抄了一下官网的说明仅供参考 Make asynchronous HTTP requests, handle responses in anonymous callbacks HTTP requests happen outside the UI thread Requests use a threadpool to cap concurrent resource usage GET/POST params builder (RequestParams) Multipart file uploads with no additional third party libraries Tiny size overhead to your application, only 60kb for everything Automatic smart request retries optimized for spotty mobile connections Automatic gzip response decoding support for super-fast requests Optional built-in response parsing into JSON (JsonHttpResponseHandler) Optional persistent cookie store, saves cookies into your app’s SharedPreferences 项目地址：https://github.com/loopj/android-async-http 总结网络框架就介绍这么多吧， 以后还有合适的再做更新吧， 希望大家使用愉快！ 本文原创于微信公众号 ”自由狂想“ 转载务必注明出处！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android常用的开源项目及其比较系列-Retrofit进阶教程]]></title>
      <url>%2F2016%2F11%2F07%2Fandroid_retrofit_advanced%2F</url>
      <content type="text"><![CDATA[上一篇我们谈了谈Androiod开源项目的网络框架， 比较了它们之间的优缺点，原文在这里 。今天我们着重谈谈Retrofit框架如何更友好的使用，本着提出问题解决问题的原则，也为大家以后解决问题提供基本思路。 目前都有哪些问题？根据官方Demo， 简单使用是这么样的 12345678910public static GithubService create() &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); return retrofit.create(GithubService.class); &#125; 上面代码如果用在实际项目中有如下问题： 只能创建指定的服务，而实际项目中可能有多种服务，如：登录，支付、事件上报、Github URL固定，同样的实际项目中不同服务 base url可能不同。 如果项目https中用到自签名证书该怎么办？ 如何解决问题？上面我们简单提出我们会遇到的问题， 其实总结就是一个问题如何更好的封装Retrofit?对于封装每个人的理解不一样，这就是为什么android中会出现那么多开源网络框架，我一直爱说“没有最好的、只有更好的”。 前面两个问题解决基本思路是首先我们提炼公共部分，然后实现不同的部分,，废话不多说先上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public abstract class HttpClient &#123; public static final String DEFAULT_API_BASE_URL = "https://api.github.com/"; private static final Retrofit.Builder builder = new Retrofit.Builder(). addConverterFactory(GsonConverterFactory.create()); /** * 创建制定api服务 * @param serviceClass * @param baseUrl * @param &lt;T&gt; * @return */ protected &lt;T&gt; T createService(Class&lt;T&gt; serviceClass, String baseUrl) &#123; setApiBaseUrl(baseUrl); OkHttpClient client = OkHttpManager.getOkHttpClient(false); Retrofit retrofit = builder.client(client).build(); return retrofit.create(serviceClass); &#125; /** * 设置base url */ private void setApiBaseUrl(String baseUrl) &#123; String apiBaseUrl = baseUrl == null ? DEFAULT_API_BASE_URL : baseUrl; builder.baseUrl(apiBaseUrl); &#125;&#125; 从上面的代码我们可以看到创建一个createService抽象方法，让子类进行相应的实现。代码如下： 123456public GithubHttpService() &#123; mService = createService(GithubAPIService.class, PAY_API_BASE_URL);&#125; 如何解决自签名问题？解决签名问题之前，我们来说说什么是自签名？因为Retrofit访问网络是通过okhttp去真正进行网络请求的， 而okhttp默认情况下是支持https协议的，比如：https://www.google.com、https://www.github.com。支持的https的网站基本都是CA机构颁发的证书，默认情况下是可以信任的。 当自己搭建https的网站，自己通过keytool去生成一个证书，然后使用，并不是CA机构去颁发的。使用自签名证书的网站，大家在使用浏览器访问的时候，一般都是报风险警告，大名鼎鼎的网站就是这么干的，12306。 如果通过代码访问，可能有如下异常： 12345javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found.javax.net.ssl.SSLHandshakeException: 简单说一下， https协议其实是http+SSL， SSL位于TCP/IP和HTTP协议之间，最终保证数据安全。客服端和服务端建立连接之前需要，先要进行一次握手，基本原理如下： 浏览器将自己支持的一套加密算法、HASH算法发送给网站。 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 浏览器获得网站证书之后，开始验证证书的合法性，如果证书信任，则生成一串随机数字作为通讯过程中对称加密的秘钥。然后取出证书中的公钥，将这串数字以及HASH的结果进行加密，然后发给网站。 网站接收浏览器发来的数据之后，通过私钥进行解密，然后HASH校验，如果一致，则使用浏览器发来的数字串使加密一段握手消息发给浏览器。 浏览器解密，并HASH校验，没有问题，则握手结束。接下来的传输过程将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public static SSLParams getSslSocketFactory(InputStream[] certificates, InputStream bksFile, String password) &#123; SSLParams sslParams = new SSLParams(); try &#123; TrustManager[] trustManagers = prepareTrustManager(certificates); KeyManager[] keyManagers = prepareKeyManager(bksFile, password); SSLContext sslContext = SSLContext.getInstance("TLS"); X509TrustManager trustManager; if (trustManagers != null) &#123; trustManager = new MyTrustManager(chooseTrustManager(trustManagers)); &#125; else &#123; trustManager = new UnSafeTrustManager(); &#125; sslContext.init(keyManagers, new TrustManager[]&#123;trustManager&#125;, null); sslParams.sSLSocketFactory = sslContext.getSocketFactory(); sslParams.trustManager = trustManager; return sslParams; &#125; catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) &#123; throw new AssertionError(e); &#125; &#125; 上面代码主要干了上面几件事 构造CertificateFactory对象，通过它的generateCertificate(is)方法得到Certificate。 然后讲得到的Certificate放入到keyStore中。 通过trustManagers、keyManagers初始化我们的SSLContext 调用如下： 123456789101112131415private void setHttpBuilderSSLParams() &#123; //设置自签名证书相关参数// InputStream[] certificates = &#123;new Buffer().writeUtf8(CER_TEST).inputStream()&#125;; HttpsUtils.SSLParams sslParams = HttpsUtils.getSslSocketFactory(null, null, null); httpBuilder.hostnameVerifier(new HttpsUtils.UnSafeHostnameVerifier()) .sslSocketFactory(sslParams.sSLSocketFactory, sslParams.trustManager); &#125; 如果是单向认证，上面就可以了， 如果是双向的，即服务端要认证客服端的合法性，HttpsUtils.getSslSocketFactory(null, null, null) 后两个参数就是要填client的bsf文件和相应的密码了，一般用在安全性比较高的场景，如：支付。 总结好了， 到目前为止我们已经解决上面所提到的问题了， 这里只是Call使用， 还可以结合RxJava一块使用， 可以让威力变得无穷。 如果你有更好的想法， 可以联系我，一块探讨、进步！ 项目地址:GitHub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android常用的开源项目及其比较系列-序列化篇]]></title>
      <url>%2F2016%2F11%2F07%2Fandroid-open-source-serial%2F</url>
      <content type="text"><![CDATA[在进入今天的主题之前我们来说一下当下比较火的话题， 一个AR类游戏刷爆国外网络社交平台？是的，它就是Pokemon Go，中文意思就是皮卡丘；一个抓精灵手游，通过你的位置信息，根据不同场景的显示不同精灵。不过可惜国内没有开服，听说东北一些地区可以玩。本来不怎么关注游戏的， 也荡起涟漪想体验体验。另一个就是和电影明星赵薇相关的，大家都称“赵薇事件”，一个微博电影宣传照引发的事件。事情刚开始时本来想写一点对此事一些看法的，但还没来得及写，整个事情就像我想想的方向发展了。你猜猜还会不会再次反转，你们还是洗洗睡吧；所以你会发现有些东西不一定是我们看到的， 特别是涉及到政治相关的。 动态注入AndroidAnnotationsbutterknifeDagger序列化JackjsonGsonProtobuf]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android项目持续集成-Travis CI]]></title>
      <url>%2F2016%2F11%2F07%2Fandroid-continuous-integration-travis%2F</url>
      <content type="text"><![CDATA[以前在写代码重构中提到，所有的重构都是建立在测试的基础上的， 没有测试覆盖的重构都是在耍流氓，其中我也提到了持续构建（CI）。传统的、非敏捷的软件创建方法通常依赖于一个更严格管制的开发流。瀑布流程就是这方面的一个示例，其中需求、设计、开发和测试的每个活动都是连续执行的。而现今互联网时期都受益于敏捷开发方式，他们主要采取快速迭代开发、多人协作式开发推动项目的发展。在代码或者项目开发过程中，就能发现问题。 什么是CI(持续集成)？根据 Martin Fowler（现就职于ThoughtWorks） 的观点，持续集成（continuous integration）是一种软件开发实践，要求团队成员经常集成他们的工作。每个人至少每天集成一次，这导致每天有多个集成。集成是通过自动化的构建进行验证的，这些构建运行回归测试，以尽快检测集成错误。团队发现，这种方法会导致集成问题大幅减少，更快地实现有凝聚力的软件开发。 CI的目的就是及早地、经常地改正错误。这样就可以避免它们稍后在项目中发展成为更大、更难解决的问题。该技术提供的好处之一是能够提供在项目时间表中多个日期进行构建和测试的更小的功能性发布。通过验证来自团队的架构、需求和时间表估算，每个交付都降低了项目风险。 知乎上有一个相关问题的回答：如何理解持续集成、持续交付、持续部署？ 大家可以看看。 说了这么多，CI这么好怎么用了？当然CI的工具很多，Jenkins、Travis CI、Circle CI等等。Jenkins现在主要用在工作中，特点是构建比较灵活，插件比较丰富。 Travis CI主要用在个人项目中， 主要于Github结合，构建简单。今天我们来说说Travis CI。 如何使用？通过官网 说明，步骤和把大象装进冰箱一样多，也是三步： 1. 打开开关 2. 新建和配置.travis.yml文件 Travis CI使用YAML文件作为构建脚本，在项目根目录创建.travis.yml文件，下面主要是针对SDK API 23的配置。 android SDK和依赖相关： 123456789101112131415161718192021222324252627282930313233343536373839404142434445language: androidandroid: components: # Uncomment the lines below if you want to # use the latest revision of Android SDK Tools - platform-tools - tools # The BuildTools version used by your project - build-tools-23.0.1 # The SDK version used to compile your project - android-23 # Additional components - extra-google-google_play_services - extra-google-m2repository - extra-android-m2repository - addon-google_apis-google-19 # Specify at least one system image, # if you need to run emulator(s) during your tests - sys-img-armeabi-v7a-android-23 - sys-img-x86-android-17 模拟器相关： 12345678910111213# Emulator Management: Create, Start and Waitbefore_script: - echo no | android create avd --force -n test -t android-23 --abi armeabi-v7a - emulator -avd test -no-skin -no-audio -no-window &amp; - android-wait-for-emulator - adb shell input keyevent 82 &amp; 编译和测试相关： 1234script: - ./gradlew build connectedCheck 也可以指定JDK版本 123jdk: - oraclejdk8 3. 提交.travis.yml文件到远程库上 123456git add .git ci -m &quot;add travis config&quot;git push origin master 更多配置请参考官方文档 配置。 最后自动构建完成后， 所在的项目显示效果如下： 总结从技术角度来看，CI 可以帮助团队更高效地工作。这些团队可能是跨职能的，创建配合工作的硬件和软件。他们在地理上可能是分散的，因为不断的集成工作将会确保您没有偏离设计。人们可以在大型团队中工作，因为复杂系统的不同组件将以更可靠的方式一起工作。CI 解决了许多非传统的敏捷团队在没有 CI 时可能都经历过的早期陷阱。CI 与测试驱动的开发相结合使更多人可以利用敏捷，因为它可以让敏捷方法更高效地工作。 祝大家使用愉快！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 性能优化]]></title>
      <url>%2F2016%2F10%2F28%2Fandroid-performance%2F</url>
      <content type="text"><![CDATA[最近在做 APP 优化，查阅官方说明和一些网友的总结，因为涉及内容比较多， 而且一些在项目上也没有用到，没有更多的见解，在这里进行一下整理笔记。 在Android中，性能和内存的关系很密切，因为系统的整体内存大小会影响所有进程的性能，因为垃圾回收器会对运行期间的性能产生很大的影响。下面的重点是运行期间的性能问题而不是内存。主要分为下面几个方面： 代码性能优化建议 内存优化 渲染优化 减少 App 大小 App 启动优化 App 后台优化 减少图片下载大小 网络优化 代码性能优化建议这个使我们写代码时候要特别注意的， 这里不涉及算法、代码设计， 仅仅这样写执行起来更有效， 主要依赖编译器规则。 基本原则： 不要做冗余的动作，如打篮球时能一步过的，就一步过， 不要像有的球员本来可以过的，感觉刚才的姿势不够优美， 回到半场重新来。 如果能避免，尽量不要分配内存， 如尽量避免在循环语句里分配内存等。 原文： http://developer.android.com/training/articles/perf-tips.html 翻译： [http://hukai.me/android-training-course-in-chinese/performance/performance-tips.html] 内存优化由于嵌入式设备，内存相对服务器来说， 内存还是很宝贵的，还有 Android 对每个 App 内存限制，让我们在开发中使用内存就显得格外注意了。 明白Android会运行多个Activity和多个并行的Service也是很重要的。在最近App列表中切换而不是重新启动一个App的方式对于创造出一种很好的体验是非常重要的。但是这样意味着如果这些app消耗了比它们本应该消耗的更多内存，那么留给其它的应用的系统内存就很少了。如果这种低内存情况发生，应用就不能保留在后台，系统会干掉app的进程，用户就被迫以重新启动的方式去开启一个App，显然这样的体验就比较差。官网： https://developer.android.com/topic/performance/memory.html#remove 翻译： http://www.lightskystreet.com/2016/10/16/android-optimize-memory/ Developing for Android, II The Rules: Memory: https://medium.com/google-developers/developing-for-android-ii-bb9a51f8c8b9 翻译： http://www.lightskystreet.com/2015/06/07/google-for-android-2-memory/ 渲染优化Android 从一诞生到现在已经发布的 7.0 版本，卡顿和不流畅问题却一直被人们所诟病。客观地来讲，Android 的流畅性确实一直不给力，哪怕是某些大厂的 App ，也都不同程度地存在卡顿问题。从开发角度来说，每个开发者都应该关注下性能优化，在平时的开发工作中注意一些细节，尽可能地去优化应用。本文作为性能优化系列的开篇，先从过度绘制优化讲起。官网： https://developer.android.com/topic/performance/rendering/index.html Android 过度绘制优化: http://jaeger.itscoder.com/android/2016/09/29/android-performance-overdraw.html 减少 App 大小主要减少资源文件包括图片， 减少不用的资源。原文： https://developer.android.com/topic/performance/reduce-apk-size.html 翻译： http://www.lightskystreet.com/2016/10/19/android-optimize-image-download-size/ App 启动优化通常用户期望app响应和加载速度越快越好。一个启动速度慢的app很可能会给用户留下不好的印象，除了导致用户在应用市场上的打分低之外，很有可能导致致用户直接卸载。这篇文章提供了优化app启动时间的方法。先解释了app进程启动的内部流程。然后讨论如何优化启动的性能。最后列出几个常见的启动问题和解决方案。官网： https://developer.android.com/topic/performance/launch-time.html#common 翻译： http://www.lightskystreet.com/2016/10/15/android-optimize-start/ App 后台优化后台进程是内存和电池敏感的。一个隐式的broadcast可能会启动很多监听它的后台进程，即使这些进程可能做得工作不多。这可能丢设备性能和用户体验都有比较大的影响。 为了缓解这种问题，7.0（API 24）做了以下限制： Target为 Android 7.0 (API level 24)的App，将不会再收到在mainfest中注册的 CONNECTIVITY_ACTION广播。运行中的App仍然可以在Main Thread中通过Context.registerReceiver()注册 CONNECTIVITY_CHANGE 广播来监听 App 将不能够发送或者接收 ACTION_NEW_PICTURE or ACTION_NEW_VIDEO。这种优化会影响到所有的app，不仅是target为Android7.0的设备。 因此如果你使用了这些intennt，应该尽快的移除对它们的依赖，以便你的app可以在Target为Android 7.0的设备上正常运行。Android框架提供了几种解决方案去减小对这些隐式广播的依赖。比如，JobScheduler and GcmNetworkManager提供了强健的机制去调度特定情况下的网络操作。比如，你也可以使用JobScheduler去响应content provider的变化。JobInfo对象封装了JobScheduler用于调度job的参数。当满足指定的条件的时候，系统会通JobService过执行该job。原文： https://developer.android.com/topic/performance/background-optimization.html 翻译： http://www.lightskystreet.com/2016/10/16/android-optimize-background/ 减少图片下载大小主要如下： 如何选择一种图片格式（PNG、JPG、WebP） 确定准确质量值 服务端的尺寸大小 原文： https://developer.android.com/topic/performance/network-xfer.html 翻译： http://www.lightskystreet.com/2016/10/19/android-optimize-image-download-size/ 网络优化位于在城市中的大多数软件开发者来说拥有一些现代的基础设施和移动网络是很简单的。但很多其它地区并不具备这样的设施。更别说LTE或4G了。很多国家的地区还是2G的网络而且可能还要承受大量数据的传输。这样就会导致两个通用的问题： 依赖于快速的网络速度 App 严重依赖大媒体数据， 在网络基础较差的地方可能没有选择。但是避免下载，直到条件允许的情况下再去下载也是 App 体验的一部分。 多度同步也许你的 App 希望更新一些信息，但是用户并不需要它，更重要的问题，设备并不应该承受所有应用程序与网络不断交互的情况。这种动态会很容易地使设备持续工作而不能够进行休眠，最终影响电池的续航。 原文： https://medium.com/google-developers/developing-for-android-iv-e7dc4ce0a59#.l1kwx8e0n 翻译： http://www.lightskystreet.com/2015/06/07/google-for-android-4-network/ 移动端网络优化: http://b.codekk.com/detail/Trinea/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96 写在最后当然优化不仅仅是上面所说的， 不同场景方案不一样。有人的地方就有江湖、有代码的地方就有优化，代码不止、优化不止。生活当然不是只有诗和远方， 还有代码和段子。 PS：苹果发布新款 MacBook Proc ，我没有看发布会， 第二天看了 KeyNote， 发现除了变薄，并没有特点。还把 USB 给取消了，变亮的 logo 也没有了， 反正让我太失望了，还好我有2015款。你们感觉呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用 Markdown here 排版微信公众号]]></title>
      <url>%2F2016%2F10%2F20%2Fmarkdown-here%2F</url>
      <content type="text"><![CDATA[以前写的文章一般都会发到个人Blog上面去， 并没有发到微信公众号上面前。当然微信公众号的排版一直是让人头痛的问题， 我也知道现在是移动互联网时代， 微信的时代。 有没有小伙在公众号排版上发费的时间超过半个小时以上的？我先默默举个手。 微信公众号申请一年多时间也没有发布几篇文字。有网友在后台给我留言问，问我你微信公众号是多， 一般回答都是xx， 然后默默补上一句里面没几篇文字。 直到突然的某天，在知乎上发现有人说微信后台支持 Markdown 格式（不知道，没关系，下面我们再说，下面的文章 Markdown 简称 MD），当时心里窃喜还专门尝试了一下， 拷贝一段含有 MD 格式的文字， 预览发现不起作用，心里想是不是骗人的， 不科学啊。最后搜索发现可以用 Markdown here 工具将 MD 格式的转换一下。这样微信排版只需要几分钟就可以搞定了。在我们说Markdown here 之前来介绍一下 Markdown， 它才是以后一切的前提啊。 关于Markdown维基： Markdown 是一种轻量级标记语言, 它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 总之就是方便写作，在没用 MD 之前，我是用 Emacs Org-mode 编辑文字和做 TODO list 任务管理。突然某天我发现好多网站后台都支持 MD 了，如简书、Mynote、CSDN等，然后我就这样学习了 MD，并喜欢上它。其实 MD 语法也很简单， 关于 MD 的教程，可以去看看这篇文章： [http://wowubuntu.com/markdown/] Markdown 编辑器其实我最开始用时是 emacs markdown-mode 并加入一些 snippets, 感觉很好。后来 MalkTalk 推荐的写作工具 Ulysses，尝试一下发现它有如下优点： 界面友好 多终端同步 强大的搜索、统计功能 写作我现在一般也用它， 可惜它有点贵。 推荐好评比较多的免费 Markdown 编辑器，下面的两款软件我没有用过，大家可以去试一下，来告诉我， 应该是不错的。Sublime Text 2 + MarkdownEditing/Atom，下面使他们的教程。Sublime Text 2： [http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/]Atom:http://xiaolai.li/2016/06/17/makecs-atom-advanced/ 多说一句，工具是解决问题而产生的，选择一个适合你的就行， 如果没找到，就不断的尝试。 Markdown hereMarkdown here 是个浏览器插件（Chrome/Firefox/Safari），可以将浏览器中编辑器里的 Markdown 文本转换成渲染过后的 HTML。还能自定义 CSS，对应经常使用 Markdown 格式的人来说， 确实是很爽， 你写邮件、文档等用 Markdown 。 装好插件以后， 下面我们只需要下面几步就可是帮你在微信公众号上排版： 将上面写好的拷贝粘贴到微信公共帐号的编辑器中 Ctrl+Alt+M 使用 Markdown Here 渲染 插入图片 Markdown here 默认 CSS 和 Github 的显示样式一样，当然上面我们说过可以自定义 CSS 达到想要的效果。 自定义CSSChrome修改路径： Chrome → 设置 → 扩展程序 → markdown.here → 选项 → 基本渲染 CSS 主要对字体大小、行间距、字间距、字体颜色做修改就可以。总结原则如下： 文章正文的字号最好在14—18px之间，以16px最为合适。 行间距：1.5-1.75倍的行距看起来会比较舒服。 移动端的文章均无需首行缩进。 段落之间最好空一行。 推荐几个人的 Markdown here 自定义样式吧。阳志平李笑来版 如果你现在使用的是 Web 版的邮箱，你也可以 Markdown 来书写你的邮件内容，在最后通过 Markdown Here 一键渲染，格式化邮件样式。 祝大家使用愉快！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[至那些时期迷茫的我们]]></title>
      <url>%2F2016%2F10%2F17%2Flost-self%2F</url>
      <content type="text"><![CDATA[最近和一朋友聚会聊天， 大家都感慨我们已经步入 「 而立之年 」，但是我们还是再爬着 Coding。北京的房价这么高， 一月工资连一平米厕所都买不起，路在何方？我还自嘲说， 干了这杯白牛二，睡一觉什么都有了。 我们在叹息、在迷茫，活着不易，生活更不易。记得前一段时间写过 「五年北漂生活 」 表达过类似的观点，选择就不要放弃， 要紧牙关，一闭眼一切都会过去的。每个人都或多或少都迷茫过， 如果你告诉我你没有， 那你一定不是人，一定是神。今天我们不谈神界的事， 哪天我们再聊哈。 为什么会迷茫？为什么会迷茫？简单来说就是一件事件想不明白、想不开。房价这么高， 奋斗一辈子也在北京买不起一套房子，就会迷茫问自己，那还该不该去奋斗？ 记得半年前迷茫我技术方向到底往广的方向走，还是往深的方向走？是走技术路线还是偏向于管理？我还因为这些事情和我们 CEO 聊过类似的话题，他没有直接回答我， 给我讲他当时遇到类似这样的问题是怎么解决的。 上面可以看出迷茫是长时间过程， 短时间之内不一定能解决。下面我们聊聊怎么度过这段空床期。 如何度过迷茫期？当然不能仅仅依靠自己的双手， 而是不断的社交， 这样才能有机会度过空窗期，意淫是解决不了问题的。好了，按照这个思路来，就很好解决了。总体来说分为下面几个方面： 不断学习， 保持亢奋。 拜访比你层次高的人， 哪怕是付费的。 行动，再行动 不断学习， 保持亢奋简单的说就是多读书，读好书。有人会有这样的疑问，每次都是看了圣贤书，打了鸡血后奋斗两天，过去了又低沉下去？很简单就是每过两天读一本圣贤书就行了。 说的读书， 可能要牵扯到如何读书呢？这个问题一两句说不清， 这里涉及到学习系统。 推荐你一本书 「 如何阅读一本书 」。 有些小伙伴，希望我推荐几本书， 其实我是决绝的。因为每个情况不一样， 好书太多。你多读就是，总有一天你会找到适合你的书。 拜访比你层次高的人， 哪怕是付费的好的导师能够看到你自己看不到的地方。人这一辈子，很少人能给自己一个清晰的评价和认知，要么高估自己，要么低估自己，而旁观者，尤其是老师，往往能够看到你的弱点、长处，可以给你提醒和指导，少走弯路。所以在你这里的迷茫， 在他那里可能找有答案，交流很重要。 那么问题来了， 怎么找好的导师呢？几种方式都行， 一种是公司高层， 既然能做到这个位置， 肯定有他牛 X 的地方。 如果你不认同他的，你也要学会去聆听，如果这样也做不到，那就是你的问题。 另一种在网上能找到， 一般主要的社交平台上都有他们的账号， 如微博、知乎等。 他们一般都有自己的微信公众号，和不同形式的社群（一般都是付费的）。为什么要付费？能迅速筛选目标用户，顺便挣点零花钱，这样他们才能持久输出，毕竟都要生活。 还有真正最牛叉的， 一般网上都找不到他们， 原因很简单就是他们太忙， 根本没有时间扯淡，一般这样的人目标就是我们先挣它，一个亿，呵呵，开个玩笑， 不过你大概知道他们是什么级别的喽 。不过我们现在可以不考虑，等你到了那个 level， 你才可以进入他圈子， 是的， 他们有圈子， 属于他们自己的圈子。 行动，再行动仅仅读书时不够和请教导师是不够的，他们给你的一个方向， 你一定要去跟着做， 一定要在路上。就像你仅仅看篮球视频， 你不去练习，永远不会上篮。 很重要，很重要，很重要！ 写在最后好多人会说， 上面的道理我都知道， 就是做不到。 告诉你其实道理你不知道， 那时别人的道理，不是你的。如果你真知道，你就会去做。 如果有太多问题想不明白、想不开， 解决办法只有一个， 认真思考，不断的思考、不停地思考，等到活的久了， 想明白的事情多了， 就不那么迷茫了。 祝大家不那么迷茫！ PS：最近在整理设计模式，刚刚开始，等写好后分享给大家， 大家可以关注我的 GitHub，我在一点点整理，如果有兴趣的可以一起。项目地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[国庆假期感想--谈谈房价]]></title>
      <url>%2F2016%2F10%2F07%2Fholiday-think%2F</url>
      <content type="text"><![CDATA[国庆假期还剩最后一天，大家好多应该在准备或回来的路上， 有多少人和我一样，有上班前综合证的。好吧， 写的东西不让你们看出来这个假期我什么也没做。 我一直在探索，也不断问自己这样走对吗，试图找到一条适合自己的路， 可惜还在路上。最近发生的事情，给我一定的触动， 也写写自己的看法吧。 房价首先我们来说说房价， 大家应该都知道连续几个月房价以火箭的速度上升，周边人谈论最多的也是房价。网上也出现类似 「十大败家、旺家排行榜」、人民日报微信公众号评论员文章称「失去奋斗，房产再多我们也将无家可归」。干实业的不干实业去炒房的， 大有人在。最后 ZF 看不下去了， 10.1 前后北京、深圳、杭州、南京、郑州等19个城市出现限购政策调控房价。 有人会问， 那么我们到底要不要买房子？3、4个月尽量不要买房子，持现就好。具体逻辑就不展开说了，简单说一下，接下来几个月要发生的事件： 十八届六中全会10月24日至27日的召开， 肯定会讨论房价新政策。 加息肯定跑不了，有人估计12月份。 限购政策会越来越严，不会放松。 房价下降问题的 ZF的解决方案是，下面是知乎网友的看法， 感觉有一定道理: 问: ZF、开发商、已购房者、银行的利益如何维系?答:房产税, 他估计17年房产税具体实施方案会公布。问:当房价下降20%，逐步出现弃房断供时，如何处理?答:法律约束。问:土地价格下降，地方ZF的贷款、债务、融资平台怎么办?答:债务转移。问:基于买方买涨不买跌的心理，市场会立刻降温，开发商欠的钱咋办?答:CDS（信用违约互换）。 真是不得不买房的， 像不买不给你结婚，那么买房一定注意下面的条件： 教育配套+医疗配套+生活设施配套（主要因素) 房企品牌+物业口碑+发展前景（辅助因素） 普通人逆袭国庆假期大熊老师写了一个逆袭系列「普通人如何年入xx 」，从10万一直写到300万。 告诉我们每个阶段需要的条件和行业。前几个阶段努力一般努力就能达到，后几个阶段还需要把握风口。 那我来说说，年入五十万， 为什么？好吧， 被你看出来了，是的我还没赚到。他提到的目前看最容易靠谱的，大概就是写作、社群和小吃。 写文章变现的方向有很多， 你可以去做广告， 你也可以去做培训， 还可以做社群。大熊老师也是这么做的，他也做到今天的成就。 做小吃， 第一步就是你一定要让它做的好吃， 如果没有这个前提， 别的都别谈。其实以前我也和朋友谈到这个话题， 吃的方向以后是中央厨房。当然这个行业就是比较辛苦，这个收入阶层，你想不辛苦， 也不太可能。 写在最后没有买房的最近不要出手， 观望，看 ZF 下一步动态吧，房产带动整个GDP增长这件事本身就可悲， 到头来受伤的总是老百姓。 如何实现人生逆袭， 每个人目标不一样，所处的阶段也不样，选好自己的下一个目标，一步步去实现， 抓住机遇更重要，不要动不动就说我先赚它 1 个亿， 醒醒吧， 你不是王首付。有一点很重要大方向不能错， 告诉你富人会越来越有钱， 穷人会越来越穷。21 世纪最缺的是什么， 告诉你不是人才， 是资源，好好想想资源都在那里， 你就会明白了。 祝你们最后一天过的快乐！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit源码解析（一）]]></title>
      <url>%2F2016%2F09%2F17%2Fandroid-retrofit-01%2F</url>
      <content type="text"><![CDATA[本人以前写的Android网络框架时介绍过Retrofit，原文在这里，也做过对Retrofit库进行简单的封装工作， Github源码再这里， 在这里就不多说了。当时使用的时候简单看了一些源码，发现源码中大量使用设计模式，包括Facade、Factory、Proxy、Strategy、Adapter、Observer等等，是我辈学习设计模式的好案例。当然Android源码也大量用设计模式， 只是太分散了。 不要为了设计而设计 在这里多说一些， 不要为了设计模式而设计，相反是因为写也块的时候，正好可以能用这种设计模式而已， 总之好的代码是重构出来的，不是设计出来的。 就像金庸武侠小说里风清扬的独孤九剑一样， 虽然只有短短的九个招式， 但每个招式又有不同的变化。这也是为什么比较喜欢C语言的地方， 语法就那么简单，但不同的组合就能干任何事情。 如何阅读源码本人一直的观点是”授人予鱼、不如授人予渔”，这是我写这些的东西的目的之一。其实没有太多的技巧， 就是死磕，但是要有策略的死磕。好吧， 你们有福了， 正好最近看到一篇相关的，里面也讲一些有用的技巧，分享给大家： 与编程一样，阅读别人的源代码永远不是一件轻松的事，或者说，是一件困难的事情，需要持续的投入，阅读、研究、把玩、实践。很多人觉得拿到了源代码就像买了本书一样，放到书柜上，马上就有种学会了的感觉，但真正实践起来才会体验到强烈的挫败感。大部分情况下，读不下去，不是方法不好，而是投入度不够。 阅读源代码，一定要找到好的开源项目。什么是好的项目？口碑好且应用广泛的项目就是好项目，比如 Docker、Spring、OpenResty，都是非常好的阅读素材。另外，完善的文档和足够的 test case 覆盖率，都是衡量一个开源项目是否优秀的标准。很多人说，代码即文档，好的代码本身就是自解释的。但是，对于规模宏大的开源软件来说，没有文档是不可想象的。所以在阅读源代码之前，一定要读文档。尽管读了文档之后，你可能不知道代码的技术细节，但至少可以了解项目的轮廓。结合开源项目的代码目录，差不多可以绘制出一个粗粒度的整体架构图。 然后为每个目录（或模块）做记录和标识，逐一阅读，或者直接去读你最感兴趣的部分。 我读源代码喜欢自顶向下的方式，先把整体脉络理清楚，然后按照模块去阅读代码，把类和类、函数和函数之间的调用关系记录下来，如果可以进行逆向工程，用类似 Intelli IDEA 这样的工具把代码之间的调用关系用 Diagrams 展现出来，阅读会更加直观一些。 另外，阅读 test case 同样能帮助你理解作者的代码设计意图，正常情况下，测试用例都是从文档和设计衍生出来的，而不是完成了代码再写 test case。阅读测试用例，可以让你更清晰的知道对应的类和函数想要做什么事情（笔者注：测试用例很重要）。 阅读源代码需要顺手的工具，我自己喜欢用 Vim，配合 NERDTree、Cpmmand-T、ctags、taglist 等插件，Vim 可以成为一款优秀的代码浏览工具，而且非常轻量级。你可以通过命令行迅速打开、关闭、查找和索引程序，并进行有效的关联跳转（静态代码）。如果你不习惯，也可以用 Sublime Text，Atom 等工具。当然，如果你要进行调试和跟踪，那最好使用相关程序栈的 IDE 工具了，比如 Eclipse、Jet Brain 系列工具，Xcode 等，这样你可以在 debug 状态跟踪所有的函数调用和变量参数在执行时间线上的变化。(笔者注：Emacs也很好，也是本人比较喜欢的) 重复一句，工具和方法永远不是最重要的，去读，并在遇到困难的时候，看不明白的时候，咬牙坚持下去，抽丝剥茧，逐个击破。最终，你会在冰冷黑暗的二进制世界里面看到一张地图，找到一座灯塔，然后去解释和还原这个底层世界里每一个细微方面的语义，重建出高层次的抽象概念和关系（这个观点和笔者一致）。 正文上面扯了那么多还没进正文， 看来要分两篇来下了，本文主要分析的源码版本是2.0。 Retrofit 可以分为注解解析（Request 生成），请求执行，请求回调（异步处理），响应体转化几个部分。其中请求执行与请求回调可以算作一个部分，并且请求回调也可以没有，同步请求操作Call 直接执行的接口 execute。 还是上一张详细的设计图把， 这里偷一下懒吧， 不自己画了， 这个以前帖过，现在版本总体设计没有什么变化。 主要是围绕着 converter，CallAdapter 设计的整个框架，剩下的下篇再说吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[打造最强终端-iTerm 2]]></title>
      <url>%2F2016%2F09%2F11%2Fiterm2%2F</url>
      <content type="text"><![CDATA[作为一名程序猿，都避免不了使用终端。本人使用不同终端， Linux下的Terminator、Emacs自带的终端等， 都没有今天要说的“小公举”（iTerm 2）好使，谁用谁知道。话不多说先上张图： 安装Mac：1brew install iterm2 zsh众所周知在Unix/Linux系统下是存在很多不同的shell，常见的就有bash, csh，ksh，zsh等等。在Linux和MAC OS系统中，默认使用的是bash。这里我们介绍功能更加强大的 zsh。它兼容 bash， 所以 bash 的一些常用东西，它还能用。但是zsh配置太过复杂， 还好他的 wife 拯救了他， 让他进行华丽的转身，是的她就说oh-my-zsh，它支持更多插件和主题，在这里[https://github.com/mbadolato/iTerm2-Color-Schemes ]。 安装 zshUbuntu：1sudo apt-get install zsh Mac：1brew install zsh 安装oh-my-zsh1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 当然再加上 autojump 智能跳转会感觉更棒，比如想跳转 project下， 可以 j + pro 。更多的配置大家可以参考 MacTalk 下面的文章： MacTalk:[http://macshuo.com/?p=676] Hotkey Window (快速调出窗口)实际使用时我们经常会遇到这种场景： 有时候只是执行几行命令，然后就不再使用它。可是我们还是必须要打开Terminal，然后使用后关闭它。在这种情况下借住iTerm的Hotkey Window 功能我们将会得到前所未有的体验。Hotkey Window支持一键调出iTerm 它将以半透明的形式 覆盖在屏幕上方，配置如下：本人配置的快捷键是F12 基本操作主要是快速移动光标位置、删除一个单词、字母等， 这个和Emacs使用快捷方式是一样的， 也不知道是谁借鉴谁的， bash的也是这么操作的。 control + a: 到行首 control + e: 行末 control + f/b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快 control + p: 上一条命令，相当于方向键上 control + r: 搜索命令历史，这个大家都应该很熟悉了 control + d: 删除当前字符 control + h: 删除之前的字符 control + w: 删除光标前的单词 control + k: 删除到文本末尾 control + t: 交换光标处文本 control + u: 删除一行 ⌘ + —/+/0: 调整字体大小 ⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到窗口操作 shift + command + d（横切）command + d（竖切） 关闭窗口：shift + command + w 前一个窗口：command + ` 后一个窗口：command + ~高效功能 粘贴历史：使用Command + Shift + h 可以呼出粘贴历史，支持模糊检索。 全屏模式：command+enter command+; 根据上下文呼出自动完成窗口，上下键选择 即时回放：Command + Opt + b 打开即时回放，按Esc退出。即时回放可以记录终端输出的状态，看看你以前都干了啥。 历史信息查找和粘贴：command + f，呼出查找功能，找到后 tab 键可以选中找到的文本，通过option + 回车粘贴 Expose Tabs：option + command + e PS:今天是教师节， 想起交过我的老师了， 祝他们节日快乐，也祝所有老师节日快乐！ **本文原创于微信公众号 ”JasonThink“ 转载务必注明出处！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提问的艺术]]></title>
      <url>%2F2016%2F08%2F17%2Fquestion_art%2F</url>
      <content type="text"><![CDATA[本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 其实如何更好提问的话题， 网上已经有很多写过，而且有的写的也很好， 那为什么我还要拿来说？第一是因为它太重要、太重要、太重要，第二发现还是有很多人没有抓住本质，再加入个人的一些理解，希望能真正帮到大家。 在面试工程师的时候我经常会问他们一个问题（以前面试的时候也被问过），你觉得你和一个只有一两年经验的工程师比，你的优势是什么？很多人只能回答：工作经验 ；然后问他具体体现在哪些方面，很多人很难说清楚，读完这篇文字你可以找到答案！ 我们对某个事物的认识，总是“由浅到深”。虽然同样是由浅到深，但每个人思考的深度却千差万别。不幸的是，大多数人在看待某个东西（事物、问题、现象）的时候，都仅仅停留在浅层次。为什会这样？一个主要原因就是：大部分人不善于提问。原因可能和我们的接受教育方式有关， 在我们的中小学教育阶段，根本就没有教会学生，该如何提问、该如何质疑、该如何反思。这里给大家提问一个问题， 为什么呢？难道老师水平不够？大家可以思考一下！ 充分思考后，再去提问大家可能都知道人类和其他动物的本质区别是我们人类拥有独立思考的能力，可是好多人都没有用好， 就像我上面说的都仅仅停留在浅层次。同样的，某个人之所以能从社会中脱颖而出，善于思考往往是重要因素（不是唯一因素）。 今天好多网站，如知乎等， 当你要提问时，它会提示你先去搜索一下， 有没有类似的问题， 但是事实上很多人，还是自动屏蔽提示，不管宝宝的苦（哈哈， 最近宝宝真的很苦）， 还是提很类似的问题。经常有一些人会问我，你的博客是怎么搭建的，你的域名是怎么绑定的。不是说你问问题不对， 而是我以前的文章以前说过， 你简单搜索就能找到答案。好多人一遇到问题第一反应就是提问， “大神， XXXX”， 告诉你我不是神我是人，现在想到一个好玩的场景， 很多人遇到问题， 都会说， 神啊， 救救我吧。 神真能救你吗， 只是一种安慰吧！ 阅读的时候也是一样的，你要始终带着问题来阅读。一边接受信息，一边摸索这些问题的答案。对得到的信息进行分析、过滤、取舍。 善用搜索引擎我们常说通过搜索能解决我们生活和工作中的80%问题，但前提你会使用搜索。还是有好多人不会正确组合关键字，很多时候就是关键词组织，组合的问题，你在搜索一个问题的时候，对关键词要有各种组合方式，如果无效的答案太多太杂，要学会增加限制性关键词过滤，如果搜索不到任何结果，或任何有价值结果，要学会减少一些非关键的限制性关键词，来扩展搜索结果的多样性，其实说白了就上面这两条，多尝试而已。 如果你是搞技术和科研的， 最好用的就是google， 没有之一，可是很可惜，现在国内不能用， 所以你想用要学会如何科学上网。google也有很多使用技巧，但是技巧这东西不要盲从， 适合自己就好。 如何用好 Google 等搜索引擎:https://www.zhihu.com/question/20161362?rf=19798921 结构化思维,层次化提问当我们遇到问题， 看看能不能将问题才分成若干小问题。 如何拆分问题呢？当然是先分析，通过一步步提问排查问题，举个栗子，一个很常见的场景，手机不能上网，没有信号？不是，设置页有问题？设置没有问题，浏览器能打开网页吗？不能，路由器有问题吗？没有，重启手机可以吗？重启了， 欠费？ 是的，发现宽带欠费了。还用我们定位程序问题时经常用二分法去排除问题， 一点点缩小范围，直到找到问题。 你是不是有一种整体的判断方式，能够用排除法快速找到方向，用一步步递进的方式逐渐剥出真相。很多很多人一上来就开始猜答案，基于他们认定的答案来提问，这是特别坏的一个习惯，因为这样找问题几乎就只能凭运气了。 心态保持开放心态，保持理性、冷静（这个很难做到，包括自己，现在有些事情也做不到）。大多数人都有自己的一些既有观点（成见）。如果你没有开放的心态、或者过于感性，就会对不同的观点持一种排斥的态度。如果你尚未经过思考就排斥某个观点，就很可能走偏。 写在最后有些人工作十年，你说经验丰富？ 但同样重复的经验他用了十年，所以建议大家永远保持一颗学习的心态。做事一定要保持： What - “What is it?” 你要搞清楚某个东东是【什么】样子的？有【什么】用处？有【什么】特性？有【什么】语法？ How - “How to do?” 你要搞清楚某个东西，其内部是【如何】运作的？【如何】实现的？ Why - 就是搞清楚某个东西【为什么】设计成这样？【为什么】不是另外的样子？这样的设计有什么讲究？ 推荐一本书《学会提问——批判性思维指南》，好了， 就写这么多吧， 希望大家读的愉快！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[五年北漂生活]]></title>
      <url>%2F2016%2F08%2F09%2Ffive-years-bj-life%2F</url>
      <content type="text"><![CDATA[周末参加圈内朋友的读者见面会，见到了一些网友，聊了一些创业和肉身翻墙的话题。让我更感慨的是几年过后，再回头看看这过往的经历，发现有些事情当时做的时候并没有发现有多大用处，但是多年以后你会发现对自己的影响起到确定性的。比如：码字、Steve Jobs在上学的时候逃课学习画画等。当你迷茫的时候可以在当下把一件事情做好的， 多去行动， 先不要老想结果，脚踏实地的把整个过程走完。 也见到覃超，前Facebook工程师，他现在从工程师转型到投资方向了，他的文章很有自己的见解和深度，如在“Sheryl Sandberg 在UC Berkeley的2016毕业演说”中提到3个P，Personalization、Pervasiveness、Permanence。更多关于他写的文章请关注他的知乎或公众号（可以搜索覃超帝国兴亡史）。 也聊到北漂的话题， 谈到北京高房价问题。正好昨天出去办点事回来比较晚，一个人走在满是霓虹灯的马上，想起《北京北京》歌里写到： 当我走在这里的每一条街道我的心似乎从来都不能平静除了发动机的轰鸣和电气之音我似乎听到了他烛骨般的心跳我在这里欢笑我在这里哭泣我在这里活着也在这死去我在这里祈祷 我在这里迷惘我在这里寻找 在这里失去 211年毕业，那年我二十三岁，我女朋友也二十三岁， 花一般的年纪，也记得我们在校园中散步日子， 可能那些日子再也回不去了。最近微信同学群里，看到那些一起对瓶吹酒的少年们， 有多少人干过类似的事件。有图有真相：时光荏苒回想这五年的北漂生活，是时候做个小结了。 当初的理想实现了吗？曾经的梦想还在吗？ 记得当时给自己定的目标， 给自己五年时间看自己是不是适合做什么，找到自己的定位。这一干就是五年，五年我实现了什么？ 北京现在北漂有800多万人，从卫星地图上也找不到自己居住的家，到目前为止我搬家4次，从北京北边到西边在到东边， 地图上我已经把北京爬了大半圈了。 5多么神奇的一个符号，一个支配天地之气、梦绕的数字。 我属于哪里呢？北京是我的归属的土地么？ 说实话我不知道， 我只是偶然的机会踏上了这篇土地， 并没想扎根在这里。这里见证过我的迷茫与徘徊，见证过我的纠结与失落，最后也见证过我的尝试与行动。 见证过我在这里结婚、生子，可惜没能在这里置办房产（不能怨我幺）。 我的年纪也快到30岁了， 我也把青春奉献给了这座城市。多少次在梦里呼喊着你的名字，北京、北京，一个让人又爱又恨得城市。 你准备漂到什么时候？ 我不知道， 我只是一个北漂， 飘到什么时候，我也不知道，漂已经成了我生活的一部分，深深打上烙印，我生活在农村， 初中短暂离开父母，独自在县城上学，大学离开的家乡，另一个城市求学；毕业后又到北京漂泊。 随着年纪的增长，我肩上的胆子越来越重，父母的年纪也开始大起来，除了要负责养家，社会的繁杂，我们要面对。 未来不可期， 下一个五年、十年，我不知道是否还在北京， 但我现在能确定的是， 这种漂，还将继续， flighting！ 下面是知乎上对北漂的回答,分享给大家，共勉吧。 站在今天是看不见的，也不必看；过五十年再回头，自然就能看到。也许这一代人其实是时代的宠儿，也许这一代人成为了时代的炮灰，也许这一代人挽起袖子改变了这个时代。都有可能。但站在今天不宜多想，多想无益。看不到未来在哪，但还能坚持向前走，沿途偶尔还能乐呵乐呵。能做到这样的，了不起。看不到未来在哪，但还能坚持向前走。能做到这样的，也是正常人。看不到未来在哪，就没法向前走，亟需看到一条出路……这样，就是被幻想毒害的一代人。借用弗洛姆的说法，安全和自由不可兼得。你想要生活得更自由，就必须承担相应的不安。世界上本没有路，你走过去了，它就是你的路。 本文原创于微信公众号 ”JasonThink“ 转载务必注明出处！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android常用的开源项目及其比较-图片加载篇]]></title>
      <url>%2F2016%2F06%2F18%2Fandroid-open-source-summary%2F</url>
      <content type="text"><![CDATA[我们在开发中经常会用到一些开源的项目，不可否认互联网技术的快速发展就是站在这些优秀的开源项目的肩膀上的。每个公司都离不开开源项目，这个是他们快速迭代产品的基石，不过现在许多优秀的开源项目都是国外公司和个人主导的，国内现在还处在拿来阶段，不过国内现在环境的正在变好，相信不远的将来会更好。扯的都是题外话，下面进入今天的主题， 当然Android开发中也不能免俗， 毕竟Android系统本身就是一个开源项目，这也是为什么能快速占领市场的原因，当然也带来一些弊端，主要是涉及商业问题， 不能很好闭环。下面来说说我个人在Android项目中一些常用的开源框架，主要包括图片加载、网络、序列化、动态注入、ORM、测试、其他。考虑长文章大家不喜欢读，还是分开来写吧 图片加载 UIL(Universal Image Loader)人如其名，是很早开源的图片缓存，在早期被很多应用使用。 UIL aims to provide a powerful, flexible and highly customizable instrument for image loading, caching and displaying. It provides a lot of configuration options and good control over the image loading and caching process. 下面是官网图片加载原理图优点： 支持多线程下载，并支持进度监听，如监听ImageLoadingListener类 可以在View滚动中暂停图片加载 默认实现多种内存缓存算法， 如LRU、FIFO、UsingFreqLimited（如果缓存的图片总量超过限定值，先删除使用频率最小的bitmap）、LargestLimited（当超过缓存限定值，先删除最大的bitmap对象） 支持本地缓存文件名规则定义缺点：个人项目， 现在不在维护。 PicassoSquare 开源的项目，且他的主导者是 JakeWharton，没错也是butterknife作者，下面我们要也介绍它，想想都知道JakeWharton在Android领域的地位。通过名字你能发现，有多么霸气。噢，有些童鞋可能不认识，好吧，算了告诉你吧， 没错就是毕加索。优点： 支持图片缓存使用的监控，包括缓存命中率、已使用内存大小、节省的流量等。 支持优先级处理，每次任务调度前会选择优先级高的任务，比如 App 页面中 Banner 的优先级高于 Icon 时就很适用。 支持延迟到图片尺寸计算完成加载 支持并发线程数根据网络类型而变，如手机切换到飞行模式或网络类型变换时会自动调整线程池最大并发数，比如 wifi 最大并发不一样 本地缓存，通过交给okhttp去实现的， 这样的好处是可以通过请求 Response Header 中的 Cache-Control 及 Expired 控制图片的过期时间。缺点：对多帧动画支持不是很好 GlideGoogle 员工的开源项目，被一些 Google App 使用，在Google I/O 上被推荐，不过目前国内用的也少， 我也没用过只是写过Demo。 FrescoFacebook开源的图片缓存，这个我也没在项目中用过， 等到1.0后会考虑， 持续关注中，不过特点很明显包括： 更像一个自定义控件的使用 两个内存缓存加上 Native 缓存构成了三级缓存 支持流式，可以类似网页上模糊渐进式显示图片 对多帧动画图片支持更好，如 Gif、WebP 更多样的显示，如圆角、进度条、点击重试、自定义对焦点 总结共同特点 使用简单， 一两行代码可以搞定问题 可灵活配置， 包括内存缓存、本地缓存、线程池、缓存算法、网络请求框架、图片处理 多级缓存 支持多种数据源， 包括网络、本地、资源、Assets 等 只看不用假把式、只用不看傻把式、又看有用才是真把式。先介绍这么多吧，下一篇我们聊聊常用的网络框架。 本文原创于微信公众号 ”自由狂想“ 转载务必注明出处！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何实现财富自由-《富爸爸、穷爸爸》]]></title>
      <url>%2F2016%2F06%2F09%2Frich-dad-poor-dad%2F</url>
      <content type="text"><![CDATA[介绍[富爸爸、穷爸爸] 最早1997发行，2003出版的简体中文版，原名[ Rich Dad, Poor Dad] 。本书作者罗伯特·T·清崎，美国夏威夷出生，第4代日裔美国人，富爸爸系列书籍的主要作者。以提倡理财智商（财商）的教育著名。 1977年，清崎在业余时间创办生产“冲浪者”钱包的企业，日渐成长，令清崎毅然放弃在施乐的高薪厚职，全职投身企业，更曾一度借此致富，然而由于拍档在产品成功之后，变得松懈，令清崎决定离开，后又在拍档要求下，为拯救濒危公司而再次加入，最后由于中国大陆、台湾等地不断有仿冒品出售，打击尼龙生意，公司亦难逃倒闭命运。虽然如此，清崎彻仍然坚持开设公司，经过九个月无工资收入，晚上睡在车子里的艰难日子后，他的创业理想终于成真，包括在中国、委内瑞拉等地，收购或开设石油公司等。其中房地产收入丰硕，更令他明白到现金流对致富极为关键，亦成为他在“富爸爸”系列中，一再强调的致富方法。最后他在47岁时，与妻子金一同达成财务自由，两人更到斐济度假庆祝。退休生活期间，清崎彻决定重操父亲故业——教师，希望透过游戏，将致富心得广为传授，便在深山隐居两年，专心钻研与理财有关的游戏。1985年，“现金流游戏”(CASHFLOW GAME)终于面世。为更易向大众介绍该游戏概念，他开始执笔撰写“富爸爸·穷爸爸”，结果大受欢迎，连续六年成为纽约时报最畅销书籍。因此他随后更与友人合作创办一家国际教育公司“富爸爸理财教育”，配合现金流游戏，教授理财观念。并曾主持电视节目。 本书主要分几个部分： 1.不为钱工作2.分清什么是资产什么是债务3.现金流4.调整心态、开始去行动 学会不为钱工作 作者的观点是不要为钱工作， 要让钱为你工作。全世界到处都有聪明、才华横溢、受过良好教育以及极具天赋的人。大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。财商是会计、投资、市场和法律等各方面知识和能力的综合。将上述4中技能结合起来，以钱生钱就会更容易的多。当涉及钱的时候， 只有一项技能的人不得不努力工作，就像笼子的小老鼠，不停地转圈一样。作者还举了一些例子，如麦当劳为什么更赚钱，难道他做的汉堡是世界上最好吃的汉堡吗？答案显而易见：他们拥有一套出色的商业体系。许多才华横溢的人之所以贫穷，就因为他们只是专业做好产品，而对商业体系知道的很少。精通专业技能是优点也是缺点，就像我现在的IT行业，很多非常有天赋，但不善于与他人沟通。如以前flash很火的时候，一部分人进入了这个方向。现在flash在真正被html5取代后，不会别的技能那部分人面临失业。 分清什么是资产什么是债务 资产是能把钱放进你口袋里的东西。 负债是能把钱从你口袋里取走的东西。 作者的观点是如果你想致富，只需不断买入资产就行了，富人之所以富有，是因为 他们在某些方面比那些有财务问题的人更有知识，所以如果你想获得财富并保证财富，财务知识是十分重要的， 它包括对文字和数字两方面的理解。作者也举了自己的买入资产的例子，通过买房产、买小公司的股票、研究法律找到避税的办法。那么我就问自己，在中国我能如何买入资产，如果几年前购买房产是个不错的主意，但是现在在北上广等一线城市买房，对我个人来说已经超出我能承受的风险了，股票等也不懂， 不懂的东西，暂时不要去碰。现在能做的就是那一部分钱，参加培训，投资自己，增加财商；另一部分先做理财，让钱流通起来。有人说互联网金融一定是未来体系中的重要的一环，在我看来这是未来趋势。 风险关于什么是风险？如何控制风险？有一篇文章解释的很形象，凡是不确定性的都是风险。地址：http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712310&amp;idx=1&amp;sn=be92fd4969d78f5a3783535b8c34f0fc&amp;scene=0#wechat_redirect 现金流 调整心态、克服困难 作者还提到人们通过学习掌握了财务知识，但在通向财务自由之路上仍然面临着很多障碍。掌握财务知识的人有时候还是不能积累丰厚的资产项，分为以下原因：1.对可能亏钱的恐惧心理2.愤世嫉俗的心理3.懒惰4.不良习惯5.自负 开始去行动作者说每个人都拥有理财天赋，问题是这种理财天赋一直处于休眠状态，等待有人将它唤醒。建议我们采取以下十个步骤来开发这种才能，而这种才能只有你才可以控制：1.需要一个超越现实的理由–精神的力量2.每天做出自己的选择–选择的力量3.慎重选择朋友–关系的力量4.掌握一种模式，然后学习一种新的模式–快速学习的力量5.首先支付自己–自律的力量，如果你控制不了自己， 就别想着致富6.给你经纪人以优厚报酬–好建议的力量7.做一个“印第安给予者”–无私的力量8.用资产来购买奢侈品–专注的力量9.对英雄的崇拜–神话的力量10.先于后取–给予的力量 总结 赚大钱是靠运气的，勤奋和能力是赚小钱的保证。运气可遇不可求，但我们总要生活，在努力奋斗赚小钱的同时，去理解整个金融社会、信用体系的应用规则，对每个人摆脱金钱的束缚非常有帮助。 尽管读了他的书未必能财务自由，但如果想财务自由的话，确实需要知道上述观念。还有作者的投资方式，由于时代和环境不一样，不推荐照搬， 每个人都应该有一些变通。但是他的思路完全可以学习，研究法律漏洞、规避税收、寻找存在信息不对称的商业机会、利用法律条款减少支出…… 如何积累现金流？每个人都要很长的路要走，上士闻道，谨行之，中士闻道，若存若亡，能不能坚持做简单的事情，也是衡量个人素质的指标。行动和学习是关键，祝世界上都是真正的富人，为富人干杯！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何实现一个朋友圈--简介篇]]></title>
      <url>%2F2016%2F05%2F29%2Fproject_weixin_introduce%2F</url>
      <content type="text"><![CDATA[背景由于本人在带一个小朋友学习编程，从去年12份到现在算起已经有半年多了， 主要学习的技术栈是java。到了收获的季节，想让它做一个项目把以前学习的知识点串起来。一直在为选什么项目纠结，最后把目标落在朋友圈上，为什么不选其它项目，例如图书管理系统呢？不是因为简单， 对于初学者来说没有简单的项目， 好多人包括自己当初都有-“这东西太简单了，烂大街了，没有技术含量”-的想法。只有你认真去做，你才真正能get到相应技能。理由如下： 产品大家都很熟悉，交流成本低（我们不在同城） 包括前端、后端以及它们之间数据交互；比较全面覆盖技术栈 3. 发现朋友圈对细节的处理，把产品做到极致，这也是马化腾、张小龙等牛x之处，也是腾讯生存之道。 可以进行扩展， 简单能用—支持高并发、低延时—多区域同步 技术选型下面谈谈都用那些技术栈 前端前端APP用android开发，整体框架要符合mvp模式，中间肯定会涉及到各种自定义控件开发，其中也包括视频、图片预览。 后端主要语言用java开发，http响应服务用nginx搭建，部分考虑性能问题的用C++，主要用于高并发响应的地方。用于这个项目不是一个人参与，用Github托管代码，为方便以后review code以及协同开发。 功能介绍重要功能大家应该很熟悉了， 分别有发布、点赞/评论、刷新朋友圈。如果要做一个商用的系统，后台开发还是比较麻烦的， 要考虑突发事件， 比如最近的陆家嘴事件， 你就会发现， 这个时候服务器的峰值可能最高。 发布内容包括大量的图片和视频，而且又都是静态数据， 可以通过cdn进行缓存。多个数据中心间的数据同步问题，包括国内、国外的用户。 为了避免增加学习难度，秉承着“万丈高楼平地起”原则， 这个项目我们就做个单节点服务。 项目计划由于平时需要上班，只能利用休息时间，计划8-10周完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android单元测试-Robolectric]]></title>
      <url>%2F2016%2F05%2F20%2Fandroid-unit-test%2F</url>
      <content type="text"><![CDATA[背景今天我们不谈why，以前写过两篇关于测试的文章， 好处就不多说了， 总之就是为了提高产品的质量，以TDD驱动开发。 今天我们讲讲如何用Robolectric进行android单元测试。Robolectric Robolectric is a unit test framework that de-fangs the Android SDK jar so you can test-drive the development of your Android app. Tests run inside the JVM on your workstation in seconds. 配置这里不多说请参考官方配置。 Activity1234567@Beforepublic void setUp()&#123; //获取activity mainActivity = Robolectric.setupActivity(MainActivity.class); turnBtn = (Button) mainActivity.findViewById(R.id.btn_login);&#125; 带有@Before注解的函数在该类实例化后，会立即执行，通常用于执行一些初始化的操作，比如构造网络请求和构造Activity。带有test注解的是单元测试的case，由Robolectric执行，这些case本身也是函数，可以在其他函数中调用，因此，case也是可以复用的。每个case都是独立的，case不会互相影响，即便是相互调用也不会存在多线程干扰的问题。 创建Activity12345@Testpublic void testActivity()&#123; assertNotNull(mainActivity); assertEquals(mainActivity.getTitle(), "Robolectric Sample");&#125; Robolectric只提供运行环境，逻辑判断还是需要依赖JUnit中的断言。 Activity生命周期123456789101112@Testpublic void testLifecycle() &#123; ActivityController&lt;MainActivity&gt; activityController = Robolectric.buildActivity(MainActivity.class).create().start(); MainActivity mainActivity = activityController.get(); TextView textView = (TextView) mainActivity.findViewById(R.id.text_lifecycle); assertEquals("onCreate", textView.getText().toString()); activityController.resume(); assertEquals("onResume", textView.getText().toString()); activityController.destroy(); assertEquals("onDestroy", textView.getText().toString());&#125; Robolectric.buildActivity()用于构造Activity，create()函数执行后，该Activity会运行到onCreate周期，resume()则对应onResume周期。由于MainActivity的onCreate、onResume中改变了TextView的内容， 可以通过判断textView的值来进行判断。代码如下： 1234567891011@Overrideprotected void onResume() &#123; super.onResume(); lifecycleTextView.setText("onResume");&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); lifecycleTextView.setText("onDestroy");&#125; Activity跳转1234567@Testpublic void testStartActivity()&#123; turnBtn.performClick(); Intent expectedIntent = new Intent(mainActivity, LoginActivity.class); Intent actualIntent = ShadowApplication.getInstance().getNextStartedActivity(); assertEquals(expectedIntent, actualIntent);&#125; 测试广播广播的测试点可以包含两个方面，一是应用程序是否注册了该广播，二是广播接受者的处理逻辑是否正确，关于逻辑是否正确，可以直接人为的触发onReceive()方法，验证执行后所影响到的数据。 12345678910111213141516171819/** * Broadcast Receiver */@Testpublic void testBroadcast()&#123; ShadowApplication shadowApplication = ShadowApplication.getInstance(); String action = "com.example.jason.test.login"; Intent intent = new Intent(action); intent.putExtra("USERNAME", "jasonim"); //是否注册广播接收者 assertTrue(shadowApplication.hasReceiverForIntent(intent)); MyReceiver myReceiver = new MyReceiver(); myReceiver.onReceive(RuntimeEnvironment.application, intent); SharedPreferences sharedPreferences = shadowApplication.getSharedPreferences("account", Context.MODE_PRIVATE); assertEquals("jasonim", sharedPreferences.getString("USERNAME", ""));&#125; service的测试和广播类似， 具体实现可以看Github的Demo Shadow采用Shadow的方式对Android中的组件进行模拟测试，从而实现Android单元测试。Robolectric针对Android SDK中的对象，提供类很多shadow对象， 如： ShadowActivity、ShadowListView等等。对于一些Robolectirc暂不支持的组件，可以采用自定义Shadow的方式扩展Robolectric的功能。 自定义Shadow创建User的Shadow对象 1234567@Implements(User.class)public class ShadowUser &#123; @Implementation public String getName() &#123; return "jason"; &#125;&#125; 其中@Implements是声明Shadow的对象，Shadow还可以修改一些函数的功能，只需要在重载该函数的时候添加@Implementation，这种方式可以有效扩展Robolectric的功能。还需要自定义TestRunner，将User对象添加它上面：123456789101112131415public class CustonShadowTestRunner extends RobolectricGradleTestRunner &#123; public CustonShadowTestRunner(Class&lt;?&gt; klass) throws InitializationError &#123; super(klass); &#125; @Override public InstrumentationConfiguration createClassLoaderConfig() &#123; InstrumentationConfiguration.Builder builder = InstrumentationConfiguration.newBuilder(); /** * 添加shadow的对象 */ builder.addInstrumentedClass(User.class.getName()); return builder.build(); &#125;&#125; 看看如何进行使用12345678910@Testpublic void testCustomShadow()&#123; User user = new User("jasonim"); //由于自定ShadowUser 重重载getName() 实际上调用ShadowUser的方法 Log.d(TAG, "test log"); assertEquals("jason", user.getName()); ShadowUser shadowUser = (ShadowUser) ShadowExtractor.extract(user); assertEquals("jason", shadowUser.getName());&#125; 自定义的Shadow需要在config中声明，声明写法是@Config(shadows=ShadowUser.class) TODO网络测试TODO数据测试总结总之没有测试代码的代码都是在耍流氓， 当然测试代码不用所有的case都覆盖到，主要代码的主要逻辑和核心代码覆盖就行了， 具体怎么取舍看实际决定。项目就那么几个人，老板又再屁股后面催，那就需要你想办法， 但是不能不写测试代码，哪怕以后补上。本文的Demo在Github上。地址：https://github.com/jasonim/JasonAndroidSimple/tree/master/robolectricsample 参考http://www.jianshu.com/p/9d988a2f8ff7]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android 自动化测试-Espresso]]></title>
      <url>%2F2016%2F05%2F14%2Fandroid-auto-test-espresso%2F</url>
      <content type="text"><![CDATA[以前写过一篇关于为什么要进行自动化测试，自动化测试的重要性， 文章在这里。 那篇文章中只写一些原理，没有进行实例；本着”不要只说说、 just do it”，下面我们说说今天的主角–Espresso框架。 自动化测试简介目前移动App的自动化测试框架比较多，比如：Robotium、Expresso等，很多大公司甚至都会有自己的一套自动化测试框架。这篇文章简单Android自动化测试框架，iOS自动化测试框架也会少量提到。 Monkey是Android SDK自带的测试工具，在测试过程中会向系统发送伪随机的用户事件流，如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试，也有日志输出。实际上该工具只能对程序做一些压力测试，由于测试事件和数据都是随机的，不能自定义，所以有很大的局限性。 MonkeyRunner也是Android SDK提供的测试工具。严格意义上来说MonkeyRunner其实是一个Api工具包，比Monkey强大，可以编写测试脚本来自定义数据、事件。缺点是脚本用Python来写，对测试人员来说要求较高，有比较大的学习成本。 Instrumentation是早期Google提供的Android自动化测试工具类，虽然在那时候JUnit也可以对Android进行测试，但是Instrumentation允许你对应用程序做更为复杂的测试，甚至是框架层面的。通过Instrumentation你可以模拟按键按下、抬起、屏幕点击、滚动等事件。Instrumentation是通过将主程序和测试程序运行在同一个进程来实现这些功能，你可以把Instrumentation看成一个类似Activity或者Service并且不带界面的组件，在程序运行期间监控你的主程序。缺点是对测试人员来说编写代码能力要求较高，需要对Android相关知识有一定了解，还需要配置AndroidManifest.xml文件，不能跨多个App。 UiAutomator也是Android提供的自动化测试框架，基本上支持所有的Android事件操作，对比Instrumentation它不需要测试人员了解代码实现细节（可以用UiAutomatorviewer抓去App页面上的控件属性而不看源码）。基于Java，测试代码结构简单、编写容易、学习成本，一次编译，所有设备或模拟器都能运行测试，能跨App（比如：很多App有选择相册、打开相机拍照，这就是跨App测试）。缺点是只支持SDK 16（Android 4.1）及以上，不支持Hybird App、WebApp。 Espresso是Google的开源自动化测试框架。相对于Robotium和UIAutomator，它的特点是规模更小、更简洁，API更加精确，编写测试代码简单，容易快速上手。因为是基于Instrumentation的，所以不能跨App。配合Android Studio来编写测试的简单例子 Selendroid：也是基于Instrumentation的测试框架，可以测试Native App、Hybird App、Web App，但是网上资料较少，社区活跃度也不大。 Robotium也是基于Instrumentation的测试框架，目前国内外用的比较多，资料比较多，社区也比较活跃。缺点是对测试人员来说要有一定的Java基础，了解Android基本组件，不能跨App。 Athrun是淘宝出的一个移动测试框架/平台，同时支持iOS和Android。Android部分也是基于Instrumentation，在Android原有的ActivityInstrumentationTestCase2类基础上进行了扩展，提供一整套面向对象的API。这里有详细介绍。 UIAutomation是iOS平台下的测试框架，目前用的比较多的框架。 Appium是最近比较热门的框架，社区也很活跃。后一章我会重点介绍这个自动化测试框架。 如何使用？官方已经给出了例子， 学习一样东西就是先将它做一遍，重复造轮子，切记不要只是看看，要多动手，看完你感觉你懂了， 其实你不懂。废话不多说， just do it。 官方地址：http://developer.android.com/training/testing/ui-testing/espresso-testing.html Config在build.gradle中配置Espresso，增加的代码如下：12345678910111213141516171819apply plugin: 'com.android.application'android &#123; ... defaultConfig &#123; ... testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; packagingOptions &#123; exclude 'LICENSE.txt' &#125;&#125;dependencies &#123; ... androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.1' androidTestCompile 'com.android.support.test:runner:0.2'&#125; 功能创建MainActivity类， 能够输入姓名和年纪： 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); View submit = findViewById(R.id.btn); assert submit != null; submit.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; clickContent(); &#125; &#125;); &#125; private void clickContent() &#123; Intent intent = new Intent(this, Main2Activity.class); EditText editName = (EditText) findViewById(R.id.edit_name); EditText editAge = (EditText) findViewById(R.id.edit_age); assert editAge != null; int age = Integer.parseInt(editAge.getText().toString().trim()); assert editName != null; String name = editName.getText().toString().trim(); intent.putExtra("person", new Person(name, age)); startActivity(intent); &#125;&#125; Main2Activity: 123456789101112131415public class Main2Activity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); Person person = getIntent().getParcelableExtra("person"); if(person.name.equals("jason") &amp;&amp; "20".equals(person.age)) &#123; TextView textView = (TextView) findViewById(R.id.result); assert textView != null; textView.setText("ok"); &#125; &#125;&#125; 测试类在测试的package中创建MainActivtyTest测试类, 使用正确输入进行测试，检查结果是否与预期的一致。 123456789101112131415161718@RunWith(AndroidJUnit4.class)@LargeTestpublic class MainActivityTest &#123; @Rule public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;( MainActivity.class); @Test public void verifyWithRightName()&#123; onView(withId(R.id.edit_name)).perform(typeText("android"), closeSoftKeyboard()); onView(withId(R.id.edit_age)).perform(typeText("wrong"),closeSoftKeyboard()); onView(withId(R.id.btn)).perform(click()); onView(withId(R.id.result)).check(matches(withText("ok"))); &#125;&#125; (GitHub地址)[https://github.com/jasonim/JasonAndroidSimple/tree/master/espressosample] 参考Android Testing Support Library]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Dagger 2进行依赖注入]]></title>
      <url>%2F2016%2F05%2F10%2Fandroid-dagger%2F</url>
      <content type="text"><![CDATA[当我们写代码时总会遇见好多依赖关系，为了解决依赖达到代码之间的低耦合，通常我们会运用依赖注入技术。通常如下两种方式解决依赖： 静态依赖注入动态依赖注入（java中通过注解方式实现）本着what-how-why原则去进行分析问题、解决问题。 原理依赖注入的原理网上有很多，大家可以看看，我找了两篇，感觉写不错。 martinfowler codethink dagger在 Android 上比较流行的有 RoboGuice、Dagger 等。其中 Dagger 是我现在正在项目中使用的。 Dagger已经加入Google I/O, 是Square开发的依赖注入库, 发布2.0版本. Dagger表示有向非循环图(Directed Acyclic Graph, DAGger). 好处和优点有很多, 参考, 所有优秀的开源库, 本质上都是让程序更加清晰, 编写更加容易. 让我们来看看怎么使用? dagger2主要包含inject, module, component三个部分, 即:Inject, 依赖注入dependency injection, 把定义的类注入声明.Module, 模块, 提供若干类, 在依赖注入中使用.Component, 组件, 注册若干模块至项目中. show me the code我想现在有好多疑问，那就让我们行动起来看看怎么使用dagger。 Configurebuild.gradle 配置如下： 1234567891011121314151617181920212223apply plugin: 'com.neenbedankt.android-apt'//project gradle buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4' &#125;&#125;//module gradleandroid &#123; ...&#125; dependencies &#123; apt 'com.google.dagger:dagger-compiler:2.2' compile 'com.google.dagger:dagger:2.2' provided 'javax.annotation:jsr250-api:1.0' ...&#125; Module @Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的 依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。 @Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。 12345678@Modulepublic class ActivityModule &#123; @Provides UserInfo provideUserInfo() &#123; return new UserInfo(); &#125;&#125; UseInfo: 123456789public class UserInfo &#123; public String name; public String age; public UserInfo() &#123; this.name = "jason"; this.age = "20"; &#125;&#125; Inject@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。 Dagger给了我们一堆选择用来注入依赖： 构造方法注入：在类的构造方法前面注释@Inject 成员变量注入：在类的成员变量（非私有）前面注释@Inject 函数方法注入：在函数前面注释@Inject 12@InjectUserInfo userInfo; Component@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如 果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。 12345678910111213@Component(modules = ActivityModule.class)public interface ActivityComponent &#123; void inject(MainActivity activity); final class Initializer &#123; private Initializer() &#123; &#125; // No instances. public static ActivityComponent init() &#123; return DaggerActivityComponent.builder().activityModule(new ActivityModule()).build(); &#125; &#125;&#125; Invoke1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mActivityComponent = ActivityComponent.Initializer.init(); mActivityComponent.inject(this); Log.d(TAG, userInfo.name + userInfo.age);&#125; 源码的GitHub 下载地址 参考Tasting Dagger 2 on Android]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github教程整理汇总(更新)]]></title>
      <url>%2F2016%2F04%2F30%2Fhow_github%2F</url>
      <content type="text"><![CDATA[更新2016-8-5以后的更新将放在Github上，请我的关注Github， 项目地址：https://github.com/jasonim/github-guide更新2016-6-18 Github大家应该不陌生吧，如果你没有用过，现在开始用起来吧。目前不用梯子可以直接访问，里面2110万代码仓库，包括google、Facebook等公司优秀作品和示例。它可以进行代码托管、wiki、问题追踪、可以通过github pages托管自己的静态网站、还有论坛功能。当然代码托管是它最大的亮点，[认真在github上逛一年，比你在大学四年学的东西要多的多 ]，东西就在那里了，你去挖吧。很多内容网上都有人写了，但是比较零散， 本着分享的原则，在这里整理一下。 GitGit是一个分布式版本控制工具，这个是使用github基本的工具，我也不是git高手，只会基本的一些命令， 够用就好， 本着遇到问题解决问题的原则就行了。文档当然首推官方文档 了。 描述：廖雪峰写的Git教程，比较实用，里面包括远程仓库、分支管理等功能。我也看过他写的Python教程。 地址：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 如果你不喜欢命令的，你可以装一个Github desktop管理Github上代码，个人推荐命令行。 Github Pull RequestGit多人协作工具， 当然少不了为一个现有仓库提交自己发现的bug了，下面是知乎上的教程 https://www.zhihu.com/question/21682976 TODO多人协作如何发现优秀的开源项目？Github上项目那么多， 怎么发现找到你想要的项目，主要分为下面几类： 目的导向型， 就是通过搜索获得你想要的项目， 这个最直接。 关注一些活跃的大牛， 懒人必备 Trending功能，让你发现最近比较热门的项目 最近发现Stromzhang写一篇详细的文章：地址：http://stormzhang.com/github/2016/07/28/learn-github-from-zero7/ 视频教程主要是Git视频教程 youtube(需要科学上网): Learn git in 20 minutes Git Video Tutorial1-4 # 总结 更新：最近发行stromzhang写了从0开始学习GitHub系列系列的课程很详细,涵盖了我上面所有的内容：从0开始学习GitHub系列之 初识GitHub从0开始学习 GitHub 系列之「加入 GitHub」 从0开始学习 GitHub 系列之「Git 速成」从0开始学习 GitHub 系列之「向GitHub 提交代码从0开始学习 GitHub 系列之「Git 进阶 最重要是去动手去做，多说无益， 让github飞起来吧，祝学习快乐！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈缓存]]></title>
      <url>%2F2016%2F04%2F17%2Ftalk_cached%2F</url>
      <content type="text"><![CDATA[缓存无处不在，比如磁盘缓存、Web 缓存、网络缓存、分布式缓存，等等，这些是我们在开发系统软件和互联网服务时常常要用到的技术。 缓存的意义？简单来说，缓存是存储数据的一个临时场所，由于获取原始数据的代价太大了，所以，我们会把一些使用频繁的数据放到一个更容易读取，操作更快的池子（一般是内存）里，为这些数据分门别类，打上标签，这样用户发来请求的时候，我们先在缓存池里进行快速检索，如果拿到数据就直接返回给用户；如果没有，再去数据库或其他介质获取原始数据返给用户，同时把该数据打上标签，放入缓存池。 网络世界也是一样，如果没有缓存，用户所有的请求都会直接穿透层层网络，打到数据库和磁盘 IO 上，随着数据量的增加，用户每次请求的时间会越来越长，这样的后果是，磁盘不爽，数据库不爽，用户不爽。 原理既然缓存这么重要，拥有大量用户的互联网应用都应该增加缓存服务了，那么是不是搞个 Hashtable 就可以了呢？我们可以先了解一些缓存的术语。 缓存命中用户发起了一个热点数据的请求，系统接收到这个请求之后，就需要根据用户的数据信息（key）去缓存池里寻找数据，如果根据用户提供的 Key 找到了这个条目，并返回给用户，这个过程叫一次缓存命中。 如果在缓存里没找到需要的数据，在缓存空间还有空闲的情况下，系统会去原始数据源（一般是数据库）获取信息，返回给用户，并把数据条目存储到缓存中，以备不时之用。如果缓存空间已经达到上限，那么就要根据缓存替代策略，把旧的数据对象销毁，把新的对象放入缓存池。 对于缓存服务的设计来说，命中率高的缓存系统，性能越好，命中率高，消耗的时间和资源越少。所以缓存服务并不是简单的搭建一个 Memcached、Ehcache 或 Redis 就可以了，相关的技术，应用在合适的业务场景中，才能最大化的利用缓存的价值。 缓存成本上述场景中，缓存没有命中的时候，系统会从原始数据源中获取数据，一般是数据库或文件系统，然后再把数据放入缓存池中。这个过程需要的时间和空间，就是缓存成本。 一般为了避免缓存成本过高，系统初始化的时候，会同时进行缓存池的初始化，把我们需要的，已知的数据尽可能多的提前放入缓存池，这样可以最大程度的提升缓存命中率，降低缓存成本。但不适用在数据量大的场景，例如双11秒杀。因为不能在较短时间内遍历缓存key，而且初始化缓存请求过多，也将给后端机器造成压力。 缓存失效当缓存中的数据需要更新的时候，说明缓存中的数据已经失效了，这时候就需要有相关的服务进行实时的数据更新，同时要保证数据的一致性，不能让系统拿到已经失效的数据到处去招摇撞骗，这种情况，系统和用户的内心，都是拒绝的。 大家知道在高并发下会缓存失效，会带来后台服务压力增大，解决这种问题有好多方法，大家可以参考下网上应对Memcached缓存失效，导致高并发查询DB的几种思路 替代策略编程新手一般会觉得内存是可以无限使用了，看到服务器上标着 64G 内存这样金光闪闪的配置之后，他们会觉得「广阔天地，大有可为」，于是在系统里 new 出了一个又一个的 Hashtable，然后不停的往里面加入数据读出数据，事实上，如果系统简单，这样做一时半会还真出不了系统问题。如果是系统级的缓存服务，要考虑的事情就比较多了。 每个缓存产品，一般都会有一个类似 maxmemory 的最大内存使用参数，这个参数肯定是小于物理内存的。一旦缓存数据达到上限，而又出现缓存没有命中的情况时，系统就会踢出一些老弱病残的缓存数据，加入新条目。判断老弱病残的标准是什么呢？这就是替代策略。最理想的做法当然是把最没用的数据踢出去，但是，做到最理想永远是最难的，就像你永远想找到团队里最没用的那一个将其淘汰掉，但执行的时候总是极其艰难。 常用算法常用的一些算法包括：FIFO、LFU、LRU、LRU2、ARC等。 FIFO 就是先进先出，一种非常简单的算法，缓存数据达到上限的时候，最先进入缓存的数据会最先被踢出去。很多老员工看到这一条都义愤填膺，所以，这个算法注定是不被喜欢的，但是由于它简单直接，很多开发者喜欢。嗯，有些企业老板也比较喜欢。Second Chance 和 CLock 是基于 FIFO 的改进，算法更加先进合理，也更复杂，Google「缓存算法 CLock」等。 LFU 的全称是 Least Frequently Used，最少使用算法，系统会为每个对象计算使用频率，最不常用的缓存对象会被踢走，简单粗暴。 这里看到一个形象的比喻： 缺点是，一个传统工业时代曾经被重用过的老员工，在互联网时代没用了，由于其前期使用频率很高，吃老本，所以数据会一直保存在缓存系统中，反而是后起之秀，往往会遭遇到误杀的不公正待遇。 LRU 的全称是 Least Recently Used，也就是最近最少使用算法。基本思路是，如果一个数据最近一段时间被使用的频率很少，那将来被用到的可能性也会很低。 LRU2 和 ARC 都是基于 LRU 的改进 很多我们耳熟能详的缓存产品，比如 Memcached、Redis、Ehcache、OSCache等，都参考了类似的算法，要么进行加强，要么进行简化，目标就是提升缓存的命中率，降低缓存成本。 总结缓存原理就是这些， 但是在实际工作中远没这么简单，特别在大数据、高并发情况问题就更多了。“Talk is cheap. Show me the code”，抱歉没有，以后争取写一些demo…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[写代码的正确姿势-内功之自动化测试]]></title>
      <url>%2F2016%2F04%2F10%2Fhow_code_auto_test%2F</url>
      <content type="text"><![CDATA[在写代码的正确姿势-剑招之重构 中我们谈到重构的时机和如何重构等等。 你想想下面的场景： 你利用重构之术让代码更简洁， 可读性更好，更高效，修改完成后，你泡上一杯清茶，躺在你的人体工学座椅上还在沉浸在刚才的美好之中， 这时QA找到你， QA：请问你刚才提交代码了吗， 答曰：是的 QA: 你修改的那部分功能跑不通了，你没有测试吗 答曰：是吗， 我看看 ….. 子曰：一切没有自动化测试的代码重构都是耍流氓。如果你重构了代码，却破坏了基本的功能，纵使代码再漂亮，性能再高，又有何用？ 自动化测试那么如何保证重构不破坏既有的功能？答曰：测试。无论你是单元测试，功能测试，集成测试，还是哔哩哔哩测试，总之你需要尽一切可能去测试。重构有一个个「点」（细胞）的重构，所以你需要单元测试；也有一个个「切面」（器官）的重构，所以你需要功能测试；当「切面」的改动甚大（器官移植），还需要集成测试…相关的测试是否存在决定了你能否重构；而测试所花费的时间直接决定了你是否会进行重构，以及以一个什么样的频率进行重构。如果重构了十行代码，却需要花费一个小时进行运行一次单元测试，那么你要么不会去重构代码，要么你重构了不会去测试。 好的重构发生在构建系统的每时每刻，而非问题发生或者老板要求。如果重构之后测试立刻会告知你结果，你会更有信心进行更多的重构，使其成为你工作生活的一部分。 你也许会质疑：什么样的单元测试可能会需要一个小时来完成？答曰：手工测试。这是为什么先验条件不是「测试」，而是「自动化测试」。没有自动化测试（以下简称测试），谈重构纯属扯淡。如果要重构的环节测试覆盖率不好，先想法提高覆盖率。 如何分配测试精力？单元测试一般是开发人员最应该关注的事情，单元测试只是测试一个方法单元， 他不是测试整个流程没有问题。例如它不是测试汽车有没有问题， 而是仅仅测试轮胎有没有问题。就像我们学单词以前，都要先学习音标。当然每部分没有问题不能说明整个没有问题， 可能衔接、依赖有问题呢？而单元测试会比较完整的测试每个单元的各种不同情况、临界等等。一般来说， 如果每个环节都没问题， 对应整个流程来说成功概率就会很高， 至少在通往成功的路上。 有种这方面的理论叫做 Test Pyramid, 如下图： 主要理念就是，单元测试时基础， 我们最应该花时间的地方，而集成测试应该是冰山上的一小部分。why? 主要原因是集成测试比较麻烦，运行起来比较慢， 发现的 Bug 少， 对于改善代码质量上面起不到任何作用， 由于它的重要程度并不那么高， 相反单元测试运行速度超快，能发现的bug更多，在开发时能引导更好的代码设计，在重构时能保证重构的正确性，因此它能保证我们的代码在一个比较高的质量水平上。所以大量的集成测试一般会放在测试部门那边去做。至少我们是这样做的， 当然对应服务器开发来说， 还要有压力测试， 对应 Android 开发来说意义不大。 TODO 测试驱动开发在测试驱动开发（TDD）这本书也写到，如何利用测试驱动开发。 总结然而由于大环境问题，大家都赶着上线， 自动化测试内功这一块， 很多忽略的， 大部分测试靠人肉。特别是移动开发来说， 好多都在嘴上说，「天下武功为快不破」，当我听到这样的话， 就想将他拉出去枪毙了，快是够快， 就是出问题给他擦屁股时候很难擦。 子曰：读万卷书不如行万里路。行动起来吧， 用实践说话，实践是检验真理的唯一标准。如果根本没有测试用例，请先做好这个基本功再谈重构。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我眼中的生活]]></title>
      <url>%2F2016%2F04%2F04%2Fmy-year-life%2F</url>
      <content type="text"><![CDATA[今天是清明节最后一天，大家是不是刚从外面玩回来了啊，家里小孩感冒刚好没有出去玩，尽管出去也到处堵车，到处都是人。基本上在家宅了三天。说实话想出去转转。几个朋友也打电话问我约不，只能任性的回答他们不约。节前一个晚上大概八点半，和朋友一块打球回来，在等红灯时候看见两辆房车从我们面前经过，朋友说，你看人家，再看看我们，人家那才是生活，我们这是充其量只是个生存。我笑笑说，那是我们向往的生活，留在梦想里吧，万一哪天实现了。 假如生活欺骗了你你是不是有这样的经历，经常听到老板在办公室骂员工，有时候你会害怕，你想哪天是不是该轮到我了，有时候你也会问自己: 这是我要的生活吗？ 难道这不是你自己选择的吗？ 不，这不是我自愿的，我是被生活所迫的。 假如让你重选，你还会选择现在的生活吗？ 记得我还没毕业的时候，同学问我，你以后毕业了就打算干计算机这行吗，我是这样回答的，先干着吧，以后再说吧。其实我没有别的选择，家里有没背景，也没别人有力气，不干这个我还能干什么啊。据我了解当时全专业一百零几人，从事自己本专业的也就那么十几个人。刚来北京的时候住在亲戚家，住了10个多月时间吧，一分钱也没给过，当时我和一个同学一块来北京的，他当时就没我幸运了，当时他在城中村租了房子，记得第一次我去找他玩，刚好下暴雨，去他家的路上都是积水，最深的地方到了大腿了。到我到他屋里时，屋里也没有窗户，还住着三个人，屋里烟味、臭鞋味交加一起，那酸爽你无法想象，在那里我住了一个晚上都快要窒息了，而他在那里住了大概一年。 大家会说，不是生活所迫，谁有钱会住那里啊。现在一块的时候偶尔我会问他，你还记得刚来北京的日子吗，你后悔来北京吗。他说不后悔，不来你怎么知道 ，你是不是属于这里啊。 小结生活就是这样，你来与不来，它就在那里。生活不易，且行且珍惜吧，生活也不只是苟且。这里先引这么多，以后慢慢展开吧，我眼中还有那些生活呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提高android开发的效率工具]]></title>
      <url>%2F2016%2F03%2F31%2Fgreat-tools-for-android-development%2F</url>
      <content type="text"><![CDATA[随着android市场份额越来越多， 开发人员也越来越多， 功能也越来越多，版本迭代越来越频繁，提高开发效率就显得越来越重要，我们都希望把时间放在刀刃上，那么就让工具飞起来吧。以后还会持续更新。。 工欲善其事,必先利其器 web相关的这方面技术小黑屋已经总结很好了，本人就重复造车了， 请不要叫我雷锋， 叫我大自然的搬运工,嘿嘿… 地址：快速提高Android开发效率的Web工具 android studio 开发相关的如果你开发android还用eclipse的ant，那么你就out了， android studio是你必备武器。如果你正在用，恭喜你正在通往牛X的道理上，那么你知道怎么正确的姿势去撸代码吗？如下你已经不需要了， 那就忽略下文。这里多数几句因为android studio是基于IntelliJ IDEA的，可能我是emacs重度用户， 和eclipse相比个人更喜欢IntelliJ IDEA，这里不展开说了， 以后可以单独说一下。 以前本人写过一遍写代码的正确姿势-剑招之重构 中提到一些技巧，但是不全， 本人一直本着独乐乐， 不如众乐乐的原则， 分享给大家， 网上发现小伙伴翻译了一篇AS技巧合集，很全面，总共62个其中包括： 1.常用技巧 2.编码技巧 3.调试技巧 地址：AS 小技巧合集]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一枚c/c++程序员java探索－reflect]]></title>
      <url>%2F2016%2F03%2F20%2Flearning_java_reflection%2F</url>
      <content type="text"><![CDATA[提到reflection，大部分android或java程序员可能都不陌生，都知道这是java的特性，知道了A类的内部结构之后，就可以与它进行交互，包括创建新的对象和调用对象中的方法等。网上这样的文章很多，为什么重复造轮子，一是整理思路加深印象，二是备忘。 优缺点优点运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。例如熟悉设计模式的人对于代理模式可 能都不陌生。 代理对象和被代理对象一般实现相同的接口，调用者与代理对象进行交互。代理的存在对于调用者来说是透明的，调用者看到的只是接口。代理对象则可以封装一些内部的处理逻辑，如访问控制、远程通信、日志、缓存等。比如一个对象访问代理就可以在普通的访问机制之上添加缓存的支持。这种模式在RMI和EJB中都得到了广泛的使用。传统的代理模式的实现，需要在源代码中添加一些附加的类。这些类一般是手写或是通过工具来自动生成。JDK 5引入的动态代理机制，允许开发人员在运行时刻动态的创建出代理类及其对象。在运行时刻，可以动态创建出一个实现了多个接口的代理类。每个代理类的对象都会关联一个表示内部处理逻辑的InvocationHandler接 口的实现。当使用者调用了代理对象所代理的接口中的方法的时候，这个调用的信息会被传递给InvocationHandler的invoke方法。在 invoke方法的参数中可以获取到代理对象、方法对应的Method对象和调用的实际参数。invoke方法的返回值被返回给使用者。这种做法实际上相 当于对方法调用进行了拦截。熟悉AOP的人对这种使用模式应该不陌生。 缺点使用反射的一个最大的弊端是性能比较差。相同的操作，用反射API所需的时间大概比直接的使用要慢一两个数量级。 基本语法12345678910111213public class MyClass &#123; private String name; public MyClass(String name) &#123; this.name = name; &#125; public void print(int age) &#123; System.out.println("name " + name + "age " + age); &#125;&#125; 获取类的类名 1234567891011//第一种方式Class c = obj.getClass()c.getName()//第二种方式Class.forName("com.jason.example.MyClass") 2.获取类的方法名 12c.getMethod("print", int.class) 3.获取类的属性名 12c.getField("name") 获取类的所有方法和属性的名字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ClassUtil &#123; /** * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数) * @param obj 该对象所属类的信息 */ public static void printClassMethodMessage(Object obj)&#123; //要获取类的信息 首先要获取类的类类型 Class c = obj.getClass();//传递的是哪个子类的对象 c就是该子类的类类型 //获取类的名称 System.out.println("类的名称是:"+c.getName()); /* * Method类，方法对象 * 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，包括私有方法 */ Method[] ms = c.getMethods();//c.getDeclaredMethods() for(int i = 0; i &lt; ms.length;i++)&#123; //得到方法的返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName()+" "); //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型---&gt;得到的是参数列表的类型的类类型 Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125; /** * 获取成员变量的信息 * @param obj */ public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); /* * 成员变量也是对象 * java.lang.reflect.Field * Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ //Field[] fs = c.getFields(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; //得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName+" "+fieldName); &#125; &#125; /** * 打印对象的构造函数的信息 * @param obj */ public static void printConMessage(Object obj)&#123; Class c = obj.getClass(); /* * 构造函数也是对象 * java.lang. Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 * getDeclaredConstructors得到所有的构造函数 */ //Constructor[] cs = c.getConstructors(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName()+"("); //获取构造函数的参数列表---&gt;得到的是参数列表的类类型 Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125; 4.反射调用方法 1234Method method = c.getMethod("print", int.class);method.invoke(MyClass.this, 25); 运用场景 通过发射读取属性文件的内容 动态Proxy模式 不限制场景， 只要你想要]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[写代码的正确姿势-剑招之重构]]></title>
      <url>%2F2016%2F03%2F13%2Fhow_code_refactor%2F</url>
      <content type="text"><![CDATA[这篇是即写代码的正确姿势之后的第二篇。或许你应该知道了，重构是怎样的，你也知道重构能带来什么。开发的流程大概 编写测试-&gt;功能代码-&gt;修改测试-&gt;重构 当然当逻辑很清楚的时候， 编写测试可以不用先行，反之逻辑复杂是编写测试先写。重构在我们写程序时无处不在，位置也很固定。 为什么要重构在Martin Fowler的《重构：改善既有代码的设计》一书中强调了代码中有哪些的坏味道，并告诉我们如何重构。我们经常遇到以下情景： 有时候你可能要面对着一坨一坨的代码，有时候你可能要花几天的时间去阅读代码, 你也可能会骂：‘写的都是shit，在没别这更烂的了’。 你想重写那几十代码可能只会花上你不到一天的时间。 每到这个时候， 我们可以这样想，如果你没办法理解当时为什么这么做，你的修改只会带来更多的bug。修Bug，更多的是维护代码。只有下心来， 你会发现修复bug也是一门艺术。 重构时机时时刻刻重构代码最佳的时间点：撰写每行代码的时候，而非迫不得已的时候。就是Martin Fowler提到坏味道，如果你遇到下列情景其实在提醒你代码该重构了： 当你写一段代码时，不得不从别处拷贝粘贴代码?这个应该在初学编程时候经常犯这种问题， 记得刚入职场时经常用这项技能，屡试不爽。不一些老鸟教育了几次也不敢用了。其实由于人性的懒惰，偶尔也会犯一次。现在回过头看自己早期写的程序（对， 还算不上作品）添加一点逻辑需要检查七八个地方是否需要同样的逻辑，完全可以入选教材作为经典的反面案例。 当你修改已有代码添加新功能时，发现已有代码总感觉哪里不对? 比如说，逻辑写得太绕，太复杂，太难以理解，循环太多，分支太多，状态太多等等。这样的代码几乎跪在那里请求你的重构，不重构说不过去。 当你调用已有的代码时（函数，类），不得不阅读被调用的代码才能确定怎么调用时？Martion Fowler这样说过，如果发现代码中有注释的地方都能通过重构进行去掉，那么注释写在哪里了， 当然写在函数和类的说明上。 一个函数有十多个参数；要么是文档写的不好， 关键性的函数没有对接口提供足够的说明 重构之术面向对象编程中的类的重构和函数式编程中的函数的重构也不尽相同；但是Java（OOP）、JavaScript（FP）它们的重构手段就千差万别了。下面主要说说用Idea重构java代码吧。 Intellij Idea重构以前用emacs写java代码时候， 进行代码重构一般都手动进行， 也没有想去找一些插件进行重构。以后发现Intellij idea自带重构工具，解放了生产力， 妈妈再也不担心我的学习了。 看一下下边的一段代码： 12345678910111213141516171819202122232425262728package com.jason.util;/** * Created by jason on 16/2/21. */public class Calculate &#123; public int substract(int a, int b) &#123; return a - b; &#125; public int multiplay(int a, int b) &#123; return a * b; &#125; public int divide(int a, int b) &#123; return a/b; &#125; public static void main(String[] args) throws Exception &#123; int temp = 1 + 2; int temp1 = new Cal2().fibonacci(5); System.out.println("add(): " + temp + " finbonacci(): " + temp1); &#125;&#125; Rename 把光标放到temp上，按下shift+f6，输入add 把光标放到temp1上，按下shift+f6，输入add 123456public static void main(String[] args) throws Exception &#123; int add = 1 + 2; int fibonacci = new Cal2().fibonacci(5); System.out.println("add(): " + add + " finbonacci(): " + fibonacci);&#125; Extract methodmac: command + alt + m 选中 int add = 1 + 2； 按下command + alt + m 结果如下： 123456789101112public static void main(String[] args) throws Exception &#123; int add = add(); int fibonacci = new Cal2().fibonacci(5); System.out.println("add(): " + add + " finbonacci(): " + fibonacci);&#125;private static int add() &#123; return 1 + 2;&#125; Extract paramtermac: command + alt + p 把光标放到1上，按下command + alt + p，输入a 把光标放到2上，按下command + alt + p，输入b 1234567891011public static void main(String[] args) throws Exception &#123; int add = add(1, 2); int fibonacci = new Cal2().fibonacci(5); System.out.println("add(): " + add + " finbonacci(): " + fibonacci);&#125;private static int add(int a, int b) &#123; return a + b;&#125; Inline Methodmac: command + alt + n 选中add(),按下command + alt +n 又回到以前了 123456public static void main(String[] args) throws Exception &#123; int add = 1 + 2; int fibonacci = new Cal2().fibonacci(5); System.out.println("add(): " + add + " finbonacci(): " + fibonacci);&#125; Pull Members Up/Push Members DownPull Members Up我们可以看到在Cal2类中有一个fibonacci（）函数， 并且继承Calculate类。我们认为他应该放在Calculate类中，我们就可以进行如下方法： Push Members Down相反方式处理， 就可将刚才修改还原了 Replace Temp with Query《重构：改善既有代码的设计》中这样写到： 我们都知道临时变量都是暂时的，而且只能在所属的函数中使用。所以它们会驱使你写出更长的函数，因为只有这样你才能访问到需要的临时变量。如果把临时变量替换为一个查询，那么同一个类中所有函数都将可以获得这份信息。这将带给你极大帮助，使你能够为这个类编写出更清晰的代码。 该重构方法往往是你运用提炼函数之前必不可少的一个步骤。局部变量会使得代码难以提炼，所以应该尽可能把它们替换为查询式。比较简单的情况是：临时变量只被赋值一次，或者赋值给临时变量的表达式不受其它条件影响。 用法鼠标: Refactor | Replace Temp with Query Martin Fowler的例子 重构前： 123456double basePrice = _quantity * _itemPrice;if (basePrice &gt; 1000) return basePrice * 0.95;else return basePrice * 0.98; 重构后： 123456789if (basePrice() &gt; 1000) return basePrice() * 0.95;else return basePrice() * 0.98;...double basePrice() &#123; return _quantity * _itemPrice;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[迟来的一封信-写于你一周时]]></title>
      <url>%2F2016%2F03%2F08%2Fhello_son%2F</url>
      <content type="text"><![CDATA[为什么现在才写还有几天就是你一周岁生日了，想想这一年的经历就像做过山车一样，更像放电影一样经常出现在我的脑海里，一遍遍回放。本来这封信在你刚出生的时候就想写，你提前的降临，导致我当时没有勇气去写。现在一切都过去了， 你也在一天天的长大，我内心也慢慢平静下来了，也是时候为你做的什么了。让你知道你是怎么来的，都经历什么，也让我有些思考。 出身前的那些事突然住院那是你妈妈怀上你第26周的第二天， 记得当时我下班回来， 吃过饭，刚打开电脑准备看今天的NBA录像（你妈妈那天上的是晚班9点才下班），计划看完以后去公交车站去接你妈妈回来。就在这时候电话响了，你妈妈打来的： 妈妈：肚子有点疼！ 爸爸：大概什么时候开始的？ 妈妈：大概晚上6点多吧， 想去医院看看。 爸爸：用不用陪你一块去？ 妈妈：先不用了，到时候有问题了在给你打电话。 挂过电话我也没当回事， 心想应该是吃坏肚子了。大概半个小时后， 电话又响了，还没等我说话，电话另一头你妈哭着说，小孩可能保不住了。我当时就傻了， 过了一会反应过来了，告诉你妈妈在医院那里等着我，我马上就过去。放下电话就往外赶，出门以后上了一辆出租车就奔医院方向去了。因为当时不知道怎么办了，路上给你奶奶打了一个电话， 那时你奶奶还在天津， 你奶奶问了一些情况，安慰我了几句(到时候也不知道什么情况)。 大约半个小时，到了医院， 看你妈妈在那里正在办住院手续。 问了才知道，医生说出现宫缩，有早产的征兆，要求住院处理。记得当时我还责备你妈妈几句， 好像因为住院单子上没有写明在几楼，我先跑到二楼问值班护士，你妈妈也跟着来了， 我说: ”让你那里找个位置坐着， 我弄好了去找你，你就是不听， 就是平常说你不听好了现在出问题了吧”（现在想想不该这样说）。 找好了床位，按动好你妈妈，由于医院一些材料没有带，你妈妈让我回去拿，我说先陪你一会吧。 记得那时候大概晚上11点多吧， 我让你妈妈先睡一会。当时我就在病床边爬着睡了一会。 大概是你妈妈心疼我说， 你还是先回去把那些材料那来吧， 随便在家睡一会再来吧。我看了看时间快1点了，交代了几句然后就回家了， 回家后整理好了材料然后躺在床上睡了两个小时左右，起来以后就去医院了（现在回想起来，也挺好玩的， 那时候还能睡着， 可能那个时候脑子一篇空白吧， 医生让做什么就做什么吧，😄现在想想也好）。 下午的时候你奶奶从天津过来了， 照顾你和你妈妈，就这样你奶奶天天给你们做饭送饭，我下班了就去医院陪陪你们。大概住了半个月吧， 医生说可以回家卧床休养了，然后我们就回家了。 羊水破了记得在家呆了大概一个多月吧，那时正月十二，过年的气氛还没有过去，又是一个夜黑风高的晚上，我在下班回家的路上接到你妈妈的电话说，裤子湿了， 可能羊水破了^1。我说你先去医院我马上就到。 到了医院检查后确定是羊水破了。那时你才33周，医生说， 如果现在就出生害怕心肺还没发育完成，根据经验34周一般都发育完成了，先用一些保胎药，尽量多保几天（当时在海淀妇幼住的院，整个下来感觉医生和护士的态度和责任心都还不错）。 我们也知道你快出生了， 就马上办你出生要的材料， 我们是外地户口在北京出生的话要办《外来京人员生育联系服务单》[^2]，然后我就各个地方去办这些材料。 [^2]:吐槽一下，最后就是拿到一张纸， 为什么要这么多材料 出生在医院住了第七天时候，你已经在妈妈肚子里待了34周了， 住院期间医生曾给我们说过，因为羊水破了，你在里面待得时间越长，越容易感染。她建议从今天开始就不用药了，不再进行人工干预了。2015.3.12，天气也晴朗，阳光明媚， 早上9点多， 我刚到公司就接到你奶奶打来的电话说，应该快要生了。因为上班高峰期去医院的路上有点堵，等到了医院，你和你妈妈已经进产房了（原本你妈妈想让我陪她一块进去的， 可是我当时不在身边）。我们就在外面等着，大概到了11：40左右吧，护士报个小孩出来了说，谁是xx的家属，我答了一声。她说2.56Kg，男孩女孩我也没听清楚，让我跟她去儿科。我心里想坏了才2.56斤（正常出生的小孩在6斤以上），然后进了电梯又和护士确认了一下。 她说，5斤多点。就在这个时候我才注意到你，在那安稳的睡着 。到了儿科医生接过你，过了一段时间， 医生从玻璃房走了出来， 给我说了一下你的基本情况，因为你是早产儿， 要在保温箱里待着、做检查，让我签了一些协议，期间我也问了一些问题，例如会不会哭。然后我去找你妈妈去了，当时我很高兴，我有儿子了，内心反复告诉自己。 你住院的期间，检查也一切正常， 就是有点黄疸，然后观察了10天左右，就出院了。 出身后的那些事起名字名字在你出生前也想了，还在论坛上征询过网友的意见， 大都被调侃了，最后都感觉不合适。想想自己也是互联网人， 就在网上找了一个网上起名的公司， 支付了299让他们帮忙起个名字。他们一天给5个名字让我去选，由于当时时间紧、任务重，连续几天后， 相互比较后就敲定了你的名字（胡宸硕）。 再次住院你在家待了大概一个星期吧，然后就发现你低烧， 先去了你出生的医院，因为没有床位，然后就去了家附近的八一儿童医院。这家医院不要探视，可以每天十点过来送母乳。就这样你保温箱待了十天左右，你的低烧退了， 就出院了。 还没有几天，发现你又出现低烧问题， 那天你妈妈和你奶奶带你去的， 去了八一儿童医院， 医院要求你住院， 你妈妈给我电话说明了情况，我心里嘀咕了一下，是不是那个医院技术不行啊， 怎么上次住院没有治好（住院不让我们陪护， 害怕护士们照顾不好你）。然后给你妈妈说，咱们换一家医院试试，去北京儿童医院看看吧。才开始我和你妈妈有分歧， 她的意思别折腾了， 赖不住我的坚持。然后我们缤纷两路向北京儿童医院那儿赶，等我到了， 你们已经到了， 儿童医院人太多，需要排队。又加上那天天气有点热，你的脸色一直通红。当时你妈妈还吓哭了， 我也害怕，去了重新挂了儿童医院的特需号，做了初步的检查后医生建议住院做全面的检查， 我们在大厅商量快半个小时，最后决定还是回原来的医院住， 第一离家近，第二他们已经了解了你的一些基本情况了， 可能有些检查可能不需要做了。 就这样你又住进了八一儿童医院。 这期间还有别的事情发生，我大伯（也就是你大爷爷）病重，同时我在装修房子， 你又住院， 我就这样同时三线程操作，也不知那段时间我是怎么过来的。期间医生给我打电话说， 给你脑袋做了一个CT，发现有一块阴影，也看不清， 怀疑脑内有出血，要求再做个核磁共振，确认一下。当时我就傻了， 第一万一脑袋真的出血了怎么办，第二核磁有辐射，你又那么小， 一直犹豫要不要给你做。最后理性战胜感性，还是同意做了。记得知道检查结果没事时我正在高铁上， 当时就哭了。 住了大概15天左右你就出院了， 以后的日子，一切步入了正轨， 慢慢的你也赶上了其它正常出生的小孩了，现在回想起来这一年的经历我们痛并快乐着。 在那段困难的时间里给自己暗语，给自己打气 。孟子曰: 故天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。 寄语有时候我会反问自己， 我能教你什么？说来惭愧， 这一年来我没有为你过什么， 你妈妈经常嘲笑说， 你爸爸在家扮演的角色是负责欣赏。以后我会陪你走过你前半段人生，作为你成长的见证者，可能帮你做一些决定。 爸爸想对你说的话 做个善良的人 做个诚信的人 做个会独立思考并持续行动的人 做个善良的人善良是人心之本，这个是你与生俱来，世界越来越扁平化、复杂化，但是但是，请一定要保持一颗善良的心。你一定会吃亏，也一定会受伤。只要不突破个人底线，请保持一颗大爱的心吧。胸怀有多大路才有多宽广。 做个诚信的人未来很长时间， 你会接触形形色色的人，俗话说‘林子大了，什么鸟都有’。请诚实守信的对待每个人和每件事，包括自己， 其实不是生活欺骗了你，而是你欺骗了生活。 做个会独立思考并持续行动的人这个可以慢慢来， 你需要大量的练习，才会有自己的思考。 我不会告诉你什么是对的，什么是错的， 因为本来就没有真正的对和错，需要你自己去发现、去探索。以后我们也可以一块探讨，并持续去行动，慢慢形成习惯，到那个时候我们就放心你走出去了。 妈妈对你说的话宝贝，时间过的真快，马上你就要一岁了，有很多话要给你说，从爸爸妈妈结婚到有了你，还有以后怎么更好的守护你成长，等等，以后的很多事。但妈妈首先要给你说的是，抱歉宝贝，妈妈由于身体素质不是特别好加上没有特别注意，让你提前从妈妈肚子里出来了，以致让你受了很多罪，非常抱歉，我会再以后的日子里加倍爱你。 首先妈妈希望你健康快乐，然后有一个挣钱养家的本事，有自己的兴趣爱好，有几个知心朋友，这样才能使生活继续，我不会强迫你非考前三名，差不多就行，如果能考前几名更好，嘻嘻。我会尽最大的努力培养你，但有很多时候不会满足你的愿望，希望你不要怪我，一方面是因为能力有限，另一方面我会对你的愿望进行权衡，对你好的才会满足，纵容是不会发生在你身上的，我可能会打你，骂你，你做好心里准备，但肯定不会经常发生，我会控制也希望你控制。 在你青春期和我更年期的时候我们会发生很多矛盾，到时候希望我们都冷静对待。 你长大了也会有自己的家庭，妈妈很高兴也会有点失落，高兴你长大了，失落你要离开我。 结束语写了这么多，是不是感觉爸爸好啰嗦啊， 是不是老了， 爸爸现在29岁。我们最希望你能健康快乐的成长， 我们只是在你的生活中扮演着陪伴的角色， 我们也会用心做好这个角色。你的路还很长，祝你一切顺利， 生日快乐！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[写代码的正确姿势-序]]></title>
      <url>%2F2016%2F02%2F27%2Fhow_code%2F</url>
      <content type="text"><![CDATA[有些童鞋可能会问， 难道写代码还要姿势吗？ 不都是坐着写的吗？ 莫非首先要有一张工学人体座椅、一个机械键盘和鼠标，两个显示器（最好还是retina屏），倒一杯清茶， 最后发现还没有写一行代码。哈哈，此姿势非彼姿势也，最后的目的是我们写出优雅的代码。本人上大学的时候，读过有关如何写好代码的书， 例如《代码大全》、《重构-改善已有代码的设计》、《设计模式》等，无赖受限自己当时水平，不能深刻理解。工作几年以后，前一段时间又重新有翻开来看看， 发现现在在写代码的时候还是犯书中说的问题。好吧，看来自己还不是一个优秀的程序猿，记录一下自己的笔记吧， 让自己通往牛X的路上吧。 正文由于内容很多，而且都重要重要，还是分三篇来说说吧，纵览武侠江湖，制胜法门不外两项，内功和外功。二者得一可天下去得，但最终皆入内外兼修之境。令狐冲是自外而内，先学独孤九剑，后学吸¯星大法，最后学易筋经。张无忌是自内而外，先修内功九阳真经，然后以此为基础，加上太极拳和太极剑，最终成就天下第一高手。 剑招-重构 外功-设计模式 内功-自动测试 总结重构的方法好比剑招，剑招固然重要，但更重要的是知道什么时候用什么剑招，心中无招，信手挥洒，皆是模式。设计模式好比外功。内里明心见性，心如磐石，护体神功，自动化测试；外求格物致知，游刃有余，独孤九剑，设计模式。如何写好出优雅的代码，设计模式、重构和自动测试三者缺一不可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[书评：格局逆袭]]></title>
      <url>%2F2016%2F02%2F21%2Fbook_review_framework%2F</url>
      <content type="text"><![CDATA[因为机缘巧合关注了本书的作者（大熊），也了解他的背景，也被他持续两年时间写作的行为震撼。然后就发现他写了这本《格局逆袭》的书，春节放假的时候读完全书。由于这本书的内容是作者这几年文章的合集，所以逻辑有点混乱，整个中心思想不能很好的串成一条线（也有可能是我理解问题），但是书中大部分观点还是很有意思的，值得我们去思考。 这本书据说是写给都市年轻人和创业者的奋斗指南。有人说， 这是一本强鸡汤鸡血的书。那你就干了这碗，细细去品味通过自己去思考去寻找，只要你找到依据，这也是你的收获不要只是写上“以鉴定此书是鸡汤体”，然后没有下文了，我更想看的是你的论据。 作者认为‘全世界到处都是有才华的穷人’，一直认为自己是一个没才华的穷人， 是不是没救了。穷人分为两种：一种是有才华，另一种是没有才华。有没有才华怎么判断，自己理解就是问问自己有没有利用价值，如果有就是有才华，反之就是没有。只有拥有才华了，通过不断的沉淀，最后才能找到自己的位置。也印证了作者后面所说的‘你现在做的事情不能只考虑收获，更要考虑积累。慢慢来，比较快’。 作者提倡首先要认清自己，就是认识自己，你要知道自己是谁，并且承认。 如何提升层次： 天赋: 这个已经注定了。 各种商: 阅读量、信息量、能说、能写。 格局: 去和你想成为的人在一起，看看他们怎么生活、工作的，然后自己去领悟、模仿。 高端人士核心共同点： 逻辑性很好 决断力很强 情商很高 能发现和驾驭人才 承压能力强 有的网友是这么评价的： 以往的职场书籍大概都有假大空的噱头，给你许多成功人士的案例，让你要么克制本性照抄，要么坚持三天又放弃了。大熊的这本书与那些书比起来似乎朴实了很多，从一个屌丝走向一个稍微不那么屌丝的角色，每一步值得我认真反思，而这个反思在大熊的文字里又那么普通和描写。贪大求全是每一个有野心的唯一优点，也是致命的弱点；大熊似乎把这种双刃剑舞的很专业，不急不躁才能认真思考。大熊讲了一个普适的成功概念，就是：坚持，顺便起来看一看自己走过的路。如果方向偏了，就要调整方向；如果以前做错了，就要调整和修改。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-数据篇]]></title>
      <url>%2F2016%2F02%2F18%2Fandroid_note_data%2F</url>
      <content type="text"><![CDATA[Android 的四种数据存储方式： SharedPreferences SQLLite Content Provider File SharedPreferences SharedPreferences它是一种轻量的数据存储方式，本质是基于xml文件存储key-value，通常用来存储一些简单的配置信息。SharedPreferences对象本身只对获取数据而不支持存储和修改，存储修改是通过Editor对象实现实现SharedPreferences存储的步骤如下： 获取SharedPreferences对象 获取SharedPreferences.Editor对象 通过Editor接口的putXxx方法保存key-value对其中xxx表示不同的数据类型 通过Editor接口的apply(以前commit)方法保存key-value对 123456789101112SharedPreferences pref = getSharedPreferences("myPref", MODE_PRIVATE);SharedPreferences.Editor edit = pref.edit();edit.putString("name", "jason");edit.putInt("age", 28);edit.putLong("time", System.currentTimeMillis());edit.apply();//保存数据，建议不要用commitedit.remove("time");edit.apply();//获取数据System.out.println(pref.getString("name", "jason"));System.out.println(pref.getInt("age", 0)); SQLiteSQLite简介维基定义： SQLite （英语发音：/ˌɛskjuːɛlˈlaɪt/[2] or 英语发音：/ˈsiːkwəl.laɪt/[3]）是遵守ACID的关系数据库管理系统，它包含在一个相对小的C程序库中。与许多其它数据库管理系统不同，SQLite不是一个客户端/服务器结构的数据库引擎，而是被集成在用户程序中。 SQLite遵守ACID，实现了大多数SQL标准。它使用动态的、弱类型的SQL语法。[4]它作为嵌入式数据库，是应用程序，如网页浏览器，在本地/客户端存储数据的常见选择。它可能是最广泛部署的数据库引擎，因为它正在被一些流行的浏览器、操作系统、嵌入式系统所使用[5]。同时，它有许多程序设计语言的语言绑定。 特点： 轻量级 一个动态库、单个文件 独立性 没有依赖、无序安装 隔离性 全部在一个文件中 跨平台 多语言接口 支持众多编程语言 安全性 事务 事务处理的安全性问题： 通过数据库上的独占性和共享锁来实现独立事务处理 多个进程可以在同一时间从同一数据库读取数据， 但只有一个可以写入数据。 数据类型SQLite支持NULL、INTERGER、REAL、TEXT和BLOB数据类型 动态数据类型当某个值插入到数据库时，SQLite将会检查它的类型，如果该类型与关联的列不匹配，SQLite则会尝试将该值转换成该列的类型，如果不能转换，则该值将作为本身的类型存储差异性 没有可用于SQLite的网络服务器、只能通过网络共享可能存在文件锁定或者性能问题 只是提供数据库级别的锁定 没有用户账号的概念，而是根据文件系统确定所有数据库的权限 android中如何使用SQLiteSQLiteDatabase提供了一些管理SQLite数据库的类，提供创建，删除，执行SQL命令，并执行其他常见的数据库管理任务的方法，每个程序的数据库名字是唯一的。 ContentValues values = new ContentValues(); values.put(“name”, “jason”); 执行对应的sql操作 12345678910111213141516171819202122232425SQLiteDatabase db = openOrCreateDatabase("user.db", MODE_PRIVATE, null);//通过内置方法操作数据库ContentValues values = new ContentValues();values.put("name", "jason");values.put("sex", "male");values.put("age", "28");db.insert("usertb", null, values);values.clear();values.put("sex", "female");db.update("usertab", values, "_id&gt;?", new String[]&#123;"1"&#125;);//将全部id&gt;3的人的性别改为女db.delete("usertab", "name like ?", new String[]&#123;"%j%"&#125;);//删除所有名字中带有j的人//Cursor query = db.query("usertb", null, "_id&gt;?", new String[]&#123;"0"&#125;, null, null, "name");Cursor cursor = db.rawQuery("select * from usertb", null);if(cursor != null) &#123; cursor.moveToFirst(); int index = cursor.getColumnIndex("_id"); while (cursor.moveToNext()) &#123; Log.i("jason", String.valueOf(cursor.getInt(index))); &#125; cursor.close();&#125;db.close(); TODO SQLiteOpenHelper用于管理创建和版本更新一般是建立一个类的继承它，并重写onCreate()和onUpgrade()方法getReadableDatabase() 创建或打开一个只读数据库getWriteableDatabase() 创建或打开一个读写数据库 SQlite 性能优化技术小黑屋的一篇《Android中SQLite性能优化》写的不错，点击这里 TODO FileTODO ContentProvider主要作用是进行数据共享，可以是不同进程、应用之间。 如何实现Content Provider？ 继承抽象类ContentProvider实现一系列针对于数据的增、删、改、查等方法 需在AndroidMainfest.xml中完成对ContentProvider的注册 获取UriMatcher类 使用ContentResolver操作ContentProvider中的数据 当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用ContentResolver 类来完成使用Activity提供的getContentResolver()方法获取ContentProvider对象 系统提供的ContentProvider联系人短信读取通话记录多媒体 图像、音视频]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[过年抢红包一些感想]]></title>
      <url>%2F2016%2F02%2F15%2Fhongbao%2F</url>
      <content type="text"><![CDATA[题图是春节我和表哥一块去抓兔子，经过的一大片芦苇地，停下来拍到的。在这个寒冷的冬季，此刻的场景着实让我震惊，当你站在它中间寒风吹过芦苇们随风摆动自己显得那么渺小和无助。 春节已过，但春节的影响还没过。现在春节除了看春晚、串亲戚给长辈拜年，还有一项就是抢红包，今年更是把抢红包推向了高潮（可能是春晚太没意思，人们又发明新玩法，😄），从支付宝和微信一对多发放，到亲戚朋友相互之间通过红包拜年。每件事情都有它的两面性有好有坏，抢红包也不例外。 好处就是通过抢红包，大家成功避开了去吐槽春晚。大家仅仅是凑个热闹，图个吉利。相互交流一下感情，至今没见过谁通过抢红包发财的，你要认真你就输了。我们公司有个微信群，过年了大家都相互抢红包， 中间应该A同事抢了B同事给C同事的红包，出现了一些摩擦。在这里我们不讨论谁对谁错， 因为抢红包本身没有问题，只是相互太认真了就会出现问题。但是从抢红包里我们能基本分析哪些人值得你交往的（只抢不发的），哪些是不值得（也抢也发的）。抢红包一款产品直指人心，深不可测。 最好还是别参与这么无聊的游戏了， 如果你有价值，自然会有人给你发红包的，反之没就抓紧时间提升自己吧。向长辈和真正的朋友，发发就可以了， 不要较真。今年我被拉到了一个七大姑八大姨群里， 然后我就发了几个红包，然后就默默退了，因为我的任务完成了， 还在那里干什么啊。 最后引用知乎里的一句回答: 你的快乐分我一点我的快乐分我一点大家的快乐不会减]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读Scaler700+文章后感想]]></title>
      <url>%2F2016%2F02%2F11%2FscalersTalk%2F</url>
      <content type="text"><![CDATA[提笔写的时候，其实离当初制定的计划已经过去几天了（原本计划2.4号就刷完S的文章的）。到现在为止（2.11）我也没有真正看完s的700多篇文章。 本来想真正看完后再写的，这个坑挖了，还是一点点的填吧。用一篇文章概况s的两年内写的几十万子的东西，显然不可能的。由于自己的行动量不够，一些s的总结有些不能深刻的理解（好吧，其实我很笨，😄），那就只能听s的话、照做。 背景记得那时一个夜黑风高的晚上， 我躺在床上刷手机，随意翻看着文章，发现一个关于学英语相关的文章，感觉大多数人和我一样，第一反映肯定想又是一个打着旗号骗钱的，但是还是不能抑制对英语的渴望，心想再让你们骗一次吧。当时应该是2015.10.xx 我看到的文章是2015.1的成长会会员招募，心想现在都快11月，进去了意义也不大，就加了s的qq号，‘在吗， 你们2016的成长会什么时候开始啊’ ‘你现在可以报名，1000’ 其实当时我想搞价的，心想少骗一点是一点吧，反过来想想这又不是买菜，哪有看病去搞价的，现在想想没有搞价多么明智啊， 不然又要让s当反面教材了。就这样成了第62位进入2016成长会会员了。我深知自己的英语水平，本来高中时英语几门课里最好的一科，上大学以后，我们英语老师是一个毕业没多久的小姑娘，不知怎么的就被归到不爱学英语的行列中(其实我是很爱英语的)，有时候她的课也不去上， 四级也不知道怎么就考过的，六级我连报名的勇气都没有 。最后毕业后发现英语的好坏取决你能走多远（其实以前也知道这个道理，只是没有深刻体会，忘了说了我是IT男）。中间也尝试了一次，我没有坚持下来， 总是在网上找一些学习英语的方法，每次发现看后跟打鸡血似的，药物过后，发现病还没有治好。事后都怀疑是自己用错药了，安慰自己。 正文S行动了这么长时间， 也总结一套自己体系，包括学习系统、行动系统、成长系统,下面我们单独列列。 以输出带动输入，以行动驱动梦想输出倒逼输入，只有你行动起来，当输出的时候，自然而然的你会Get技能，查找数据库。就像当时才开始写blog时，害怕没有东西写，迟迟没有输出，拖了很久后，发现没有那么当时那么困难，到目前为止，每月至少四篇， 已经坚持7个月了。 你觉得牛逼的东西，只是你不了解而已。当你了解了，你就会知道，这都是一步步累积出来的。 先上路，先行动，上路以后再说 在通往牛逼的道路上，让一部分事情先做起来。先行动起来，有了行动才有感悟，有了感悟才能有改进和突破；同时在一阶段的行动结束后及时复盘总结，规避错误，提炼成功，增加达成目标的几率。五分钟能做完的事情马上就去做； 五分钟做不完的马上先做一点点。 方法论 方法应该以动态的观点来看，你在长期不懈的行动中，方法会是在不断调整的，而且一般会越调整越适合你的进步 明确主线，合理取舍，简单入手，逐步挂载成长会有很多社群，对我来说进入成长会的主线就是英语，先从朗读开始(惭愧， 还没有发声，还是听小伙伴再读)，持续行动，慢慢来，踏实行走。具体什么时候挂载，等能力到了再说吧。 什么是成长？ 其实努力的指向是成长，而成长是产生意义的。只是有时候我们追求结果，过分追求，所以忽略了成长，忽略了意义。不要想着我努力了，我就一定会迎娶白富美。努力但没成功而失落的人内心通常还是有相当然的，我这么努力了你还不垂青我一下；但是事实上就是，真不一定。我们生活中的事件其实都是概率，而且既然是概率，那就是有运气的成分，只是有时大有时小。 结束语好吧， 写先写到这里吧， 这里只是文章的结束，自己刚刚开始行动的地方，还是持续行动，构建属于自己的学习系统和行动系统。希望s的成长会，持续办下去，到时候我让我儿子也参加进来，哈哈。 在新春之际，祝S新春快乐，早日找到S嫂！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一枚c/c++程序员java探索－容器]]></title>
      <url>%2F2016%2F01%2F28%2Flearning_java_collection%2F</url>
      <content type="text"><![CDATA[网上找了一张图，可以整个概况容器的整个结构 容器概念容器接口是容器的基础。使用接口可以将容器的实现与容器接口分开，因而可以使用相同的方法访问容器而不需关心容器具体的数据结构。Iterator接口也使用户能够使用相同的方法访问不同的容器类。 容器API Collection 接口，定义了存取一组对象的方法，其子接口set和list分别定义了存储方式 Set中的数据对象没有顺序且不可重复 List中的数据对象有顺序且可以重复（equals） Map接口定义了存储“键（key） –值（value）映射对”的方法（一对一对往里装） Collection接口中所定义的方法1234int size() //装了多少个元素boolean isempty() //是不是为空void clear() //清空boolean contains(object element) //是不是包含某个对象 容器类对象在调用remove，contains等方法时需要比较对象是否相等，这回涉及到对象类型的equals方法和hashcode方法，对于自定义的类型，需要重写equals和hashcode方法以实现自定义的对象相等规则（相等的对象应该具有相等的hash codes） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class BaseColl &#123; public static void main(String[] args) &#123; Collection&lt;Comparable&gt; c = new HashSet&lt;&gt;(); c.add("hello"); c.add(new Name("f1","l1")); c.add(100); c.remove("hello"); c.remove(100); System.out.println(c.remove(new Name("f1","l1"))); System.out.println(c); &#125;&#125;class Name implements Comparable&lt;Name&gt;&#123; private String firstName,lastName; public Name(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; @Override public boolean equals(Object obj) &#123; if (obj instanceof Name) &#123; Name name = (Name) obj; return (firstName.equals(name.firstName)) &amp;&amp; (lastName.equals(name.lastName)); &#125; return super.equals(obj); &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public String toString() &#123; return firstName + " " + lastName; &#125; @Override public int hashCode() &#123; return lastName.hashCode(); &#125; @Override public int compareTo(Name o) &#123; return this.equals(o) ? 0 : -1; &#125;&#125; Iterator接口所有实现了collection接口的容器类都有一个iterator方法用返回一个实现了iterator接口对象Iterator对象称作迭代器，用以方便的实现对容器内元素的遍历操作 123456789101112 //通过集合的iterator方法，取得迭代器的实例 LinkedList&lt;Name&gt; lists = new LinkedList&lt;&gt;(); lists.add(new Name("jason", "hu")); lists.add(new Name("jim", "li")); lists.add(new Name("kobe", "Bryant")); lists.add(new Name("Stephen","Curry"));Iterator&lt;Name&gt; it = lists.iterator(); while(it.hasNext()) &#123; Name name = it.next(); System.out.println("name.first: " + name.firstName + ":" + name.lastName);&#125; CollectionsCollections工具类提供了大量针对Collection/Map的操作，总体可分为四类，都为静态（static）方法： 排序 reverse(List list)：反转指定List集合中元素的顺序 shuffle(List list)：对List中的元素进行随机排序（洗牌） sort(List list)：对List里的元素根据自然升序排序 sort(List list, Comparator c)：自定义比较器进行排序 swap(List list, int i, int j)：将指定List集合中i处元素和j出元素进行交换 rotate(List list, int distance)：将所有元素向右移位指定长度，如果distance等于size那么结果不变 查找和替换 binarySearch(List list, Object key)：使用二分搜索法，以获得指定对象在List中的索引，前提是集合已经排序 max(Collection coll)：返回最大元素 max(Collection coll, Comparator comp)：根据自定义比较器，返回最大元素 min(Collection coll)：返回最小元素 min(Collection coll, Comparator comp)：根据自定义比较器，返回最小元素 fill(List list, Object obj)：使用指定对象填充 frequency(Collection Object o)：返回指定集合中指定对象出现的次数 replaceAll(List list, Object old, Object new)：替换 同步控制Collections工具类中提供了多个synchronizedXxx方法，该方法返回指定集合对象对应的同步对象，从而解决多线程并发访问集合时线程的安全问题。HashSet、ArrayList、HashMap都是线程不安全的，如果需要考虑同步，则使用这些方法。这些方法主要有：synchronizedSet、synchronizedSortedSet、synchronizedList、synchronizedMap、synchronizedSortedMap。 特别需要指出的是，在使用迭代方法遍历集合时需要手工同步返回的集合。123456789Map m = Collections.synchronizedMap(new HashMap()); ...Set s = m.keySet(); // Needn't be in synchronized block ...synchronized (m) &#123; // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next());&#125; 设置不可变集合(TODO)常见的容器比较ArrayList VS LinkedList 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。 相对于ArrayList，LinkedList插入是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。 类似于插入数据，删除数据时，LinkedList也优于ArrayList。 LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。concurrent(TODO)JDK5之后新增的java.util.concurrent包下的集合类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一枚c/c++程序员java探索－io]]></title>
      <url>%2F2016%2F01%2F24%2Flearning_java_io%2F</url>
      <content type="text"><![CDATA[File类File类只用于表示文件（目录）的信息（名称、大小等），不能用于文件内容的访问。 RandomAccessFile java提供的对文件内容的访问，既可以读文件，也可以写文件。RandomAccessFile支持随机访问文件，可以访问文件的任意位置 分为下面几步: java文件模型在硬盘上的文件是byte byte byte存储的,是数据的集合 打开文件有两种模式”rw”(读写) “r”（只读)RandomAccessFile raf = new RandomeAccessFile(file,”rw”)文件指针，打开文件时指针在开头 pointer = 0; 写方法 raf.write(int)—&gt;只写一个字节（后8位),同时指针指向下一个位置，准备再次写入 读方法int b = raf.read()—&gt;读一个字节 文件读写完成以后一定要关闭 123456789101112131415161718192021222324252627282930 File demo = new File("test");if(!demo.exists()) &#123; demo.mkdir(); &#125;File file = new File(demo,"test");if(!file.exists()) &#123; file.createNewFile(); &#125;//打开文件，进行随机读写RandomAccessFile accessFile = new RandomAccessFile(file, "rw");/*序列化*/int i = 0x7ffffff;accessFile.write(i &gt;&gt; 24);accessFile.write(i &gt;&gt; 16);accessFile.write(i &gt;&gt; 8);accessFile.write(i);System.out.println(raf.getFilePointer());/*反序列化*/accessFile.seek(0);int b = accessFile.read();i = i | (b &lt;&lt; 24);b = accessFile.read();i = i | (b &lt;&lt; 16);b = accessFile.read();i = i | (b &lt;&lt; 8);b = accessFile.read();i = i | b;System.out.println(Integer.toHexString(i)); accessFile.close(); RandomAccessFile提供基本类型的读写方法，可以将基本类型数据序列化到文件或者将文件内容反序列化为数据 字节流InputStream、OutputStreamInputStream抽象了应用程序读取数据的方式 OutputStream抽象了应用程序写出数据的方式 EOF = End 读到-1就读到结尾 输入流基本方法 int b = in.read();读取一个字节无符号填充到int低八位.-1是 EOF in.read(byte[] buf) in.read(byte[] buf,int start,int size) 输出流基本方法 out.write(int b) 写出一个byte到流，b的低8位 out.write(byte[] buf)将buf字节数组都写入到流 out.write(byte[] buf,int start,int size) FileInputStream 具体实现了在文件上读取数据 FileOutputStream实现了向文件中写出byte数据的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 读取指定文件内容，按照16进制输出到控制台 * 并且每输出10个byte换行 * @param fileName * 单字节读取不适合大文件，大文件效率很低 */public static void printHex(String fileName)throws IOException&#123; //把文件作为字节流进行读操作 FileInputStream in = new FileInputStream(fileName); int b ; int i = 1; while((b = in.read())!=-1)&#123; if(b &lt;= 0xf)&#123; //单位数前面补0 System.out.print("0"); &#125; System.out.print(Integer.toHexString(b)+" "); if(i++%10==0)&#123; System.out.println(); &#125; &#125; in.close();&#125;/** * 批量读取，对大文件而言效率高，也是我们最常用的读文件的方式 * @param fileName * @throws IOException */public static void printHexByByteArray(String fileName)throws IOExceptio)&#123; FileInputStream in = new FileInputStream(fileName); byte[] buf = new byte[8 * 1024]; /*从in中批量读取字节，放入到buf这个字节数组中， * 从第0个位置开始放，最多放buf.length个 * 返回的是读到的字节的个数 */ /*int bytes = in.read(buf,0,buf.length);//一次性读完，说明字节数组足够大 int j = 1; for(int i = 0; i &lt; bytes;i++)&#123; System.out.print(Integer.toHexString(buf[i] &amp; 0xff)+" "); if(j++%10==0)&#123; System.out.println(); &#125; &#125;*/ int bytes = 0; int j = 1; while((bytes = in.read(buf,0,buf.length))!=-1)&#123; for(int i = 0 ; i &lt; bytes;i++)&#123; System.out.print(Integer.toHexString(buf[i] &amp; 0xff)+" "); if(j++%10==0)&#123; System.out.println(); &#125; &#125; &#125; in.close();&#125; DataOutputStream/DataInputStream对&quot;流&quot;功能的扩展，可以更加方面的读取int,long，字符等类型数据 DataOutputStream writeInt()/writeDouble()/writeUTF() 123456789101112131415161718192021222324252627 // DataInputStream dis = new DataInputStream(new FileInputStream(file));int i = dis.readInt();System.out.println(i);i = dis.readInt();System.out.println(i);long l = dis.readLong();System.out.println(l);double d = dis.readDouble();System.out.println(d);String s = dis.readUTF();System.out.println(s); dis.close(); // DataOutputStream dos = new DataOutputStream( new FileOutputStream(file));dos.writeInt(10);dos.writeInt(-10);dos.writeLong(10l);dos.writeDouble(10.5);//采用utf-8编码写出dos.writeUTF("中国");//采用utf-16be编码写出dos.writeChars("中国");dos.close(); BufferedInputStream/BufferedOutputStream 这两个流类位IO提供了带缓冲区的操作，一般打开文件进行写入 或读取操作时，都会加上缓冲，这种流模式提高了IO的性能 从应用程序中把输入放入文件，相当于将一缸水倒入到另一个缸中: FileOutputStream: write()方法相当于一滴一滴地把水“转移”过去 DataOutputStream: writeXxx()方法会方便一些，相当于一瓢一瓢把水“转移”过去 BufferedOutputStream: write方法更方便，相当于一飘一瓢先放入桶中，再从桶中倒入到另一个缸中，性能提高了 字符流编码问题 java的文本(char)是16位无符号整数，是字符的unicode编码（双字节编码) 文件是byte byte byte …的数据序列 文本文件是文本(char)序列按照某种编码方案(utf-8,utf-16be,gbk)序列化为byte的存储结果 字符流(Reader Writer) 操作的是文本文本文件 字符的处理，一次处理一个字符 字符的底层任然是基本的字节序列 字符流的基本实现 InputStreamReader 完成byte流解析为char流,按照编码解析 OutputStreamWriter 提供char流到byte流，按照编码处理 12345678910111213141516171819202122FileInputStream in = new FileInputStream("e:\\javaio\\utf8.txt");InputStreamReader isr = new InputStreamReader(in,"utf-8");//默认项目的编码,操作的时候，要写文件本身的编码格式 FileOutputStream out = new FileOutputStream("e:\\javaio\\utf81.txt");OutputStreamWriter osw = new OutputStreamWriter(out,"utf-8");/*int c ;while((c = isr.read())!=-1)&#123; System.out.print((char)c);&#125;*/char[] buffer = new char[8*1024];int c;/*批量读取，放入buffer这个字符数组，从第0个位置开始放置，最多放buffer.length个 返回的是读到的字符的个数*/while(( c = isr.read(buffer,0,buffer.length))!=-1)&#123; String s = new String(buffer,0,c); System.out.print(s); osw.write(buffer,0,c); osw.flush();&#125;isr.close();osw.close(); FileReader/FileWriter 字符流的过滤器12345678910111213141516171819202122 //对文件进行读写操作 BufferedReader br = new BufferedReader( new InputStreamReader( new FileInputStream("e:\\javaio\\test1.txt")));/*BufferedWriter bw = new BufferedWriter( new OutputStreamWriter( new FileOutputStream("e:\\javaio\\test2.txt")));*/PrintWriter pw = new PrintWriter("e:\\javaio\\test2.txt");//PrintWriter pw1 = new PrintWriter(outputStream,boolean autoFlush);String line ;while((line = br.readLine())!=null)&#123; System.out.println(line);//一次读一行，并不能识别换行 /*bw.write(line); //单独写出换行操作 bw.newLine();//换行操作 bw.flush();*/ pw.println(line); pw.flush();&#125;br.close();//bw.close();pw.close(); BufferedReaderreadLine 一次读一行 BufferedWriter写一行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java基础知识疑难问题总结]]></title>
      <url>%2F2016%2F01%2F12%2Fjava_base_question_summary%2F</url>
      <content type="text"><![CDATA[前一段时间本人将java基础学习完了， 发现一些问题和自己的一些理解，希望和大家一块探讨一下，这里只讨论一些疑问，别的问题可以下一次再讨论，例如java学习的心得。先把问题列出来吧。 面向对象java实例化对象就是内存的引用，也可以理解为索引（c++同学可以简单理解为地址）， 那比较两个对象是否相等，要实现每个元素相等，如果类的属性很多为了实现这个目的我们通常进行序列化和反序列化，个人吐槽一下特别麻烦，为什么提供一个c++中类似的memcmp()方法了？ 自动拆封箱(boxing and unboxineg) 为什么java能自动拆封箱，那么下面代码为什么不能这样写？ src12HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();int value = hashMap.get("Jason");//? 测试环境idea + jdk7.0 java中有自动拆箱功能为什么做彻底点？ 容器 为什么删除Set中元素要求这个类要继承Comparable接口，难道实现equals不就行了吗？举个例子吧src123Collection&lt;Name&gt; c = new HashSet&lt;Name&gt;();c.add(new Name("f1","l1"));boolean isSuccess = c.remove(new Name("f1", "l1")); //？ 为什么要实现compareTo方法，java API为什么这样实现？ 为什么和hash相关的集合，为什么要实现hashcode方法？还是上面的例子Name不仅要实现compareTo方法，还要实现hashCode方法啊， 就是为了快速查找吗？ IO流在学习IO的时候发现IO的类太多，如InputStream下面就用ReaderInputStream、InputStreamBuffer等等， 还用Reader、Writer、OutputStream等子类，一方面是太多，另一方面什么情况下用哪些类，这是个问题。 发射 反射可以做什么？个人理解主要可以用在程序运行中可以动态调用程序类和方法，知道的设计模式中动态proxy实现就用的inflate实现的， 但是当我们发布releases版本时候一般都进行了代码混淆， 这样反射就不起作用了。 总结谁然有上面的疑问， 我还是感觉java中学到很多东西和思想。以前不喜欢java。后来发现，我从java获得的东西比其他语言上学得东西要多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git 常用命令]]></title>
      <url>%2F2016%2F01%2F07%2Fgit_common_comand_introduce%2F</url>
      <content type="text"><![CDATA[自己用git已经一年多了， 还是好多命令还是记不住，但偶尔一些生僻的技能，总是需要去 Google，第二次用时又忘了。记录一下，方便以后查找。 工作流上面的是阮一峰bolg中常用 Git 命令清单图片感觉很形象， 这篇文章也很形象，在这里就不重复造车了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一枚c/c++程序员java探索－异常处理]]></title>
      <url>%2F2015%2F12%2F30%2Fjava_excption%2F</url>
      <content type="text"><![CDATA[概念 Java异常是Java提供处理程序中错误的一种机制。 错误是指在程序运行过程中发生地一些异常事件。 Java程序运行过程中如出现异常事件，可以生成一个异常对象，该异常对象封装了异常事件的信息并将被提交给Java运行时系统，这个过程称为抛出（throw）异常。 当Java运行时系统接收到异常对象时，会寻找能处理这一异常的代码并把当前异常对象交给其处理，这一过程称为捕获（catch）异常 1234567891011public class Test &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3&#125;; //定义一个数组 System.out.println(arr[3]); //数组下标越界，错误 try &#123; //尝试运行括号里的代码 System.out.println(2 / 0); &#125; catch (ArithmeticException ae) &#123;//捕获 ae.printStackTrace();//打印错误信息 &#125;//ae是系统自己定义的异常对象的名字 &#125;&#125; 异常分类 Throwable//所有异常类的父类 Error//称为处理不了的错误 Exception//能处理的错误（除Runtime Exception外的异常，必须处理） 在Exception中还包括一类特殊的异常（Runtime Exception），它可以处理，也可以不处理。 Finally关键字Finally段的代码无论是否发生异常都有执行 抛出和捕获异常把异常交给JVM处理1234567891011public class ExceptionTest &#123; public static void execute() throws Exception &#123; System.out.println("execute..."); throw new Exception(); &#125; public static void main(String[] args) throws Exception &#123;//自己不想处理，叫给上一层处理， 现在上一层是jvm execute(); &#125;&#125; 自定义异常 自定义异常类可以继承Throwable类或者Exception类，而不要继承Error类。自定义异常类之间也可以有继承关系 需要为自定义异常类设计构造方法，以方便构造自定义异常对象。若要在异常中添加附加信息，则可以为类添加一些变量和方法。本例演示的自定义异常没有按照业务类型来命名，而是创建一个通用异常类，以retCd来区别发生异常的业务类型与发生位置，当然对于具体的retCd值，事先必须有具体的规定或说明。 123456789101112131415161718192021222324252627282930313233/** * 多数情况下，创建自定义异常需要继承Exception，本例继承Exception的子类RuntimeException * @author Mahc * */ public class CustomerException extends RuntimeException &#123; private String retCd ; //异常对应的返回码 private String msgDes; //异常对应的描述信息 public CustomerException() &#123; super(); &#125; public CustomerException(String message) &#123; super(message); msgDes = message; &#125; public CustomerException(String retCd, String msgDes) &#123; super(); this.retCd = retCd; this.msgDes = msgDes; &#125; public String getRetCd() &#123; return retCd; &#125; public String getMsgDes() &#123; return msgDes; &#125; &#125; 注意事项当使用多个catch语句块来捕获异常时，需要将父类的catch语句块放到子类型的catch块之后，这样才能保证后续的catch可能被执行，否则子类型的catch将永远无法到达，Java编译器会报编译错误。 如果try语句块中存在return语句，那么首先会执行finally语句块中的代码，然后才返回。 如果try语句块中存在System.exit(0)语句，那么久不会执行finally语句块的代码了，因为System.exit(0)会终止当前运行的JVM。程序在JVM终止前结束执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA学习心得]]></title>
      <url>%2F2015%2F12%2F25%2Fjava_learn_summary%2F</url>
      <content type="text"><![CDATA[以前主要的开发语言是c/c++，才开始是因为工作需要开始学习java的（大学没有学过），才开始只是仅仅看懂代码就好， 也就大致看了看《java编程思想》这本书， 也没有仔细看。现在在做android开发需要大量编写java代码， 才发现自己的java基础还是不行， 有些思想还是和c++有区别的。我是真正开始系统学习java是加入成长会java小组开始的， 已经进行二三个月了，主要通过看马士兵的视频，可能自己不是新手吧， 学起来还是很轻松的。可能还有一个重要的原因吧， 工作中能用的上，秉着边学边用的原则，现在算是入门了,下面来说一下这一段时间的心得吧。 多实践任何事情，一旦考虑好了，就要马上上路，不要等到准备周全之后，再去干事情。软件开发是一门工程学科，注重的就是实践。最好是工作中能用到， 这样会学的更快，如果条件不满足，还是实践、实践、再实践。不过这个道理大家都知道， 怎么去坚持，这是个问题。还是要找到自己一个点， 可以找个同学一块学，相互监督、相互学习。我现在在教一个小同学学习编程，主要会每周让他输出文档，每周会抽出一两个小时去解决他的问题，一方面不想让他走我当时的走过的弯路，最想的是让他坚持。哪天他入门了， 就不需要我了，那时候我也很高兴。这期间我也得到了成长。 请教别人有人说万不得已才请教别人，就是你通过查找资料和API文档能找到的问题，不要问别人了。当然我赞同简单的google搜索，因为这是基本的学习能力， 如果你这个不会的话， 我个人认为你不适合这个行业，劝你还是现在掉头，回去洗洗睡吧，哈哈。我说的这个别人不是陌生人， 而是你认识的人， 最好他很认同你。如果这个人站的高度不一样，你可能获得意外的结果。有时候个人认为别人的思想远大于答案本身。所以朋友们，和你的同学和朋友搞好关系很重要，最后还是多请教别人吧。 多读好书这一点我自己做到不好， 我也会在接下来的时间去多读书。有时候看视频比看书更有效，可惜新技术视频更新太慢。这里不局限于技术的书籍，包括天文、历史、地理等等各类学科。如果你不知道方向在哪里的时候， 就多一些好书吧，说不定哪天你的格局开了。 英语英语就不多说了， 英语就不多说了， 英语就不多说了，重要的事情说三遍。这个最终决定你的高度。 学习开源软件这个我们有发言权， 因为我没有看过java的这些框架， 但是语音都是相通的，引用网上一些人的说话。 JAVA领域有许多源代码开放的工具、组件、框架，JUnit、ANT、Tomcat、Struts、Spring、Jive论坛、PetStore宠物店等等多如牛毛。这些可是前辈给我们留下的瑰宝呀。入宝山而空手归，你心甘吗？对这些工具、框架进行分析，领会其中的设计思想，有朝一日说不定你也能写一个XXX框架什么的，风光一把。分析开源软件其实是你提高技术、提高实战能力的便捷方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回顾2015]]></title>
      <url>%2F2015%2F12%2F21%2Fsummary-2015%2F</url>
      <content type="text"><![CDATA[2015年，我们见证了“互联网+”的欣欣繁荣，经历了股市的大幅震荡，迎来了普遍二孩时代的来临，体会了抗战胜利70周年的全国联欢……2015，即将过去，下面，让我们整理一下思绪，回顾自己的2015。 柴静纪录片《穹顶之下》2015年2月底，柴静纪录片《穹顶之下》将人们对“雾霾”的关注度推向一个新的高峰, “雾霾”继续作为人们关注的焦点成为人们日常讨论的热门话题。面对无孔不入的雾霾，如何改善环境是人人都需要思考的问题。可惜受到单方面原因，视频很快下架了，这几天更是这样，北京已经到了爆表的程度，让人窒息，是不是出来混，迟早要还的啊，你们懂得。 A股暴涨暴跌2014年底到2015年初，A股打破多年沉寂，大幅上涨，形势喜人，吸引了大批新股民入市，股票市场一时成为造富之地，期间到达过七年来的最高点，但从2015年第二季度起却多次暴跌，引发监管层推出一系列政策。个人经过多方分析，并没有入市，在这里呼吁一下，年轻人还是不要去碰这个东西， 不要听你旁边的说，谁谁挣多少，因为他赔多少别人不知道。还有中国股市自己的国情，有时候你拿经济学手法，也不定对，还有一些深层的东西， 这里就不说了，没办法天朝就是这样。 这里说我的一个同学吧，赔了60万，其中有10w左右是借自亲的，说实话我们也不知道他什么时候能从这次打击中走出来了，祝福他吧。 XcodeGhost病毒事件9月，一种名为XcodeGhost的病毒开始在手机上流传，该病毒主要通过非官方下载的Xcode传播，能够在开发过程中使编译出的 App 被注入第三方的代码，向指定网站上传用户数据。微信、滴滴出行、58同城、高德地图、铁路12306等多个知名应用受到影响，根据不完全统计，在本次感染事件中中招的 iOS 用户高达 1亿人，疑似XcodeGhost作者也已公开源码并致歉。类似这样的问题， 在中国还会很多， 大家可以关注一下乌云 。 关于设计本人更同意phodal的说法， 这个也是我个人努力的方向。 模式就是最好的架构。接着，我开始去探索模式如何去具体的应用。开始去创建一些能具体应用的一些场景，并编码去实现其的模式。不过，多数时候都会是一场空。当我可以实现这个模式的应用的时候，我就能做出来。而多数的时候并不是这样的，模式被强加到了一个具体的设计中。 这是一开始我没有意料到的点——模式是总结出来的。而就编码来说，设计模式也应该是重构出来的。一开始以某种设计模式作为理想化的设计，那就类似于瀑布流式的设计。定义好一个接口，并去实现之。并不是说预先设计不好，只是不会如预期的好。而一个模式可以让程序员之间有一个更好的交流接口，他们可以更快地了解到设计本身所含的一些思想。 然后，我就了解到了浮现式设计的概念。可以演进的系统就是最好的系统，假定一开始我们就将系统限制于某种模式来构建，那么我们就会以这种模式来构建我们的系统。而业务本身就是不断变化的事务，因为人本身在不断地变化。同蝴蝶效应一样，可能只是你多余的一个手势，影响到了另外一个人，从而改变了系统的设计。如果你也知晓蝴蝶效应，那么这个模式就是我们的语言，你也就更能理解这句话。 寄语从最开始的自己坚持写东西，到现在的成为一种习惯，这就是成长吧。我想告诉她，带我羽翼丰满，我娶你回家哈。我是一个平凡的人， 时间短暂，珍惜现有，不要一片森林，只有属于我的大树。我觉得博客可以分为几种不同类型的文章： 技术、阅读笔记——学习 理论、技术实现过程——创造 思想、感受、总结——分享 我希望将来成为第三种！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一枚c/c++程序员java探索－对象（二）]]></title>
      <url>%2F2015%2F12%2F03%2Fhow_learn_java_object2%2F</url>
      <content type="text"><![CDATA[我们接着上一章来说 Package 和 import 语句 为了便于管理软件系统中数目众多的类，解决类名冲突问题，利用package机制 Package语句作为Java源文件的第一条语句，指该文件类所在的包（若没有该语句，则为无名包） 格式： package pkg1[.pkg2[.pkg3….]]; Java中，包相当于文件系统的目录管理，用‘ . ’来指明包（目录）的层次 例如 ：package com.example (则该文件中所有类位于 ./com/example) 类的继承和权限控制 Java中使用extends关键字实现类的继承机制 通过继承，子类自动拥有了父类的所有成员（成员变量和方法） Java只支持单继承，不用许多继承（一个子类只能有一个父类，一个父类可以派生多个子类） Java权限修饰符 public protect private 置于类的成员定义前，用来限定其他对象对该类对象成员的访问权限 对于class的权限修饰只可以用public 和 default Public可以在任意地方被访问 Default类只可以被同一个包内部的类访问 方法重写 在子类中可以根据需要对从父类中继承的方法进行重写 重写方法必须和被重写方法具有相同方法名称，参数列表和返回类型 重写方法不能使用比被重写方法更严格的访问权限 Super关键字 用super引用父类成分 继承中的构造方法 子类的构造过程中必须调用其父类的构造方法 子类可以在自己构造方法中使用super调用父类的构造方法，而且必须写在子类构造方法的第一行（this是调用本类的另外的构造方法） 如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造函数 如果子类构造方法中既没有显示调用父类构造方法，而父类中又没有无参数的构造方法，则编译出错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 class SuperClass &#123; private int nnt; SuperClass() &#123; System.out.println("SuperClass()"); &#125; SuperClass(int n) &#123; System.out.println("SuperClass(" + n + ")"); this.n = n; &#125;&#125; class SubClass extends SuperClass &#123; private int n; SubClass(int n) &#123; //super(); System.out.println("SubClass(" + n + ")"); this.n = n; &#125; SubClass() &#123; super(300); System.out.println("SubClass()"); &#125;&#125; public class TestSuperSub &#123; public static void main(String arg[]) &#123; //SubClass sc1 = new SubClass(); SubClass sc2 = new SubClass(400); &#125;&#125; Object类 Object类是所有Java类的根父类 如果在类的声明中未使用extends关键字指明其父类，则默认父类为object类 Tostring方法 object 类中定义有public string tostring（）方法，返回值是string类型 在进行string与其他数据类型的链接操作时（如：system.out.println(‘’info’’+person)）,将自动调用该对象类的string方法 可以根据需要在用户自定义类型中重写tostring（）方法 12345678910111213141516171819202122232425public class TestToString &#123; public static void main(String[] args) &#123; Dog d = new Dog(); System.out.println("d:=" + d); &#125;&#125; class Dog &#123; public String toString() &#123; return "I'm a cool dog!"; &#125;&#125; Equals方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TestEqual &#123; public static void main(String[] args) &#123; Integer i1 = new Integer(1); Integer i2 = new Integer(1); System.out.println(i1 == i2); System.out.println(i1.equals(i2)); Mao m1 = new Mao("A", "A"); Mao m2 = new Mao("A", "A"); System.out.println(m1 == m2); System.out.println(m1.equals(m2)); &#125;&#125; class Mao &#123; String name; String color; Mao(String n,String c)&#123; name = n; color = c; &#125; public boolean equals(Object obj) &#123; return true; &#125;&#125; 对象转型 一个父类的引用类型变量可以指向子类对象 一个父类的引用不可以访问其子类对象新增的成员（属性和方法） 可以使用 引用 变量instanceof类名，来判断该引用型变量所指向的对象是否属于该类或该类的子类 子类的对象可以当作父类的对象来使用，称作向上转型，反之想向下转型 动态绑定/多态指在执行期间（而非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125abstract class Animal &#123; private String name; Animal(String name) &#123;this.name = name;&#125; /* public void enjoy()&#123; System.out.println("叫声......"); &#125; */ public abstract void enjoy();&#125; abstract class Cat extends Animal &#123; private String eyesColor; Cat(String n,String c) &#123;super(n); eyesColor = c;&#125; /* public void enjoy() &#123; System.out.println("猫叫声......"); &#125; */ //public abstract void enjoy();&#125; class Dog extends Animal &#123; private String furColor; Dog(String n,String c) &#123;super(n); furColor = c;&#125; public void enjoy() &#123; System.out.println("狗叫声......"); &#125;&#125; class Bird extends Animal &#123; Bird() &#123; super("bird"); &#125; public void enjoy() &#123; System.out.println("鸟叫声......"); &#125;&#125; class Lady &#123; private String name; private Animal pet; Lady(String name,Animal pet) &#123; this.name = name; this.pet = pet; &#125; public void myPetEnjoy()&#123;pet.enjoy();&#125;&#125; public class Test &#123; public static void main(String args[])&#123; Cat c = new Cat("catname","blue"); Dog d = new Dog("dogname","black"); Bird b = new Bird(); //Lady l1 = new Lady("l1",c); Lady l2 = new Lady("l2",d); Lady l3 = new Lady("l3",b); //l1.myPetEnjoy(); l2.myPetEnjoy(); l3.myPetEnjoy(); &#125;&#125; Final 关键字 Final的变量的值不能够被改变 Final的方法不能够被继承 Final的类不能够被继承 接口（interface）接口是抽象方法和常量值的定义的集合 本质上，接口是一种特殊的抽象类，这种抽象类中包含常量和方法的定义，而没有变量和方法的实现 特性1.可以多重实现 2.接口中声明的属性默认为 public static final 的，也只能是他们 3.接口中只能定义抽象方法，而且是public的 4.接口可以继承其他的接口，并添加其他的属性和抽象方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一枚c/c++程序员java探索－对象（－）]]></title>
      <url>%2F2015%2F11%2F24%2Flearning_java_object1%2F</url>
      <content type="text"><![CDATA[面向对象思想 从现在世界中客观存在的事物出发来构造软件系统，在系统的构造中尽可能运用人类的自然思维方式。 强调运用人类在日常常采用的思想方法与原则，如抽象，分类，继承，聚合，多太等。 Java与面向对象 Java程序的核心就是对象（java程序中万事万物皆对象） 对象可看成静态属性和动态属性的封装体 类是创建同一类型的对象的模版，在一个类中定义了该对象具有的成员变量及方法 Java类的定义 类是用于描述同一类型的对象的一个抽象的概念，类中定义了这一类对象所具有的静态和动态属性 类可以一类对象的模版 Java面向对象基本概念 Java语言中除基本类型外变量类型都称引用类型 Java中对象是通过引用对其操作的 对象创建和使用 必须使用new关键字创建对象 Student st = new Student(); 使用对象.成员变量来引用对象的成员变量 使用对象.方法来调用对象的方法 同一类的每个对象有不同的成员变量储存空间 同一个类的每个对象共享该类方法 成员变量 成员变量可以使用Java语言中任何一种数据类型 定义成员变量可初始化，不初始化，将使用默认值 成员变量的作用范围为整个类体 内存分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 class BirthDate &#123; private int day; private int mouth; private int year; public BirthDate(int d, int m, int y) &#123; //构造函数 day = d; mouth = m; year = y; &#125; public void setDay(int d) &#123; day = d; &#125; public void setMouth(int m) &#123; mouth = m; &#125; public void setYear(int y) &#123; year = y; &#125; public int getDay() &#123; return day; &#125; public int getMouth() &#123; return mouth; &#125; public int getYear() &#123; return year; &#125; public void display() &#123; System.out.println(day + "-" + mouth + " -" + year) &#125; &#125; class Test &#123; public void main(String arge[]) &#123; Test test = new Test(); int date = 9; BirthDate d1 = new BirthDate(7, 7, 1970); BirthDate d2 = new BirthDate(1, 1, 2000); test.change1(date); test.change2(d1); test.change3(d2); System.out.println(" date =" + date); d1.display(); d2.display(); &#125; public void change1(int i) &#123; i = 1234; &#125; public void change2(BirthDate b) &#123; b = new BirthDate(22, 2, 2004); &#125; public void change3(BirthDate b) &#123; b.setDay(22); &#125;&#125; 这里内存分布图如下： 命名规则 类的首字母大写 变量名和方法名首字母小写 用驼峰标识 方法重载（overload）指一个类中可以定义相同的名字，但参数不同的多个方法。调用时，根据不同参数表选择对应的方法 this 关键字 一般用在类的方法中，代表使用该方法的对象的引用 必须指出当前使用方法的对象是谁时要使用this 使用this可以处理方法中成员变量和参数重名情况 this可以看作一个变量，他的值是当前对象的引用 static关键字 在类中，static声明的成员变量为静态变量，它为该类的功用变量，第一次使用被初始化，对该类的所有对象来说，static成员变量只有一份。 申明方法为静态方法，在调用时不会将对象的引用传递给他，所以在static方法中不可访问非static的成员（静态方法不在是针对于某个对象调用，所以不能访问非静态成员） 可以通过对象引用或类名访问静态成员]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一枚c/c++程序员java探索－一些常用类]]></title>
      <url>%2F2015%2F11%2F17%2Flearning_java_base_class%2F</url>
      <content type="text"><![CDATA[多看api文档多看api文档多看api文档重要的事情说三遍 字符串相关类(String、StringBuffer) java.lang.String代表不可变的字符序列。 String(byte[] bytes)一种编码格式改变成另外一种编码格式。 String(byte[] bytes,int offset,int length)从第几个位置开始，数几个字节，构建成字符串。 String(byte[] bytes,int offset,int length，String charsetName)用一个特定的字符编码，然后把这个字节数组改变成这个字符编码的一个字符串。 其他方法： public char charAt (int index)返回字符串中第index个字符 public int length()返回字符串的长度 public int indexOf(String str)返回字符串中出现str的第一个位置 public int indexOf(String str,int fromIndex)返回字符串中从fromIndex开始出现str的第一个位置 public boolean equalsIgnoreCase(String another)比较字符串与another是否一样(忽略大小写) public String replace(char oldChar,char newChar)在字符串中用newChar字符替换oldChar字符。 public boolean startsWith(String prefix)判断字符串是否以prefix字符串开头。 public boolean endsWith(String prefix)判断字符串是否以prefix字符串结尾。 public String toUpperCase()返回一个字符串为该字符串的大写形式 public String toLowerCase()返回一个字符串为该字符串的小写形式 public String substring(int beginIndex)返回该字符串从beginIndex开始到结尾的字符串 public String substring(int beginIndex，int endIndex)返回该字符串从beginIndex开始到endIndex结尾的字符串 public String trim()返回将该字符串去掉开头和结尾空格后的字符串静态重载方法： public static valueOf(Object obj) :任何一种数据类型的对象都可以往里扔，转成字符串。任何对象都当Object看，任何狗、任何猫都当Animal看。然后调用toString方法。传的什么类型，调用谁的toString()。【重写：动态绑定】 publicString[]split(String regex)可以将一个字符串按照指定的分隔符分割，返回分隔后的字符串数组。 StringBufferjava.lang.StringBuffer代表可变的字符序列。StringBuffer与String类似，但StringBuffer可以对其字符串进行改变。StringBuffer常见的构造方法：StringBuffer():创建一个不包含字符序列的“空”的StringBuffer对象。StringBuffer(String str):创建一个StringBuffer对象，包含与String对象str相同的字符序列。 StringBuffer 和 StringBuilder区别 如果你读过《Think in Java》，而且对里面描述HashTable和HashMap区别的那部分章节比较熟悉的话，你一定也明白了原因所在。对，就是支持线程同步保证线程安全而导致性能下降的问题。HashTable是线程安全的，很多方法都是synchronized方法，而HashMap不是线程安全的，但其在单线程程序中的性能比HashTable要高。StringBuffer和StringBuilder类的区别也在于此，新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。 基本数据类型包装类main函数拿到的任何类型都是字符串，怎么把字符串转换成相应的基础数据类型呢？例如：“3.14”–&gt;double。基础类型（四类八种）一般都分配在栈上，可你就是想让它分配到堆空间上需要将其包装成一个对象，有一系列类，叫做基础类型的包装类。Class ByteClass BooleanClass LongClass FloatClass DoubleClass Character static Byte parseByte(String s)static Double parseDouble(String s)static toString() 构造方法：Integer(int value) Integer(String s)static long valueOf(String s):把字符串转成相对应的数据类型包装类的对象。Long (long value):把long类型的数封装成long类型的对象，new Long(value)。long longValue():把long类型的对象里面的数拿出来。怎么把long类型的转换成int类型呢？前面加(int)但是，实际中内部执行的是intValue()方法。怎么把long类型的转换成float类型呢？floatValue()怎么把long类型的转换成double类型呢？doubleValue()数和数之间的转换，内部是这些方法在执行！包装类的常见方法： public static final int MAX_VALUE 最大的int型数 public static final int MIN_VALUE 最小的int型数 public long longValue() 返回封装数据的long类型 public double doubleValue()返回封装数据的double类型 public int intValue()返回封装数据的int值 public static int parseInt(String s) 将字符串解析成int型数据，返回该数据。 public static Integer ValueOf(String s) throws NumberFormatException返回Integer对象，其中封装的整型数据为字符串s所表示。 File类Java.io.File类代表系统文件名（路径和文件名）。并不代表物理上的文件。通过IO才能读出里面数据。 常见构造方法： public File(String pathname)：以pathname为路径创建File对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。（不是在硬盘上创建这样一个文件或路径，是在内存中创建一个名字叫这个的File对象，可以用public boolean exsits()查看是否真正存在这个文件） public File(String parent,String child)：以parent为父路径，child为子路径创建File对象。 File的静态属性String separator 存储了当前系统的路径分隔符。 枚举类java.lang.Enum枚举类型只能够取特定值中的一个 public enum EMessage { /**以下是http消息处理ID-----*/ CLIENT_INSTALLATION(0, &quot;test1&quot;), CLIENT_UPGRADE(1, &quot;test2&quot;), CLIENT_START(2, &quot;test3&quot;), /**----------------*/ ; private final String mUrlPath; public final int index; EMessage(int index, String url) { this.index = index; this.mUrlPath = url; } public String getUrlPath() { return mUrlPath; } } 枚举类型而不是一个变量！定义了一个类型就好比说定义了Person、Cat类型，用此类型再来定义变量。EMessage.values()获取对象数组]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一枚c/c++程序员java探索－基本语法]]></title>
      <url>%2F2015%2F11%2F09%2Flearning_java_base_syntax%2F</url>
      <content type="text"><![CDATA[这些语法和C＋＋差不多，还有一些区别。 标识符 Java对各种变量,方法,类等因素命名时使用的字符序列。凡是自己可以起名字的地方就是标识符，都应遵守标示符规则 标识符规则 标识符由字母，下划线“–”，美元符号“$”和数字组成（HellWord _123 $Like都是对的 而like@#就不对） 标识符必须由字母，下划线，美元符号开头（123 ，#like都不对） 标识符大小写敏感，一般长度不限制（hellword和HellWord 不是同一个类） Java标识符起名一般是见到名字就知道什么意识，最重要一点标识符起名不能跟Java关键字重名（class就不行） 关键字 Java中有特定的含义，有专门用途的字符串就是关键字（大多数编译器都会把关键字用其他颜色标注出来，例如public,class,do,void等） 关键字都是由小写英文组成 还要特别注意goto,const虽未被使用，也是Java的关键字 Java常量 Java常量值由字符串组成，区分为不同的数据类型 整数型常量 123 字符型 ‘a’ 字符串型 “like”例如：system out println(‘123’); 其中123就是Java常量 注意 要区分字符型常量和字符串型常量：前者是单引号后者是双引号 “常量”这个名词还可能用在其他语境中表示值不可变的变量。例：final关键字 Java变量 Java变量是程序中最基本的存储单元，其中包含变量名，变量类型和作用域 Java程序中每个变量都属于特定的数据类型，在使用前必须先申明 格式为：type varName[=value][{varName[=value]}] 例：int=123；string a = “like”; 从本质上讲变量其实是内存中一块小区域，使用变量名来访问这块区域，所以，每个变量使用前必须先申请（声明），然后必须复值（填充类容），才能使用 变量分类 按被声明的位置分局部变量：方法体（包括型参）或语句块内部定义的变量成员变量：方法的外部，类的内部定义的变量注意：类的外面不能有变量声明 按数据类型分基本数据类型变量引用数据类型变量 Java数据类型 布尔型一般用于逻辑运算，只可以取ture和false 整数类型声明long型常量后加‘l‘或者’L’ ，否者会出错（long c1=888888888888L 正确） Java浮点类型通常默认double型，要是声明一个常量为float型，则需在数字后加f或者F（double a=123.22正确 float f=12.2f正确） Java语句这个和c＋＋都一样的， 只是for语句有两种写法： ‘ int[] a = {1, 2, 3}; for(int i = 0; i &lt; a.length; i++;) { System.out.printf(&quot;item: &quot; + a[i]); }&apos; &apos;for(int i : a) { System.out.printf(&quot;item:&quot; + i); }&apos; 先写到这里吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一枚c/c++程序员java探索－序]]></title>
      <url>%2F2015%2F11%2F01%2Flearning_java_introdution%2F</url>
      <content type="text"><![CDATA[背景本人是个程序员一枚，以前主要的开发语言是c/c++，才开始是因为工作需要开始学习java的（大学没有学过），才开始只是仅仅看懂代码就好， 也就大致看了看《java编程思想》这本书， 也没有仔细看。现在在做android开发需要大量编写java代码， 才发现自己的java基础还是不行， 有些思想还是和c++有区别的。 正文有时候在网上看的很多java是门臃肿的语言（感觉c++也是这样），还是亲自去测试一下， 不然没有发言权。自己也没有写过系列笔记，那就从这里开始吧。也是为了激励自己， 中间会说说它和c++不同的地方，如果这个系列写完以后，效果好的话，在写别的系列， 如python、go。哈哈，自己又在意淫了。下一步准备分几个方面去记录， 如下： 基本语法 面向对象 异常处理 数组和常用类（String、StringBuffer） IO 容器 线程 网络 反射 [http://hujiandong.com/2016/01/28/learning_java_reflection/] 正则表达式 由于自己水平有限，文中有错误， 希望指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android L获取前台应用的包名]]></title>
      <url>%2F2015%2F10%2F20%2Fandroid_foregound_app%2F</url>
      <content type="text"><![CDATA[背景 前一段时间发现android5.0以后的手机发现我们的APP悬浮窗获取前台应用的名称不起作用了，以前我们的作法如下： 123456789101112131415public String getForegroundApp(Context context) &#123; ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;RunningAppProcesInfo&gt; lr = am.getRunningAppProcesses(); if (lr == null) &#123; return null; &#125; for (RunningAppProcessInfo ra : lr) &#123; if (ra.importance == RunningAppProcessInfo.IMPORTANCE_VISIBLE || ra.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND) &#123; return ra.processName; &#125; &#125; return null;&#125; 现在发现上面的lr.size一直是1, 也就是只能查找到自己。 最后google发现API 21 新增的接口 android.app.usage , 这个 API 比已弃用的 getRecentTasks( ) 方法提供了更详细信息。 实现 通过查看官网文档说明实现如下： 1234567891011121314private String getForegroundApp() &#123; long ts = System.currentTimeMillis(); List&lt;UsageStats&gt; queryUsageStats = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_BEST,ts-2000, ts); if (queryUsageStats == null || queryUsageStats.isEmpty()) &#123; return null; &#125; UsageStats recentStats = null; for (UsageStats usageStats : queryUsageStats) &#123; if(recentStats == null || recentStats.getLastTimeUsed() &lt; usageStats.getLastTimeUsed())&#123; recentStats = usageStats; &#125; &#125; return recentStats.getPackageName;&#125; 权限要求 要使用这个API，首先你必须在你的 mainifest 文件声明 “android.permission.PACKAGE_USAGE_STATS” 权限。然后在 设置 > 安全 > 有权查看使用情况的应用 里，用户必须允许该 app 的访问。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈工作和生活]]></title>
      <url>%2F2015%2F10%2F18%2Fwork_life%2F</url>
      <content type="text"><![CDATA[背景 十一前公司进行了常规体检， 然后十一因为有点事就回了一趟老家， 可能是父母都在身边的原因好几年没回去了。由于老婆没有一块回去，感觉就是脱缰的野马，也没人管，连续四五天两点以后回到家，当然肯定每天喝的也差不多了。中间一次聚会的时候发现当时上高中的时候暗恋的对象也来了（这个她本人好像知道）， 毕业以后也没怎么联系， 先后各自有组建了家庭，当时见面时候的心情大家懂的，又加上几个同学起哄，那天喝大了，最后不知道怎么回去的。当时人多也没聊上几句，在这里祝福你家庭幸福，工作顺心。纪念以下那时候我们真挚的同学情谊和那些年我们一起追过得女孩。想想剧情跟九把刀的作品剧情一样“狗血”和美好。靠，又跑题了。节后上班的时候体检中心通知体检结果出来了，然后查了一下，吓一跳，好几项有问题， 胆量息肉（3mm，不严重）、颈椎也有问题（也没感觉疼）。几天心情都不好（主要因为颈椎），今年才27岁啊。本人也经常锻炼身体，基本每周都会打篮球，也基本上不熬夜，12点之前肯定睡觉，可能和工作关系，最主要可能我天天晚上半趟着玩手机吧，昨天打球刚开始感觉脖子特别疼，随着运动进行就没有感觉了，锻炼还是有帮助的。 工作 工作这么几年，没有加班过晚上10点以后的，有时候听说的和看到有些人经常加班到11、12点以后，如果你不幸碰见了， 就不要犹豫了，赶紧走人吧。不要让自己一直处于亚健康状态，真的工作机会多的去， 不要相信老板给你画的饼，如果你是CEO那就算了，因为那是你的人生目标。还有一些公司上班996，这个我也不建议长待。 你只要每天高效工作4个小时左右，就能完成一天的工作，在以后就效率很低了， 那么我们就不如停下了，换换大脑。在这里吐槽一下还有些公司不能上外网，遇到这样的情况，我只能呵呵！ 总结 我们生活在一个食物不安全、空气等等不干净的国家，如果你自己都不注意，那说不定哪个时刻就去见马克思了，哈哈。一直认为工作只是生活的一部分， 工作只是为了生活服务的。疾病是不分年纪的，还是早发现问题早处理吧。呼吁大家不要宅在家了， 当天气好的时候走出来吧， 少年，碰跑吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo的next主题中添加微信公众号二维码]]></title>
      <url>%2F2015%2F10%2F15%2Fhow_add_weixinpublic%2F</url>
      <content type="text"><![CDATA[最近看别人的博客时发现有的站点有作者的微信公众号，感觉很好玩，也想在自己的博客弄一个。纪录一下简单的实现过程吧，不多说，先上图，有图有真相。 在theme下/layout/_macro/post.swig的 footer class=”post-footer” 下加入如下代码。 .src-js&#125;1234567891011121314151617181920212223242526&lt;! -- 添加微信图标 --&gt; &#123;% if config.weixin.enable %&#125; &#123;% if is_home() %&#125; &#123;% else %&#125; &lt;div&gt; &lt;span&gt; &#123;% if config.weixin.text %&#125; &#123;&#123; config.weixin.text &#125;&#125; &#123;% endif %&#125; &lt;br&gt; &lt;/span&gt; &lt;br&gt; &#123;% if config.weixin.public %&#125; &lt;a href=&quot;&#123;&#123; config.weixin.public &#125;&#125;&quot; title=&quot;Jason&apos;s微信公众号&quot; class=&quot;fancybox&quot; rel=&quot;article0&quot; style=&quot;float:left;margin-left:25%;margin-right:2px;&quot;&gt; &lt;img src=&quot;&#123;&#123; config.weixin.public &#125;&#125;&quot; title=&quot;Jason&apos;s微信公众号&quot; height=&quot;164px&quot; width=&quot;164px&quot;&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endif %&#125; &#123;% endif %&#125; 在根目录 config.xml 中添加如下代码即可。 .src-js&#125;1234weixin: enable: true text: 欢迎大家关注：Jason&apos;s微信公众号 public: http://7xnilf.com1.z0.glb.clouddn.com/weixin.jpg 将上面url换成自己的就行了，感兴趣的同学可以改改css吧。 Jason微信公众号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈黑客文化]]></title>
      <url>%2F2015%2F10%2F12%2Fhack_culture%2F</url>
      <content type="text"><![CDATA[以前转载过一篇《关于黑客文化和黑客精神》 文章。 《黑客与画家》这本书上大学的时候已经读过，那时对Paul Graham的思想不能理解（那时读书就是一种被动获取，不能提出针对性的问题）。工作几年以后最近又重新读了一边，发现和自己的部份观点一致， 当然作者有些观点和看法，放眼100年后还会是真理。本来早就想谈一谈自己对黑客和黑客文化的看法，怕自己的功力不够糟吐槽。就像我经常像我妈抱怨现在天朝的种种不满， 她就说你能不能有点正能量，年纪轻轻的，后来想想关那么多干什么，你不表达别人永远不知道（呵呵，自己又开始yiyin了，有点扯远了）。 为什么要看这本书编程首先是为了解决问题，其次是可以满足自己的好奇心，愉悦自己，有可能的话还可以利用此挣钱。可是中国IT教育往往直接引导学生向钱看，什么技术赚钱就鼓励学生去学什么；什么知识高深就要求学生学什么，妄图每个学生都能成为研究员，科学家。于是许多年了，中国也没出现多少伟大的黑客，也没出现几个以技术见长的创业公司。有的大多只是抄袭剽窃再加人海战术。 许多上大学前从未接触过编程的同学大一时就得学习语法繁琐的C或C++，他们还未对编程了解多少，就已经开始痛恨它了，有的甚至决定要换专业。“美好的赚钱前景”再加上具有中国特色的”忍“往往造就了许多拿着高薪，可心里痛恨自己工作的码农。 谈不上热爱怎么可能全身心投入继而创新呢？ 就好比学习英语是为了方便交流，阅读，泡外国妹子而不是为了通过各种英语等级认证。莫要本末倒置。 作者观点 黑客的出发点是原创，最终得到一个优美的结果；科学家的出发点是别人优美的结果，最终得到原创性。我们这个时代是否有所不同？只要读过一点历史，你就知道答案是“没有不同”。即使有那么一丝微小的可能，有史以来第一次，我们这个时代的所有信念都是正确的，那也是出于惊人的巧合，而不是因为我们真找到了正确的方向。 自问一个问题：大庭广众之下，你有没有什么观点不愿说出口？如果回答是没有，那么你也许应该停下来想一想了。你的每一个观点都能毫不犹豫地说出口，你自己深深赞同这些观点，并且你也确信肯定会获得别人的赞同，这是否太过于巧合了？一种可能是，也许事情并没有这么巧合，你的观点就是从别人那里听来的，别人告诉你什么，你就相信了什么，你把别人灌输的观点当作了自己的观点。到底什么话是不能说的？我们可以假设周围人因为说什么而陷入了麻烦。你会发现需要满足两个条件：第一，这些话不能说出口；第二，这句话看起来可能是正确的，值得进一步讨论。第二个条件很关键，因为你说2+2=5是不会有麻烦的。自由思考比畅所欲言更重要，在心里无所不想，但是不一定要说出来。或者找几个知己，与他们无所不谈，能够一起谈论“异端邪说”并且不会因此气急败坏的人，是最应该认识的朋友。 狂热分子都有一个共同点——缺乏幽默感。 公民自由是国家富强的原因，而不是结果。随着对公民自由的限制不断上升，政府的力量会先增加后减小。 公司内部所有不直接感受到竞争压力的部门和人，都应该外包出去。 金钱与财富不同，财富是目的，金钱是手段，是财富的一种简便的表达方式。社会的财富总值是个变量，目前看起来是逐步增加的。贫富差距的扩大是好是坏，要看是什么造成了差距，如果是通过财富的转移，那么是坏事，如果是通过创造新财富，那么是好事。 如果一家公司能够按照贡献付薪，它将取得巨大成功，小公司更适合。要更好的创造财富，你做的事情需要两点保证：可测量性，可放大性。硅谷的诀窍，可测量性来自小团队，可放大性来自开发新技术。 我们应该让自己的贡献更直接，如果你觉得自己是为公司的需要而工作，而感受不到你是为了满足顾客的某种需求而工作，就不是一个好信号。 政府禁止个人积累财富，本质上就是在命令人民减慢工作速度。强大起来的社会，都允许创造财富（注意不是通过转移获得财富）的人保住自己的财富。 随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。 浪费程序员的时间，而不是机器的时间，才是真正的无效率。随着计算机速度越来越快，这会越来越明显，所以，现在被认为缺点是运行速度慢的语言，将来会有更大的发展空间，毕竟从哲学角度上将，它的慢必然伴随着其他方面的优势。 人们真正注意到你的时候，不是第一眼看到你站在那里，而是发现过了这么久你居然还在那里。 画作永远没有完工的一天，你只是不再画下去而已。 How to do what you love《How to do what you love》是Paul Graham 2006写的一篇关于工作的文章。看完以后心中无数的疑惑有了答案，最深刻的两点是：找到自己志趣相投的工作是很难的事情；如何朝着这条路迈进。Paul拥有极强的独立思考能力，能从纷繁复杂的命题中拨笋般层层剥离，找到问题的内核。 大家可以去看看。 1、如何定义工作，工作到底是苦逼的还是好玩的？ 年少时的经验：学习和玩被老师分成两回事，而学习是为工作准备的。既然学习不好玩，那工作苦逼也就顺理成章。现在大多数人对问题的理解还停留在这个程度，就像认为生活一定是痛苦的一样。这个世界存在诸多未经检验的“常识”。高中时对大人的工作有了一定的了解，发现工作并不是那么苦逼。大人们至少是假装喜欢他的工作的。喜欢才能做得好，To do something well you have to like it。但大多是假装喜欢，干一行爱一行是一种工作伦理，不得以而为之。大学时的观念：工作并不仅是谋生，而应该是为世界创造了些什么，顺便活下来。The definition of work was now to make some original contribution to the world, and in the process not to starve. 当然，这个过程也必然包含了痛：要做出牛逼的事情，必然要有纪律，有坚持。 2、你到底应该有多喜欢自己的工作？How much are you supposed to like what you do? 大多数人会低估这个问题的难度，被父母的选择，金钱，名望和懒惰的惯性所控制，而不去思考。用了上下限的方法讨论这个问题： 喜欢程度的上限：你必须得一段时间像感官享受一样开心，当然持续时间不能只是短暂的一秒。 喜欢程度的下线：至少不能觉得下班后的休息时间是上班的痛苦换来的奖赏。 判断你喜欢上了的标准： To be happy I think you have to be doing something you not only enjoy, but admire. You have to be able to say, at the end, wow, that’s pretty cool. 不仅要享受工作，还要欣赏；得让你的圈子里的朋友说，牛逼！ 3、外物会蒙蔽你的喜欢 声望会左右你：看到别人获诺贝尔文学奖奖你就去写作，但你看不到背后的艰辛。 有时候金钱伴随着声望一起来干扰你的选择。 父母总是从保守稳定的角度来锁定你。 4、这个问题很难 如果观念上没有理清，还有很多外在的干扰因素，所以找到你志趣相投的事情很难。 那些年纪轻轻就找到自己的所爱的情况的一般都是异常的：年纪那么小就为如此复杂的人生选定了道路。 未来的你自己放心当年那个小孩的选择么？ 实际更经常的情况是：像乒乓球一样的职业生涯，最后才辗转很久才找到。 5、如何尝试转换？ 既然职业生涯有可能像乒乓球，那么是不是应该跳来跳去呢？每份工作都要做好，不能让做不好成为跳槽的借口，而应该养成把每一件事做好的习惯； 或者工作的同时，坚持在别的尝试方面有生产性输出。这即可防止你是因为懒惰而跳槽找借口，又可以为你找到所爱做一些启发性的尝试。 “Always produce” will discover your life’s work the way water, with the aid of gravity, finds the hole in your roof. 要注意不要被现实蒙蔽，低估自己的能力： 自己喜欢的事和自己可能做的事，这个是两码事，后者会污染你真正的思路，要时刻警惕。 you have to make a conscious effort to keep your ideas about what you want from being contaminated by what seems possible. 还有一个原理类似，事物总是被人们期待的愿望所污染，比如宗教。 6、如果找到了，不够谋生咋办？ One has to make a living, and it’s hard to get paid for doing work you love. 边做边挑；提高能力和见识，慢慢演化； 两份工作：一份为谋生，一份为所爱，注意不要让赚钱的工作污染了你。 7、不要太快做决定，慢慢来。 要么选一个媒介性的可转换的工作；要么自己趁年轻多试试； If you know you can love work, you’re in the home stretch, and if you know what work you love, you’re practically there. 黑客文化的精髓最近读了王垠的一篇《黑客文化的精髓》 被他的一些观点深深打动。 按照以上标准，我不认为自己是个黑客。我是一个计算机科学家，我按照几百年来国际通用的礼节行事。计算机科学家与黑客的区别在于他不只按照工具的手册来完成规定的任务。他经常记不住别人设计的复杂工具如何使用，因为他本人是一个更好的设计师。他审视这些工具的设计合理性，发现蹩脚的地方，然后构思更好的设计方案。他总是嘲笑和自嘲，我们其实仍然生活在计算机的石器时代。 在自己的公司里，我希望创造一个更加人性化的氛围，而不是宣扬所谓的黑客文化。让所有人无论男女，无论水平如何都身心舒坦，受到尊重，可以谈天说地，不耻下问。 总结本人也走过弯路，那时上大学的时候学习编程氛围不好，宿舍7个人没有一个喜欢这个的，天天给我一些负能量，经常一个人孤军奋战，不知道怎么学。那时候还因为这个给外校的老师发过邮件，卖年还给本院的老师买东西（大家不要跟我学，那时候视野窄，不知道还有别的什么办法），只想他们带带我，直到工作了才知道如何学习。中国大学的教育，只交你屠龙之术，而不告诉你怎么应用这些屠龙之术，最后导致我们学完C语言不知道实际生活中他们能干什么，总之还是那句老话“授人以鱼不如授人以渔”。任何人任何时期都有迷茫的时候，不知道干什么的时候就多读几本好书吧（以前我也不爱读书，能读多少就多少吧，时间是有限的）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学英语（持续更新）]]></title>
      <url>%2F2015%2F09%2F28%2Fhow_learn_english%2F</url>
      <content type="text"><![CDATA[1 STARTED 学英语这件事情我已经尝试无数次了，都已失败告终。 主要原因还是自身的惰性，每次都找借口安慰自己，每次看到我的计划表都有种负罪感。最近和同学一起在大街上走碰见几个老外问路（由于我住的地有好多老外）， 我同学主动上前给他们攀谈告诉他们这里有建议他们去哪里看看等等， 我就远处不敢靠近，远远的看着。你们知道什么是屌丝的什么心情吗， 脑海里有多少个王大锤吗！！ 碰巧前几天看了 @tinyfool中关于英语学习的文章，又一次点燃我的激情。说实话我已经被打倒好多次， 已经丧失学英语的兴趣了， 这个一个行可怕。 我所有的事情都是靠兴趣推动的， 没有兴趣的东西就是就是坚持不久。 首先要先培养兴趣，找到学习英语的乐趣，一个星期更新一下进度,每天至少30分钟。 Let’s go! 2015-09-28 Mon：从看美剧开始吧， 先从简单的开始《老友记》，不看字幕，知道看懂80%为止。2015-10-9 Fri： 看玩《老友记－1》1,2集，看了不下五遍，看懂了50%，还需要加油！ 练习doulingo现代式的阶段。 2015-10-18 Sun：这周有点懈怠，目标没有完成 《老友记－1》1,2集，看懂55% duolingo进行到介词，我老婆就会赶上我了 加入了英语组（发钱了） 2015-10-23 Sun： 《老友记－1》1-9集，看懂40% duolingo进行到日期和时间，有点慢 看了一些英文书 2015-11-1 Sun：1.《老友记－1》1-9集，看懂50%2.记单词2003.duolingo进行到形容词4.听bbc 2015-11-7 Sun：1.看视频，这周看的有点少2.记单词3503.继续听bbc，还是听不懂 2015-11-13 Sat：1.记单词4002.继续听bbc， 听懂20% 2015-11-22 Sun：1.记单词5202.继续听bbc， 听懂30% 2015-11-29 Sun:1.重新巩固单词2002.这周没有听bbc，视频也没看 2015-12-07 Sun:1.重新巩固单词5402.这周没有听bbc，视频也没看]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu Android studio中引入so文件的方法]]></title>
      <url>%2F2015%2F09%2F15%2Fandroid_import_so%2F</url>
      <content type="text"><![CDATA[这几天将eclipse ADT项目移植到android studio中发现，jni中so没有导入到apk中，运行后发现提示“can’t find lib**.so”，折腾一段时间。 本人环境如下：studio vesion: 1.2.2android gradle:1.2.3PC：ubuntu 14.04 首先，在我们的Module的根目录中建立libs目录（如果有就不用了），将so文件分别拷入。 网上好多方法说，在build.gradle文件添加如下： .src-sh&#125;1234567891011task nativeLibsToJar(type: Zip, description: &quot;create a jar archive of the native libs&quot;) &#123; destinationDir file(&quot;$projectDir/libs&quot;) baseName &quot;Native_Libs2&quot; extension &quot;jar&quot; from fileTree(dir: &quot;libs&quot;, include: &quot;**/*.so&quot;) into &quot;lib&quot; &#125; tasks.withType(JavaCompile) &#123; compileTask -&gt; compileTask.dependsOn(nativeLibsToJar) &#125; 我没有尝试成功， 可能本人是linux平台原因吧，最后发现两种方式。 1.1 手动添加修改build.gradle: .src-sh&#125;123456789101112131415161718192021222324android&#123;....sourceSets &#123; main &#123; ... jniLibs.srcDirs = [&apos;libs&apos;] &#125; &#125;packagingOptions &#123; exclude &apos;META-INF/DEPENDENCIES&apos; exclude &apos;META-INF/LICENSE&apos; exclude &apos;META-INF/LICENSE.txt&apos; exclude &apos;META-INF/license.txt&apos; exclude &apos;META-INF/NOTICE&apos; exclude &apos;META-INF/NOTICE.txt&apos; exclude &apos;META-INF/notice.txt&apos; exclude &apos;META-INF/ASL2.0&apos; exclude &apos;lib/mips/*.so&apos; //这里可以替换具体的so文件 exclude &apos;lib/armeabi/*.so&apos; exclude &apos;lib/x86/*.so&apos; &#125;&#125; 1.2 指定路径修改build.gradle: .src-sh&#125;1234567891011android&#123;splits &#123; abi &#123; enable true reset() include &apos;x86&apos;, &apos;x86_64&apos;, &apos;arm64-v8a&apos;, &apos;armeabi-v7a&apos;, &apos;armeabi&apos; universalApk false &#125; &#125;&#125; 可以根据自己需要添加。 /home/hujd/project/org/blog/android_import_so.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[智能指针解析与实现]]></title>
      <url>%2F2015%2F09%2F10%2Fsmartpointer%2F</url>
      <content type="text"><![CDATA[看一些开源项目，经常发现用智能指针的地方。以前不止一位老大哥给我说过，不要随便用智能指针，用不好就是大坑。每次想用时候想起先人的话就放下了，频繁分配内存的地方都从内存池上分配。报这怀疑的态度，想一探究竟，上网找了一些资料，然后总结了一下。 1 什么是智能指针从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。 2 智能指针有哪些c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr, scoped_ptr(boost), 其中后三个是c++11支持，并且第一个已经被c++11弃用。 2.1 scoped_ptr这是比较简单的一种智能指针，正如其名字所述，scoped_ptr所指向的对象在作用域之外会自动得到析构，一个例子是：此外，scoped_ptr是non-copyable的，也就是说你不能去尝试复制一个scoped_ptr的内容到另外一个scoped_ptr中，这也是为了防止错误的多次析构同一个指针所指向的对象。 2.2 shared_ptr所实现的本质是引用计数(reference counting)，也就是说shared_ptr是支持复制的，复制一个shared_ptr的本质是对这个智能指针的引用次数加1，而当这个智能指针的引用次数降低到0的时候，该对象自动被析构。 需要特别指出的是，如果shared_ptr所表征的引用关系中出现一个环，那么环上所述对象的引用次数都肯定不可能减为0那么也就不会被删除，为了解决这个问题引入了weak_ptr。 2.3 weak_ptr对weak_ptr起的作用，很多人有自己不同的理解，我理解的weak_ptr和shared_ptr的最大区别在于weak_ptr在指向一个对象的时候不会增加其引用计数，因此你可以用weak_ptr去指向一个对象并且在weak_ptr仍然指向这个对象的时候析构它，此时你再访问weak_ptr的时候，weak_ptr其实返回的会是一个空的shared_ptr。 实际上，通常shared_ptr内部实现的时候维护的就不是一个引用计数，而是两个引用计数，一个表示strong reference，也就是用shared_ptr进行复制的时候进行的计数，一个是weak reference，也就是用weak_ptr进行复制的时候的计数。weak_ptr本身并不会增加strong reference的值，而strong reference降低到0，对象被自动析构。 为什么要采取weak_ptr来解决刚才所述的环状引用的问题呢？需要注意的是环状引用的本质矛盾是不能通过任何程序设计语言的方式来打破的，为了解决环状引用，第一步首先得打破环，也就是得告诉C++，这个环上哪一个引用是最弱的，是可以被打破的，因此在一个环上只要把原来的某一个shared_ptr改成weak_ptr，实质上这个环就可以被打破了，原有的环状引用带来的无法析构的问题也就随之得到了解决。 weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。 .src-C++&#125;1234567891011121314151617181920212223242526272829303132333435class B;class A&#123;public: shared_ptr&lt;B&gt; pb_; ~A() &#123; cout&lt;&lt;&quot;A delete\n&quot;; &#125;&#125;;class B&#123;public: shared_ptr&lt;A&gt; pa_; ~B() &#123; cout&lt;&lt;&quot;B delete\n&quot;; &#125;&#125;;void fun()&#123; shared_ptr&lt;B&gt; pb(new B()); shared_ptr&lt;A&gt; pa(new A()); pb-&gt;pa_ = pa; pa-&gt;pb_ = pb; cout&lt;&lt;pb.use_count()&lt;&lt;endl; cout&lt;&lt;pa.use_count()&lt;&lt;endl;&#125;int main()&#123; fun(); return 0;&#125; 可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr\ pb_; 改为weak_ptr\ pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。 3 简单实现我们定义一个_counter类来记录引用次数，把_counter类的所有成员设定为private，因为其他的类型并不需要访问_counter，只有SmartPointer对其进行操作就行了，SmartPointer将设为其友元类。 .src-C++&#125;12345678class _counter&#123; template&lt;typename T&gt; friend class SmartPointer; _counter(int u):use(u)&#123;&#125; ~_counter()&#123;&#125; int use;&#125;; 在SmartPointer类中，保留_counter的指针。 .src-C++&#125;1234567891011121314151617181920212223242526272829303132333435363738394041template&lt;typename T&gt;class SmartPointer &#123;public: SmartPointer(T *t): pc(new _counter(1))&#123; cout&lt;&lt;&quot;SmartPointer copy invoked use is: &quot; &lt;&lt; pc-&gt;use&lt;&lt;endl; this-&gt;pt = t; &#125; SmartPointer(SmartPointer&lt;T&gt; &amp;rhs)&#123; this-&gt;pc = rhs.pc; this-&gt;pt = rhs.pt; this-&gt;pc-&gt;use++; cout&lt;&lt;&quot;SmartPointer copy invoked use is: &quot;&lt;&lt; pc-&gt;use&lt;&lt;endl; &#125; ~SmartPointer()&#123; pc-&gt;use--; cout&lt;&lt;&quot;SmartPointer::~SmartPointer() invoded use is: &quot;&lt;&lt;pc-&gt;use&lt;&lt;endl; if(pc-&gt;use == 0)&#123; delete pt; delete pc; &#125; &#125; SmartPointer&lt;T&gt;&amp; operator=(SmartPointer&lt;T&gt; rhs)&#123; if(rhs == *this)&#123; return *this; &#125; this-&gt;pt = rhs.pt; this-&gt;pc = rhs.pc; this-&gt;pc-&gt;use++; cout &lt;&lt; &quot;SmartPointer::operator=() invoked use is &quot; &lt;&lt; pc-&gt;use &lt;&lt; endl; return *this; &#125;private: T *pt; _counter *pc;&#125;; 例如：我们有一个HasPtr类，其类成员中有一个为指针*p。 .src-C++&#125;123456789101112class HasPtr &#123;public : HasPtr(int val):value(val), p(new int(3))&#123; cout &lt;&lt;&quot;HasPtr::HasPtr() invoked&quot;&lt;&lt;endl; &#125; ~HasPtr()&#123;delete p; cout&lt;&lt;&quot;HasPtr::~HasPtr() invoded&quot; &lt;&lt;endl;&#125;private: int *p; int value;&#125;; 测试： .src-C++&#125;12345678910111213int main(int argc, char *argv[])&#123; HasPtr *php = new HasPtr(3); cout&lt;&lt;&quot;---1&quot;&lt;&lt;endl; SmartPointer&lt;HasPtr&gt; psp(php); cout&lt;&lt;&quot;---2&quot;&lt;&lt;endl; SmartPointer&lt;HasPtr&gt; npsp(psp); cout&lt;&lt;&quot;---3&quot;&lt;&lt;endl; SmartPointer&lt;HasPtr&gt; nnpsp = npsp; cout&lt;&lt;&quot;---4&quot;&lt;&lt;endl; return 0;&#125; 4 如何选择智能指针如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括： 有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素； 两个对象包含都指向第三个对象的指针； STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。 5 参考 智能指针 http://www.cnblogs.com/bigwangdi/archive/2013/06/15/3138123.html /home/hujd/project/org/blog/smartpointer.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux实用技巧]]></title>
      <url>%2F2015%2F08%2F24%2F2015-08-24-linux-skill%2F</url>
      <content type="text"><![CDATA[Table of Contents 1 linux技巧 1 linux技巧个人感觉自己一直在linux工作，应该基本的技巧应该都知道，即使没吃过猪肉，也应该见过猪跑吧。最近看了耗子哥的一篇应该知道的linux技巧 文章真是亮瞎了眼，越往后看，越心虚。看来自己不能自大啊，本来自己想写一篇内似的文章，这篇已经写的挺好的了就不重复造车了，mark一下，写自己一些看法，就当是观后感方便自己以后查找。 这篇文章主要分下面几个方面： 基础：这个主要介绍一些基本的操作这个是比备的计能，作者应该是个vimer，可惜我更爱emacs，哈哈。 日常：这个很有用自己工作中也用的比较多，但是对html、xml处理用的比较少，ssl是要经常用的，翻墙一种神器。 数据处理：这个比较有用， 以前面式的时候问到让你统计文件中前50个重复行的个数，当时忘记uniq中c的参数可以做道，走了很多弯路，才知道iconv这个命令可以文件转码。 系统调试：mtr定位网络问题，没有用过，第一次用过。 感觉他的下两个相关问题，也值得一看： AWK 简明教程 sed 简明教程 点滴积累什么时候都不晚！ /home/hujd/project/org/blog/linux_skill.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android 笔记]]></title>
      <url>%2F2015%2F07%2F12%2F2015-7-12-andorid-note%2F</url>
      <content type="text"><![CDATA[Table of Contents 1 android中常用的五种布局 1.1 FrameLayout 1.2 LinearLayout 1.3 AbsoluteLayout 1.4 RelativeLayout 1.5 TableLayout 2 android的数据存储方式 3 android DVM 的理解 4 android种线程间通讯 5 mvc模式的原理，android中的应用 6 android应用的入口点 7 android Service 和 Binder机制 8 andorid程序运行时的权限与文件系统权限的区别 8.1 linux文件系统上的权限 8.2 Android的权限规则 9 Activity的生命周期 10 Activity设置窗口样式 11 Activity被回收了怎么办 12 如何退出Activity，如何安全退出已调用多个Activity 的Application？ 13 系统上安装了多个浏览器，能否指定某浏览器访问指定页面？ 14 什么情况下会导致Force close ？ 如何避免？能否捕获导致其的异常？ 15 哪些情况下会发生ANR？ 怎么应对？ 16 View 如何刷新？ 16.1 不使用多线程和双缓冲 16.2 使用多线程和不使用双缓冲 16.3 使用多线程和双缓冲 最近在学习android应用开发， 发现的一些问题，进行了总结。这个就当是第一版以后还有什么问题，再进行更新吧。 1 android中常用的五种布局FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局） 1.1 FrameLayout这个布局可以看成是墙脚堆东西，有一个四方的矩形的左上角墙脚，我们放了第一个东西，要再放一个，那就在放在原来放的位置的上面，这样依次的放，会盖住原来的东西。这个布局比较简单，也只能放一点比较简单的东西。 1.2 LinearLayout线性布局，这个东西，从外框上可以理解为一个div，他首先是一个一个从上往下罗列在屏幕上。每一个LinearLayout里面又可分为垂直布局 （android:orientation=”vertical”）和水平布局（android:orientation=”horizontal” ）。当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。 linearLayout中有一个重要的属性 android:layout_weight=”1”，这个weight在垂直布局时，代表行距；水平的时候代表列宽；weight值越大就越大。 1.3 AbsoluteLayout绝对布局犹如div指定了absolute属性，用X,Y坐标来指定元素的位置android:layout_x=”20px” android:layout_y=”12px” 这种布局方式也比较简单，但是在垂直随便切换时，往往会出问题，而且多个元素的时候，计算比较麻烦。 1.4 RelativeLayout相对布局可以理解为某一个元素为参照物，来定位的布局方式。主要属性有： 相对于某一个元素android:layout_below=”@id/aaa” 该元素在 id为aaa的下面 android:layout_toLeftOf=”@id/bbb” 改元素的左边是bbb 相对于父元素的地方 android:layout_alignParentLeft=”true” 在父元素左对齐 android:layout_alignParentRight=”true” 在父元素右对齐 还可以指定边距等，具体详见API 1.5 TableLayout表格布局类似Html里面的Table。每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素，设定他的对齐方式 android:gravity=”” 。 2 android的数据存储方式Android系统提供了四种存储数据方式。分别为：SharePreference、SQLite、Content Provider和File。但由于Android系统中，数据基本是私有的，都是存放于”data/data”程序包名目录下，所以要实现数据共享，正确方式是使用Content Provider SQLite：SQLite是一个轻量级的数据库，支持基本的SQL语法，是常被采用的一种数据存储方式。 Android为此数据库提供了一个名为SQLiteDatabase的类，封装了一些操作数据库的api SharedPreference： 除SQLite数据库外，另一种常用的数据存储方式，其本质就是一个xml文件，常用于存储较简单的参数设置。 File： 即常说的文件（I/O）存储方法，常用语存储大数量的数据，但是缺点是更新数据将是一件困难的事情。 ContentProvider: Android系统中能实现所有应用程序共享的一种数据存储方式，由于数据通常在各应用间的是互相私密的，所以此存储方式较少使用，但是其又是必不可少的一种存储方式。例如音频，视频，图片和通讯录，一般都可以采用此种方式进行存储。每个Content Provider都会对外提供一个公共的URI（包装成Uri对象），如果应用程序有数据需要共享时，就需要使用Content Provider为这些数据定义一个URI，然后其他的应用程序就通过Content Provider传入这个URI来对数据进行操作。 3 android DVM 的理解DVM有如下特征： ＋使用专有的.dex格式。 ＋原因是java类文件在编译过后，会产生至少一个.class文件包含大量陈余信息，dex文件格式会把所有的.class文件内容整合到一个.dex文件中。即减少了整体文件的尺寸和IO操作，也提高了类的查找速度。 ＋增加了对新的操作码的支持 ＋文件结构尽量简洁，使用等长的指令，借以提高解析速度。 ＋尽量扩大只读结构的大小，借以提高跨进程的数据共享。 ＋dex的优化，dex文件的结构是紧凑的，但是如果想提高运行时的性能，就需要对dex文件进行进一步的优化，这些优化针对以下几个方面： ＋验证dex文件中的所有类 ＋对一些特定的类和方法里面的操作码进行优化 ＋调整所有的字节序(Little_endian)和对齐结构中的每一个域 ＋基于寄存器，基于寄存器的虚拟机虽然比基于堆栈的虚拟机在硬件，通用性上要差一些，但是它的代码执行效率去更好 ＋每一个Android应用都运行在它自己的DVM实例中，每一个DVM实例都是一个独立的进程空间。所有的Android应用的线程都对应一个Linux线程，DVM因此可以更多地依赖操作系统的线程调度和管理机制。不同的应用在不同的进程空间里运行，不同的应用都是用不同的Linux用户来运行以最大程度地保户应用程序的安全性和独立性 4 android种线程间通讯android 有一种叫消息队列的说法，这里我们可以这样理解：假如一个隧道就是一个消息队列，那么里面的每一部汽车就是一个一个消息，这里我们先忽略掉超车等种种因素，只那么先进隧道的车将会先出，这个机制跟我们android 的消息机制是一样的。 Looper:(相当于隧道) 一个线程可以产生一个Looper 对象，由它来管理此线程里的Message Queue( 车队,消息隧道) 。 Handler: 你可以构造Handler 对象来与Looper 沟通，以便push 新消息到Message Queue 里；或者接收Looper( 从Message Queue 取出) 所送来的消息。 Message Queue( 消息队列): 用来存放线程放入的消息。 线程：UI thread 通常就是main thread ，而Android 启动程序时会替它建立一个Message Queue。 5 mvc模式的原理，android中的应用mvc是model,view,controller的缩写，mvc包含三个部分： 模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。 视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。 控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。 android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下： 视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如果你对android了解的比较的多了话，就一定可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。 控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。 模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。 6 android应用的入口点android应用程序提供的是入口Activity,而非入口函数 从哪里定义它是Activity呢?AndroidManifest.xml文件中定义了整个android应用所包含的Activity. 7 android Service 和 Binder机制Service作为Android四大组件之一，在后台处理一些耗时的逻辑，或者去执行某些需要长期运行的任务。必要的时候我们甚至可以在程序退出的情况下，让Service在后台继续保持运行状态。 Binder关联机制 8 andorid程序运行时的权限与文件系统权限的区别8.1 linux文件系统上的权限-rwxr-x–x system system 4156 2010-04-30 16:13 test.apk 代表的是相应的用户/用户组及其他人对此文件的访问权限，与此文件运行起来具有的权限完全不相关。比如上面的例子只能说明system用户拥有对此文件的读写执行权限；system组的用户对此文件拥有读、执行权限；其他人对此文件只具有执行权限。而test.apk运行起来后可以干哪些事情，跟这个就不相关了。千万不要看apk文件系统上属于system/system用户及用户组，或者root/root用户及用户组，就认为apk具有system或root权限 8.2 Android的权限规则 Android中的apk必须签名 基于UserID的进程级别的安全机制 默认apk生成的数据对外是不可见的 AndroidManifest.xml中的显式权限声明 9 Activity的生命周期下面一张图描述这个过程: 10 Activity设置窗口样式 在你的styles.xml文件中可以新建一如下的style: &lt;style name=&quot;Theme.FloatActivity&quot; parent=&quot;android:style/Theme.Dialog&quot;&gt; 2.在AndroidManifest.xml中在你需要显示为窗口的activity中添加如果属性： android:theme=&quot;@style/Theme.FloatActivity&quot; 11 Activity被回收了怎么办当你的程序中某一个Activity A在运行中，主动或被动地运行另一个Activity B这个时候A会执行onSaveInstanceState()方法缓存一些计算的数据； public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); outState.putInt( “id” , 1); } B完成之后又会来找A，这个时候就有两种情况，一种是A被回收，一种是没有被回收，被回收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上参数savedInstanceState，没被回收的就还是onResume()就好了。 savedInstanceState是一个Bundle对象，可以理解为系统帮你维护的一个Map对象，在onCreate()里你可能会用到它，如果正常启动onCreate()就不会有它，所以用的时候要判断一下是否为空。 `if(savedInstanceState !=null) { int id =savedInstanceState.getInt( “id” ); }` 12 如何退出Activity，如何安全退出已调用多个Activity 的Application？对于单一Activity的应用来说，退出很简单，直接finish()即可。 当然，也可以用killProcess()和System.exit()这样的方法。 对于多Activity的应用来说,现提供几个方法: 抛异常强制退出. 记录打开的Activity 发送特定广播 递归退出 13 系统上安装了多个浏览器，能否指定某浏览器访问指定页面？具体方法如下： `Intent intent = new Intent(); intent.setAction(&quot;android.intent.action.VIEW&quot;); Uri content_uri_browsers = Uri.parse(&quot;http://isomobile.com&quot;); intent.setData(content_uri_browsers); intent.setClassName(&quot;com.android.browser&quot;, &quot;com.android.browser.BrowserActivity&quot;); startActivity(intent);` 问题的关键在于我们设置了class name，也就是我们想要跳转的pakcage的activity。如果你想要跳转到其它的浏览器，只需要修改一下这个函数就OK了。 好，我们现在来让刚刚的思路来指导我们的实践。假如我们现在要直接启动UC浏览器，那么我们该怎么做呢？让我们step by step吧。 下载UC apk：http://i-uc.net/read.php?2 下载反编译dex文件工具：http://nchc.dl.sourceforge.net/project/dedexer/dedexer/1.5/ddx1.5.jar（Dedexer 项目主页: http://dedexer.sourceforge.net/） 执行命令：java -jar ddx1.5.jar -o -D -d c:\ c:\classes.dex 得到package name是：com.uc.browser,启动的activity是：com.uc.browser.ActivityUpdate（补充：当我在这里选择采用ActivityBrowser的时候发觉权限不够，报permiss denied 异常，而且也不是我们要的那个activity，幸运的是在第二次尝试用ActivityUpdate，刚好能满足要求） 修改上面的代码为intent.setClassName(“com.uc.browser”,”com.uc.browser.ActivityUpdate”); 14 什么情况下会导致Force close ？ 如何避免？能否捕获导致其的异常？程序出现异常，比如nullpointer会导致Force Close。 避免：编写程序时逻辑连贯，思维缜密。 能捕获异常，在logcat中能看到异常信息 15 哪些情况下会发生ANR？ 怎么应对？在Android中，应用的响应性被活动管理器（Activity Manager）和窗口管理器（Window Manager）这两个系统服务所监视，当用户触发输入事件（如按键、触摸屏事件）的响应超过5秒，或者广播接收者（BroadcastReceiver）的onReceiver()方法在10秒没有执行完毕，那么Android会认为该应用无响应，便弹出ANR对话框。 避免方法：Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作、潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者异步方式）来完成，主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程；如果BroadcastReceiver要完成比较耗时的操作，应该通过发送Intent给Service,有Service来完成（注意广播接收者不能用子线程来解决，因为BroadcastReceiver的生命周期很短，子线程可能还没有结束BroadcastReceiver就先结束了；一旦BroadcastReceiver结束，它所在的进程（此时已变成空进程）很容易在系统需要内存时被优先杀死，那么正在工作的子线程也会被杀死）。 16 View 如何刷新？Android中对View的更新有很多种方式，使用时要区分不同的应用场合。我感觉最要紧的是分清：多线程和双缓冲的使用情况。 现在可以尝试理解下面的模拟场景： 两个人：一对夫妻，老公上班，老婆在家，现在他们都要吃饭。 “不使用多线程和双缓冲”的情况是：老公在公司吃，老婆在家吃，互不干扰，吃就是了。 “使用多线程和不使用双缓冲”的情况是：老婆做好饭，另外让人送一份到公司，老公收到饭就可以吃了。 “使用多线程和使用双缓冲”的情况是：老婆做好饭，等老公回家一起吃。 16.1 不使用多线程和双缓冲这种情况最简单了，一般只是希望在View发生改变时对UI进行重绘。你只需在Activity中显式地调用View对象中的invalidate()方法即可。系统会自动调用 View的onDraw()方法。 16.2 使用多线程和不使用双缓冲这种情况需要开启新的线程，新开的线程就不好访问View对象了。强行访问的话会报：android.view.ViewRoot$CalledFromWrongThreadException：Only the original thread that created a view hierarchy can touch its views. 这时候你需要创建一个继承了android.os.Handler的子类，并重写handleMessage(Message msg)方法。android.os.Handler是能发送和处理消息的，你需要在Activity中发出更新UI的消息，然后再你的Handler（可以使用匿名内部类）中处理消息（因为匿名内部类可以访问父类变量， 你可以直接调用View对象中的invalidate()方法 ）。也就是说：在新线程创建并发送一个Message，然后再主线程中捕获、处理该消息。 16.3 使用多线程和双缓冲Android中SurfaceView是View的子类，她同时也实现了双缓冲。你可以定义一个她的子类并实现SurfaceHolder.Callback接口。由于实现SurfaceHolder.Callback接口，新线程就不需要android.os.Handler帮忙了。SurfaceHolder中lockCanvas()方法可以锁定画布，绘制玩新的图像后调用unlockCanvasAndPost(canvas)解锁（显示），还是比较方便得。 Date: 2015-07-12 Sun Author: hujd Org version 7.9.3f with Emacs version 24 Validate XHTML 1.0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[不要做聪明人（转载）]]></title>
      <url>%2F2015%2F05%2F21%2F2015-05-21-no-smart-people%2F</url>
      <content type="text"><![CDATA[本文章转载这里。 世界上有三种人：聪明人，傻瓜，傻b。傻瓜和傻b的区别是，傻b是令人讨厌的傻瓜。很多人想做聪明人， 比其他人都聪明，结果他们变成了傻b。为什么会这样呢？ 其实很多人所谓的“聪明”，要么是能够高效的完成一些机械化的任务，要么是能够高效的绕过一些前人的 设计失误。他们的所谓“知识”，建立在一堆历史遗留的糟粕之上，他们以记得住这些脆弱的“知识”为豪。 所以，这些人连聪明是什么都不知道，又怎么可能成为聪明人？有些人很傻，只会死记硬背，却自认为很聪 明，所以他们让人厌恶，进而升级成为傻b。 如果你想做聪明人，那你往往不可能成为聪明人。想做聪明人的欲望，很容易让人变成傻b。有些人随时都在 担心自己不如别人聪明，随时都在比较，害怕别人比他更聪明。纳什（John Nash）因为一辈子都在跟人计较 谁更聪明，结果发疯了。他还算好点的，很多“天才”因为跟人计较谁更聪明，最后自杀了。世界上最傻的事情， 就是拿自己跟别人作比较。跟人比较的结果，最终都是不快乐，甚至给自己的身心带来伤害。 想做聪明人的欲望，让人变得喜欢争执，喜欢咄咄逼人的想证明自己是对的。它也使人变得固执和盲从，仓促 而盲目的相信或者排斥一些事物。有趣的是，这些人选择相信或者排斥的条件，往往在于最后的结果是否能让 自己显得聪明。想做聪明人的人，往往只关心自己知道的那点东西，发现别人貌似不懂就穷追猛打，抓住小辫子 不放，教育这些不懂的人！却没发现自己有多么无知。因为想证明自己比别人聪明，所以解决问题的时候，总喜 欢选择更困难，更复杂，看似更高深的解决方案。结果不但劳神费力，还阻碍了技术的简化和进步。 聪明是可遇而不可求的。聪明可能是一种结果，一种事实，却不可以是一种欲望，一种目标。想要成为聪明人的 欲望，多半会让人变成傻b。世界上所有试图成为聪明人的人，终究都会悟出一个道理。他们发现，自己更愿意做 一个傻瓜。很多人所谓的“聪明才智”，越来越多的被机器所代替和超越。随着科技的进步，人们耐以生存所需要的 死知识，会越来越少。这个世界越来越不需要聪明人，它更需要的是可爱的人。傻瓜往往很可爱。 未来的世界属于傻瓜。所以，我觉得每个人都应该放弃做聪明人的企图，反而应该有做傻瓜的欲望。做一个傻瓜，才能给你真正意义上的实惠和幸福。 Date: 2015-05-21 Author: hujd Org version 7.9.3f with Emacs version 24 Validate XHTML 1.0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android 直连]]></title>
      <url>%2F2015%2F05%2F12%2F2015-05-12-wifi-dirct%2F</url>
      <content type="text"><![CDATA[Table of Contents 1 概述 1.1 简介 1.2 适用范围 2 背景知识 2.1 功能介绍 2.2 特点 2.3 优缺点 3 提供功能和服务 3.1 P2P Discovery 4 P2P分析 4.1 总体架构分析 4.2 源文件说明 4.3 P2P Device name获取流程 4.4 P2P搜索功能流程 4.4.1 扫描结果处理NL80211_CMD_NEW_SCAN_RESULTS 4.4.2 wpas_p2p_scan_res_handler 4.5 P2P 连接过程 4.5.1 Provision Discovery 4.5.2 GO Negotiation 5 参考文档 1 概述1.1 简介Wifi Direct 又叫p2p（peer to peer）连接，它支持多个Wifi设备在没有AP的情况下相互连接，它属于链路层。 在Android 平台的Wifi相关模块中， p2p的功能主要集中如下： Framework中的WifiP2pService， 用于处理和P2P相关的工作。 wpa_supplicant中的P2P模块。 kernel driver（本文档不涉及） 1.2 适用范围本文档提供给使用android5.1平台进行相关设计的客户及内部相关软件工程师。 2 背景知识2.1 功能介绍2010年10月，Wi-Fi Alliance（wi-fi联盟）发布Wi-Fi Direct白皮书，白皮书中介绍了有关于这种技术的基本信息、 特点和功能。Wi-Fi Direct标准是指允许无线网络中的设备无需通过无线路由器即可相互连接。与蓝牙技术类似，这种标 准允许无线设备以点对点形式互连，而且在传输速度与传输距离方面则比蓝牙有大幅提升。 按照定义，Wi-Fi CERTIFIEDWi-Fi Direct设备是支持对等连接的设备，这种设备既支持基础设施网络，也支持P2P连 接。Wi-Fi Direct设备能够作为典型的站点（STA）加入基础设施网络，而且必须支持Wi-Fi Protected Setup加入者功能。 Wi-Fi Direct设备通过组建小组（以一对一或一对多的拓扑形式）来建立连接，小组的工作形式与基础设施BSS类似。由一部 Wi-Fi Direct设备负责整个小组，包括控制哪部设备加入、小组何时启动和终止等。这种设备对于传统客户设备而言就是一部 接入点，能够提供基础设施接入点所提供的部分服务。 最初，Wi-Fi Alliance&amp;reg联盟的这一新标准原名为“Wi-Fi peer-to-peer”，也即: Wi-Fi P2P，而最终定名为WiFi Direct，面向各种Wi-Fi设备，从电脑到手机到电脑外设到家电等等。符合该标准的设备无需热点和路由器， 就可以方便的和 其他设备实现直接连接，传输数据或共享应用。Wi-Fi Direct可以支持一对一直连，也可以实现多台设备同时连接，并且Wi-Fi Direct标准将会支持所有的Wi-Fi设备，从11a/b/g至11n，不同标准的Wi-Fi设备之间也可以直接互联。 2.2 特点Wi-Fi Direct设备进一步拓展了Wi-Fi技术的覆盖范围，延伸至简单的直接连接，其连接效果与网线连接毫无二致。 其主 要特点如下： 移动性与便携性：Wi-Fi Direct设备能够随时随地实现互相连接。由于不需要Wi-Fi路由器或接入点，因此Wi-Fi设备 可以在任何地点实现连接。 易用性：Wi-Fi Direct设备发现（Device Discovery）与服务发现（Service Discovery）功能帮助用户确定可 用的设备与服务，然后建立连接。例如，如果用户想要打印文件，他们可以通过上述服务了解到哪个Wi-Fi网络拥有打印机。 即时可用性：用户将得以利用带回家的第一部Wi-Fi Direct认证设备建立直接连接。例如，一部新购买的Wi-Fi Direct 笔记本可以与用户已有的传统Wi-Fi设备创建直接连接。 简单而安全的连接：Wi-Fi Direct设备采用Wi-Fi Protected Setup™简化了在设备之间创建安全连接的过程。用户可 以按下任一设备上的按钮，也可以输入PIN码（即设备显示的PIN码），轻松创建安全连接。 2.3 优缺点主要优点：传输速率高，兼容原有设备 主要缺点：耗电量高（较之蓝牙） 3 提供功能和服务P2P主要包括三大功能： P2P Discovery:提供一系列的方法去发现和快速连接P2P device P2P Group Operation：类似BSS中STA和AP之间的功能 P2P Power Management 3.1 P2P DiscoveryP2P Discovery的作用很简单， 就是使多个p2p device 能够互相发现并构建一个group。根据协议规范， 它包括四个主要子项： Device Discovery: 用于 P2P 设备搜索周围其他支持 P2P 的设备。 Service Discovery:该 Device Discovery 基础上,P2P 还支持搜索指定的服务。这部分功能属于可选项. Group Formation:用于决定两个 P2P Device 谁来扮演 GO,谁来扮演client. P2P Invitation:用于激活一个 Persistent Group(见下文解释),或者用于邀请一个 Client 加入一个当前已存在的 Group。 P2P Device Discovery 的工作流程包含两个状态和两个阶段。先来看两个状态,它们分别是: Search State:在该状态中,P2P Device 将在 2.4GHz 的 1,6,11 频段上分别发送 Probe Request 帧。这几个频段被称为 Social Channels。为了区别非 P2P 的 Probe Request 帧,P2P Device Discovery 要求必须在 ProbeRequest 帧中包 含 P2P IE。 Listen State:在该状态下,P2P Device 将随机选择在 1,6,11 频段中的一个频段(被选中的频段被称为 Listen Channel)监 听 Probe Request 帧并回复 Probe Response 帧。值得指出的是,Listen Channel 一旦选择好后,在整个 P2P Discovery 阶段就不能更改。另外,在这个阶段中, Device P2P只处理那些包含了 P2P IE 信息的 Probe Request 帧。 再来看两个阶段,它们分别是: Scan Phase:扫描阶段。这一阶段和前面章节介绍的无线网络扫描一样,P2P Device 会在各个频段上发送 Probe Request 帧(主 动扫描)。P2PDevice 在这一阶段中不会处理来自其他设备的 Probe Request 帧。这一阶段过后,P2P Device 将进入下一个阶段, 即 Find Phase。 Find Phase:虽然从中文翻译来看,Scan 和 Find 意思比较接近,但 P2P的 Find Phase 却和 Scan Phase 大不相同。在这一阶 段中,P2P Device将在 Search State 和 Listen State 之间来回切换。Search State 中,P2P Device 将发送Probe Req- uest 帧,而 Listen State 中,它将接收其他设备的Probe Request 帧并回复 Probe Response 帧。 整个device discovery的工作流程，如下图所示： 图3-1 主要以下问题： Legacy client(不支持P2P 的device) 只能发现P2P GO。 P2P device关联上基础AP后，也同样还会处于listen state。如果p2p设备要求连接上所发现的设备，将做以下几点： 发送P2P invitation request 帧给目标P2P设备. 发送P2P invitation request 帧给先前建立的永久性p2p group的P2P GO. 初始化GON(group owner negotiation) 以构成新的group. 4 P2P分析4.1 总体架构分析P2P模块是Wlan模块的一个子功能从上往下依次是APP, Framework, JNI，WPA_Supplicant和kernel driver 。Android 平台P2P模块总体架构图如下，其中APP层属于com.android.settings应用进程，Framework层对象有WifiP2pService.java 初始化创建，因此属于system_process进程，应用与Framework层通过AIDL Binder进程间通信机制。HAL层实现属于wpa_sup－ plicant服务进程，Framework与之通过unix socket实现双向通信， wpa_supplicant通过nl80211中netlink方式跟kernel 相互间进行通讯。 图4-1 4.2 源文件说明 文件名 描述 WifiP2pService.java 和wifiService一样， 启动p2p状态机 WifiP2pServiceImpl.java 提供p2p状态机 WifiP2pSeting.java p2p UI显示 WifiMonitor.java 提供事件监听工作 WifiP2pManager.java p2p管理工作 wpa_supplicant.c wpa对外接口 p2p_supplicant.c p2p对外接口 scan.c scan相关功能接口 p2p.c p2p相关功能接口 events.c kernel事件上报接口 4.3 P2P Device name获取流程设备名称获得主要分为下面几步： 开启 WifiP2pService服务，启动p2p 状态机。一共有18个状态， 初始状态为P2pDisabledState。 wifi p2p 功能打开时，状态机处于P2pDisabledState状态，将会收到wifistatemachine DefaultState发送的消息：CMD_ENABLE_P2P。 启动monitor线程，连接supplicant,监听supplicant上报的消息并转换状态为P2pEnablingState。 wifimonitor成功关联上supplicant将发送消息WifiMonitor.SUP_CONNECTION_EVENT，在状态P2pEnablingState处理了此消息，切换至状态InactiveState 由于InactiveState是P2pEnabledState的子状态，所以会先调用到P2pEnabledState的enter。 发送广播WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION,用于通知WifiP2Psettings中P2P功能的启用情况。 发送广播 WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION，用于通知WifiP2Psettings中P2P连接情况，携带参数WifiP2pInfo， NetworkInfo，WifiP2pGroup。 本机设备初始化 initializeP2pSettings， 设置ssid名称，更新device 状态为AVAILABLE，发送广播 WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION给WifiP2Psettings。 过程如下图： 图4-2 4.4 P2P搜索功能流程点击搜索设备, 比较复杂，主要分为下面几步： APP（WifiP2pSettings.java）层调用startSearch()函数，它在调用frmaework的mWifiP2pManager.discoverPeers， 在discoverPeer 中最终调用mWifiNative.p2pFind。 然后hal层发送command”P2P_FIND “到wpa_supplicant,通过注册的socket接收并处理此命令。 在wpa_supplicant的wpas_p2p_find， 最终调用wpas_p2p_scan功能， 这个函数正是真正功能处理函数，主要如下： 构造probe req ie WSC IE和构造P2P IE信息。 wpa_drv_scan 给kernel driver发送cmd: NL80211_CMD_TRIGGER_SCAN,如果是p2p_probe,还将带上NL80211_ATTR_SCAN_SUPP_RATES 属性值,设置P2P支持的rate，p2p不支持11b rate(1, 2, 5.5, 11)。 设置P2P扫描结果处理函数 scan_res_handler为wpas_p2p_scan_res_handler。 整个设备搜索如下图所示： 图5-1 4.4.1 扫描结果处理NL80211_CMD_NEW_SCAN_RESULTS当nl80211像driver发送请求以后，等待对端回应，收到来自kernel wlan driver的NL80211_CMD_NEW_SCAN_RESULTS通知，返回wpa_scan_results 对象，调用wpas_p2p_scan_res_handler。 图5-2 4.4.2 wpas_p2p_scan_res_handler由于wpas_p2p_scan_res_handler比较复杂，我们还是单独说说吧， 它主要调用p2p_scan_res_handler和p2p_scan_res_handled函数 p2p_scan_res_handler： 它中调用p2p_add_device解析IE信息，创建p2p_device对象，将其加入p2p->devices链表中，函数最后调用 wpas_dev_found，给wifimonitor上报消息P2P_EVENT_DEVICE_FOUND，并携带信息。 p2p_scan_res_handled：进入find阶段的listen状态, 设置listen的通道，构造probe response帧的IE，启动wpas_start_listen 状态 如下图所示： 图5-3 4.5 P2P 连接过程p2p连接分下面几个阶段： 通过下发cmd：P2P_STOP_FIND，停止find，切换状态为Provision Discovery阶段 在ProvisionDiscovery阶段，根据config中的wps.setup向hal层发送命令：P2P_PROV_DISC 进入GO 流程 进入associate和4way-handeshake阶段 4.5.1 Provision Discovery整个过程主要是发送PD request帧和接收PD respone帧。 4.5.1.1 PD requestPD request帧最终将通过p2p_send_action函数发送出去，不过p2p_send_action并不简单， 它涉及off channel发送以及处理对应 netlink消息的过程。 图6-1 4.5.1.2 PD respone当收到对端发来的PD Response帧后， 低层会发送cmd： NL80211_CMD_FRAME，然后proccess_bss_event函数将被调用， EVENT_RX_ACTION帧代表action帧， EVENT_RX_MGMT代表其他类型的管理帧，wpa_supplicant_event将调用wpas_p2p_rx_action，而wpas_p2p_rx_action又会调用p2p_rx_action， p2p_process_prov_disc_resp函数处理PD Response帧。 图6-2 4.5.2 GO Negotiation4.5.2.1 GON request低层发送P2P_PROV_DISC_PBC_RSP_EVENT消息，然后P2pStateMachine通过p2pConnectWithPinDisplay 向对端发送Group Negotiation Request请求。 图6-3 4.5.2 GON response根据前面public Action帧处理逻辑的总入口函数 p2p_rx_p2p_action()当收到GON response 帧将在p2p_process_go_neg_resp 函数处理，该函数主要计算谁来伴演GO， 构造GON confirmation，发送GON confirmation action帧，发送以后wifi driver将向 WPAS发送一个NL80211_CMD_FRAME_RX_STATUS消息， 而该消息将导致nl80211 drvier发送 EVENT_TX_STATUS 消息，和P2P以及 event_tx_status相关的处理函数是 offchanelsend_action_tx_status。 图6-4 TODO 进入associate和4way-handeshake阶段- State &quot;TODO&quot; from &quot;&quot; &lt;span class=&quot;timestamp-wrapper&quot;&gt; &lt;span class=&quot;timestamp&quot;&gt;2015-04-21 Tue 16:07&lt;/span&gt;&lt;/span&gt; 这两个阶段和wlan0连接流程一样， 这里就不多说， 如果需要以后再加进来。 5 参考文档《Wi-Fi_P2P_Technical_Specification_v1.5》 《802.11-2012》 《深入理解android wifi nfc and gps》 Date: 2015-04-13 Author: hujd Org version 7.9.3f with Emacs version 24 Validate XHTML 1.0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2014个人总结]]></title>
      <url>%2F2015%2F02%2F16%2F2015-02-16-work-summary%2F</url>
      <content type="text"><![CDATA[Table of Contents序本来14年的个人总结早应该写了。由于最近事情很多，家里的事和工作的事，忙的我焦头烂鹅的，看看时间自己欠债太多，赶紧把自己挖的坑填上吧。每当我浏览计划表，告诉自己快点填坑，可能是因为堕性在给自己找借口吧。说了这么多，事情还是要做的。 在开始写以前， 先扯一下别的话题吧，由于快过年了吧， 旁边也没有什么人了，大家都回家过年了，又是一个回不去家的一年啊， 说实话真有点想家了，生我养我的地方了。 有人说我是一 个感性的人，太爱怀旧，喜欢老歌。我想可能是因为慢慢老去的原因吧，不可否认岁月是把杀猪的，一放毕业快四年了。 工作回顾这一年是个不平凡的一年，中国互联网公司最鼎胜的一年，各种互联网公司上市，典型的有强哥的京东和马云的阿里。 有人说“站在风口上，猪都能飞起来”， 也吹起来一大波创业潮。俗话说人罗活，树罗死，自己也换了一家公司，也换了一个方向，去做andorid手机了。 本人经历了年中的迷忙期， 虽不能说现在多成功， 但是至少让我看到一丝希望，有希望就有可能成功。有人说你是选择康桥大道，还是选择羊肠小道呢。“康桥大道”人多， 人多竞争就多， 这就是我们说商业红海和蓝海的区别。这个话题就不再这里展开了，哪天可以单独和大家一起讨论这个话题，简单说一下这个要因人而异，但是我一直认为路是自己选的，要尽量让每一步都走的踏实，希望自己老了，不后悔。有一点是可以肯定的脑袋决定屁肤，所以想法是很重要的。 以前自己写东西不管是blog还是notebook，都不喜欢用工具，仅仅用word和记事本，自己也知道它们效率不高，但是也不尝试去用别的工具。早就知道用org可以更高效，但是一直感觉emacs下的org要记的快捷键太多了，前几次尝试都以失败告终， 最近一次尝试终于成功了， 我现在用它写blog，做GTD（计划管理）。这个让我对emacs又有了一个全新的认识。简单说一下我个人的理解吧，org-mode更让你关注写的内容，让你不容易分心。说这么多没用， 谁用谁知道。 生活回顾生活其实很简单， 就一个主题， 我马上要当爸爸了，就在我写这篇文章以前，还陪媳妇去医院检察了。这个以后回分去我大部份的尽力和时间， 自己知道自己身上的担子会更重，要伴随我一辈子的时光。听别人说就是痛并快乐着吧，希望小家伙平安健康，也谢谢宝宝的妈妈。 展望新的一年， 还有很多的事情要做，要学习andorid架构和APP开发，要学习更新的东西，照顾好家人。 快过年了，希望家人和朋友身体健康，祝大家新年开心！阖家快乐！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于黑客文化和黑客精神]]></title>
      <url>%2F2015%2F02%2F08%2F2015-02-08-hacker%2F</url>
      <content type="text"><![CDATA[Table of Contents 1. 几篇不错的网文 1.1. 阮一峰：黑客的含义——《黑客与画家》的译者序 1.2. 商业化情境下的黑客精神 1.3. Paul Graham：顶尖黑客 1.4. Eric S. Raymond：如何成为一名黑客 2. 几位知名的黑客 2.1. Bill Joy 比尔·乔伊 2.2. Dennis Ritchie 丹尼斯·里奇 2.3. Eric Raymond 埃里克·雷蒙德 2.4. John Carmack 约翰·卡马克 2.5. Ken Thompson 肯·汤普逊 2.6. Kevin Mitnick 凯文·米特尼克 2.7. Linus Torvalds 林纳斯·托瓦兹 2.8. Paul Graham 保罗·格雷汉姆 2.9. Richard Stallman 理查德·斯托曼 2.10. Robert Morris 罗伯特·莫尼斯 2.11. Shawn Fanning 2.12. Steve Wozniak 史蒂文·沃兹尼克 关于黑客文化和黑客精神(转) 本文转载于编程随想的文章，原文在这里。 10天前，年仅26岁的天才黑客 AaronSwartz 自杀身亡，震惊了 IT界。今天转载一些和黑客有关的文章，一方面是纪念 Aaron Swartz，另一方面是让更多人了解黑客文化—— 不要把”黑客”当成纯粹的贬义词 ，不要把 hacker等同于 cracker ！ 1 几篇不错的网文1.1 阮一峰：黑客的含义——《黑客与画家》的译者序这篇通俗介绍了黑客文化的主要特点，并澄清了一些误区。 1.2 商业化情境下的黑客精神1.3 Paul Graham：顶尖黑客Paul Graham是硅谷的技术大牛兼资深风险投资家。此文告诉你顶尖黑客是啥样的家伙。 1.4 Eric S. Raymond：如何成为一名黑客Eric S. Raymond是开源运动的领军人物。这篇在互联网上流传很广。如果你想成为黑客眼中的黑客，此文必看。 2 几位知名的黑客顺便给大伙儿介绍几位全球顶级的黑客。这几位老兄要么是技术特别牛，要么是影响力特别大。通过了解这些人的事迹，或许你对”黑客”一词会有更多的体会。这个名单仅代表俺个人的喜好，未必足够全面，未必足够客观。（为了避免纠纷，以下按字母序排列） 2.1 Bill Joy 比尔·乔伊BSD 系统之父（BSD 是目前最有影响力的 Unix 衍生系统，MAC OS X 也是基于 BSD）Sun 的联合创始人兼首席科学家 Solaris 之父（Solaris 是 Sun 推出的 Unix操作系统） SPARC 之父（SPARC 是 Sun 推出的 CPU） VI 之父 2.2 Dennis Ritchie 丹尼斯·里奇Unix 之父（和 Ken Thompson 一起） C 语言之父 2.3 Eric Raymond 埃里克·雷蒙德著有多本弘扬黑客文化的著作： 《如何成为一名黑客》 《新黑客词典》《大教堂与市集》 《Unix 编程艺术》 2.4 John Carmack 约翰·卡马克ID Software 联合创始人，3维射击类游戏的教父独自完成了Wolfenstein（德军总部）、Doom（毁灭战士）、Quake（雷神之锤) 的 3D引擎 而且他把上述三款游戏都开源了，充分体现了黑客精神很多射击类游戏是从他写的 3D 引擎衍生出来的 2.5 Ken Thompson 肯·汤普逊B 语言之父（B 语言是 C 语言的前身） Unix 之父（和 Dennis Ritchie 一起）UTF-8 之父 Go 语言之父（和 Robert Griesemer，Rob Pike 一起） 2.6 Kevin Mitnick 凯文·米特尼克号称”头号黑帽黑客”，其经历极具传奇色彩 15岁就破解北美防空指挥系统16岁被逮捕，成为了全球第一名网络少年犯 因年龄太小，很快被释放之后他又入侵了当时几乎所有的大公司和大机构 2.7 Linus Torvalds 林纳斯·托瓦兹Linux 之父 Git 之父（Git 是目前 No1 的版本管理系统） 2.8 Paul Graham 保罗·格雷汉姆知名的 Lisp 黑客 和 Robert Morris 共同创办了 Viaweb（后被 Yahoo高价收购，成为 Yahoo Store） 在 IT创业界很有影响力，资助了大批技术型创业公司 著有《黑客与画家》一书 2.9 Richard Stallman 理查德·斯托曼FSF 之父（FSF 是自由软件基金会，最有影响力的开源组织） GCC 之父 GDB 之父Emacs 之父 2.10 Robert Morris 罗伯特·莫尼斯他的成名作是1988年的”莫尼斯蠕虫”（第一个通过网络自动传播的病毒） 和 PaulGraham 共同创办 Viaweb（后被 Yahoo 高价收购，成为 Yahoo Store） 2.11 Shawn FanningNapster 之父（Napster 是第一个有影响力的 P2P 分享平台） Path联合创始人（Path 是知名的社交网站） 2.12 Steve Wozniak 史蒂文·沃兹尼克少年时期是知名的 phreaker（飞客，也就是电话黑客，入侵电话交换系统）70年代后期与乔布斯共同创办了苹果当年乔布斯负责忽悠，沃兹尼克负责把乔布斯忽悠的东西实现出来独自设计了最初的几代苹果机 Date: 2015-02-08 Sun Author: hujd Created: 2015-02-08 Sun 16:55 Emacs 24.3.1(Org mode 8.2.10) Validate]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我为什么写博客]]></title>
      <url>%2F2011%2F12%2F18%2F2011-12-18-why-blog%2F</url>
      <content type="text"><![CDATA[世界这么乱，装纯给谁看写博客这个不知道几个“互联网世纪”前的东西，现在还有必要拿出来说吗？不想用太多的理论去说这个命题，先看看两个最近对我影响比较大的两个博客： Steve Losh Derek Sivers 第一个是Steve Losh的博客，我在搜索了VIM相关的关键字之后被带到了这里。简洁的风格和关屏的利落就已经吸引了我，顺手点开其他的文章看了看，博主非常的谨慎认真，每一篇都是高质量的作品，看得出他的用心，整个网站也是异常的简洁舒适，深深的被这种淡然的心态打动，躲进小楼成一统，哪管他春夏与秋冬。再看看他的介绍： “I’m a programmer, photographer, dancer &amp; bassist from Rochester, New York.” 呵呵，他完全就过着我期望的生活。 第二位博主的‘Co-op Business Model’文章也是让我茅厕顿开，这种分享的精神，用博主自己活生生的例子讲述出来之后，读者自然会被感动的，我也在团队内分享过这篇文章，下面我简要介绍一下他的事迹吧： 1994年，他把需要邮寄才能得到的版权申请表单扫描上传到网上，为大家申请提供方便的下载服务，直到版权机构将表单上网之前，他的网站是全美唯一一个可以下载到表单的地方，他也并没有盈利。 1995年，他为自己的乐队注册了一个名字，并且把注册过程详细的写在自己的博客上，很长一段时间内，他的这篇文章几乎成了注册乐队名称的标准教程。 1996年，他有了一个小唱片公司，也就有了一个条形码账户，他需要支付$750给条码协会，这样他就拥有了十万个条码，一开始他免费把这些条码给朋友们要出售的CD用，后来，越来越多人知道了他有条码，又懒得去自己申请账户，就给他付一定的费用，方便的使用，他每个收费$20，在过去的12年里，他靠出售这个条码就赚到了二百万美元。 1997年，他花费$1000申请了一个信用卡商户账户，用来销售自己的CD，一开始也免费给他的做音乐的朋友们帮忙卖，后来有越来越多的陌生人希望能使用他的账号，省的自己去申请，因为他有一些劳动量，所以也收取一定费用，每张专辑收取$35的制作费，然后每卖一张收$4，在过去的12年中，他赚到了二千万美元。 1999年，他学会了制作网站，一开始是为了展示自己的CD，后来他的朋友们抱怨自己的网站服务商很糟糕，希望能使用Derek Sivers的系统，因为也有一些劳动量，所以会一开始收取$300，然后每个月收取$20，在过去的9年中，他赚到了五百万美元。 2000年以后，他会无偿的分享所有他学到的东西，或许“他不是最聪明的人”，但是分享没有什么成本，而且这是正确的事，所以在后来的11年里，他收获了很多的好运与快乐，遇见了很多有趣的人。 找到了一个神交的外国博主，又有这么励志“好人好报”的故事，我想大道理不用讲太多也都明白了。 还有一篇理论性很强的文章做参考，我为什么写博客。 那些虚的没用，说点实际的或许这些看起来很美好的东西，你会觉得离自己很远，那就说点直接的收益，看看是否够诱人。 我还是先推荐一篇文章：怎样花两年时间去面试一个人，招聘永远是公司和个人的难题，双方的信息不对称，导致这个矛盾无法调和，这篇文章就是告诉你，如何自己去推销自己，让公司得到你的全部优质信息，尤其在现在的网络环境下，将自己工作有用的能力搬上网，那么就是最好的能力证明，就是最好的面试答案。无论你是程序员，还是设计师。 或许你会想，好吧好吧，那我找个博客站开一个博客好了，我不太会同意这个做法，有一个个人的品牌，对于自己的发展只有好处，行走网络江湖，有同一个ID标识，无论在哪里都会让人看到你，这样长期的潜移默化，个人的品牌效力也就展现出来了。然后有一个自己独立的域名，并且用心去经营，肯定会有人欣赏的。而且经过我的一番研究，成本并不是很高。 我期望的博客内容，并不是贴一段代码，或者胡言乱语两句，具体的质量可以参考Steve Losh，这样的高质量，更能展现自己的态度，或许你说有一些小心得小点滴也想和大家分享，那也可以在自己的空间下开一个Wiki频道，专门存放琐碎的知识点。 高质量的博文，肯定需要自己缜密的思考，并且需要一定的文笔才能将自己的想法完整清晰的表达出来，我在这两个方面都还差了很多，还需要大量的练习才好，给自己这样的机会。 在快知识、微段子横行的今天，能对一个个问题深入的去思考，一方面得到的是心灵的平静，更多的则是深入思考之后的收获的喜悦感，会有不一样的体会的。 技术很简单，不用担心或者你很幸运不是一个程序员，或者你是一个不用搞这些乱七八糟东西的程序员，那么相信我，你一样可以搭起来一个跟我的一模一样的个人站点的。 我要特别鸣谢以下几个站点、技术： GoDaddy DNSPod GitHub Jekyll Disqus 下面我来做一个简要说明，完整的搭建方法，我后面会专门写一篇博客分享给大家，等不及的可以自己去找资料哈。 GoDaddy &amp; DNSPodGoDaddy是一家非常不错的域名注册商，良好的用户体验，飞快的生效速度，给力的优惠码，也支持支付宝，永远不用担心国内那些流氓厂商的流氓行为，注册了域名，就可以放心不会被别人抢走。在Godaddy注册域名是一件很简单的事情，按照提示走就完全没有问题，唯一需要动脑筋的可能是，你要想一个既有个人标识，又没有被别人注册的域名了，我觉得我的BeiYuu还是不错的，呵呵。 Godaddy一切都很完美，直到遇到了GFW，原因你肯定懂。前段时间推上风传Godaddy的DNS服务器被墙，导致域名不能解析，看起来好像自己的站被墙了一样，这个确实是个闹心的事情，还好国内有DNS服务的替代产品，而且做得还非常的不错，也是免费的，功能强大，速度快，不用担心被和谐，所以隆重推荐DNSPod给大家，可以试用一下，把DNS服务迁移到DNSPod来，解决后顾之忧，配置比较简单，不懂的可以等我后面的博客啦，哈。 GitHub &amp; JekyllGitHub是一个非常优秀的产品，爆发式的增长，各大优质开源软件的蜂涌而至，只能说明人们太需要他了。Social Coding是他的Slogan，产品的设计确实解决了很多代码交流的难题，让世界更平，让交流更畅，关于Git的学习，大家可以移步这里Pro Git中文版，这也是一个本身就在Github维护的一个项目，高质量的翻译了Git入门书，讲解详细，是学习Git的好资料。 GitHub是一个伟大的产品，GitHub Pages是他伟大的一部分，GitHub Pages基于Jekyll博客引擎，当我深入的研究了他之后，我深深的想给Jekyll的作者一个拥抱，列举一下Jekyll的优点： 可以单独放在自己的服务器上，他也是GitHub Pages的基础，质量可靠 将博客最重要的功能抽取出来，去除了WordPress的复杂、烦躁的东西，一切都是清晰可控的 可以方便的使用Markdown等其他标记语言 清晰、简洁的文件组织，完美的永久链接方案，既漂亮、又可定制博客静态化，速度快 Jekyll是完美的 DisqusJekyll都很不错，但是可能有些童鞋会不满意于他不提供评论功能，这个时候，Disqus的出现就显得是雪中送炭了。 Disqus是一个社会化的评论解决方案，请允许我使用这个烂透了的词，调用它的接口非常简单，在自己的页面加载他的一段JS代码即可，如果别人注册了Disqus，那么就可以方便的留言，交流，一处登录，处处方便，而且Disqus也提供了一些spam等策略，不用自己操心了，并且可以和一些现有的博客系统很好的转换对接。越来越多的网站开始使用Disqus的服务了，这是一个非常不错的趋势，Jekyll配合Disqus实在是完美了。我别无所求了。 TL;DR写到这里，基本的点已经介绍完毕，看看Jekyll生成的博客页面，我心满意足，虽然文笔很烂，语句多不通顺，但是这是一个新的开始了，我觉得心灵都纯洁了不少，这不是发一条微博什么能带来的快乐。 对于那些对上述技术不是很熟悉的童鞋来说，搭建起来可能还是需要花费些功夫的，我会在后面写一篇专门的教程，给有需要的人，等不及了的，可以自己研究下，生命在于折腾。]]></content>
    </entry>

    
  
  
</search>
